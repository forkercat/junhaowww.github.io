<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Making Sky&#39;s Stylized Grass with Compute Shader in Unity</title>
      <link href="/2021/03/06/050_Stylized-Sky-grass-in-Unity/"/>
      <url>/2021/03/06/050_Stylized-Sky-grass-in-Unity/</url>
      
        <content type="html"><![CDATA[<p><a href="https://thatskygame.com/">Sky: Children of the Light</a> is one of my favorite games I am playing recently. During the pandemic, it is a great place where we are able to meet people (or even friends) from all over the world. Beyond the plot, music, and cosmetics, I enjoyed every second when I was sliding on those beautiful lands, especially the stylized grass on top of them. In this post, I will share my experience in reproducing the grass in Unity under Universal Render Pipeline (v7.5.3). You will get result like the following:</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cyod1.png" alt="Sky&#39;s Stylized Grass in Unity"></p><span id="more"></span><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/niyql.JPG" alt="Stylized Grass in Sky: Children of the Light (in-game screenshot)"></p><p>Be aware that this post is not a tutorial, but you will find all the information you need from attached references (tutorial blogs, YouTube videos, etc) and the comments I wrote in source files. Unusually, I decided to use compute shaders because I develop on Metal API and it does not support geometry shaders. Don’t worry! It is much easier to implement the same effect in a geometry shader (less 1,000 lines of code I believe).</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2jp8m.gif" alt="Reproduce Sky&#39;s Stylized Grass in Unity"></p><h2 id="How-To-Set-Up-TL-DR"><a href="#How-To-Set-Up-TL-DR" class="headerlink" title="How To Set Up (TL;DR)"></a>How To Set Up (TL;DR)</h2><p>You can use the shaders and scripts I wrote right away. To make the shaders more usable in games, I paint the grass with the help of the <a href="https://www.youtube.com/watch?v=xKJHL8nQiuM&ab_channel=MinionsArt">painter tool</a> made by MinionsArt. Check out the website if you are interested in learning how the tool works from behind. I made some changes to the two original files to add shortcut and compute shader support.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><ol><li>Download three shader files<ol><li><a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrass-shader">SkylikeGrass.shader</a> (shader file)</li><li><a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrass-hlsl">SkylikeGrass.hlsl</a> (main shader logic that contains <code>vertex</code> and <code>fragment</code> functions)</li><li><a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasscompute-compute">SkylikeGrassCompute.compute</a> (compute shader)</li></ol></li><li>Create two materials that use <code>Grass/SkylikeGrass</code> shader.<ol><li><code>SkylikeStripMaterial</code> and set the <a href="https://github.com/forkercat/StorageBaseWithoutCatNotice/blob/main/grass_strip.png">strip texture</a></li><li><code>SkylikeCircleMaterial</code> and set the <a href="https://github.com/forkercat/StorageBaseWithoutCatNotice/blob/main/grass_circle_blur.png">circle texture</a></li><li>After importing texture files, go to inspector:<ol><li>Check <code>Alpha Is Transparency</code></li><li>Set <code>Wrap Mode</code> to <code>Clamp</code></li></ol></li></ol></li><li>Set up painter tool and renderer<ol><li>Download <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasspainter-cs">SkylikeGrassPainter.cs</a> and import</li><li>Download <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasspaintereditor-cs">SkylikeGrassPainterEditor.cs</a> and put it to <code>Assets/Editor</code></li><li>Download <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasscomputerenderer-cs">SkylikeGrassComputeRenderer.cs</a> and import</li></ol></li><li>Set up painting<ol><li>Create a plane where the painter tool draws on</li><li>Create an empty game object<ol><li>Add <code>SkylikeGrassPainter</code> script component</li><li>Add <code>SkylikeGrassComputeRenderer</code> script component</li><li>Manually set material and compute shader accordingly</li></ol></li></ol></li><li>Start painting!<ol><li>Make sure the empty game object is selected</li><li>Paint grass by holding any modifier key (e.g. <code>Shift</code>, <code>Ctrl</code>) and <code>right mouse button</code></li><li>Switch tool with any modifier key (e.g. <code>Shift</code>, <code>Ctrl</code>) and <code>middle mouse button</code></li></ol></li></ol><p>Hope you are enjoy this shader in your game! To get rid of setup overhead, it would be convenient if you prefab the empty object with a particular material, then next time you just drag the prefab to the scene to start painting. All the presets will be stored.</p><p>In addition, if you want to bring in interactive effect, download <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-shaderinteractor-cs">ShaderInteractor.cs</a> and attach it to your player object. You can find the original file from MinionsArt’s website as well.</p><h2 id="Painter-Tool"><a href="#Painter-Tool" class="headerlink" title="Painter Tool"></a>Painter Tool</h2><p>The painter tool is defined in <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasspainter-cs">SkylikeGrassPainter.cs</a> and <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasspaintereditor-cs">SkylikeGrassPainterEditor.cs</a>. Whenever you plant some grass on the ground, it will create a new mesh and store vertices which contain the information needed in our compute shader. Then this mesh will be accessed from <code>SkylikeGrassComputeRenderer</code> which uploads the data to compute shader. At the end of <code>SkylikeGrassPainter</code>, there are few lines doing the mesh work.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set all info to mesh</span></span><br><span class="line">mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">mesh.name = <span class="string">&quot;Grass Mesh - &quot;</span> + name;</span><br><span class="line">mesh.SetVertices(positions);</span><br><span class="line">indi = indices.ToArray();</span><br><span class="line">mesh.SetIndices(indi, MeshTopology.Points, <span class="number">0</span>);</span><br><span class="line">mesh.SetUVs(<span class="number">0</span>, grassSizeMultipliers);</span><br><span class="line">mesh.SetColors(colors);</span><br><span class="line">mesh.SetNormals(normals);</span><br><span class="line">filter.mesh = mesh;</span><br></pre></td></tr></table></figure><p><code>MeshTopology.Points</code> indicates that the program will treat vertices individually. This makes sense since grass only spawns on a particular location.</p><p>Beside vertices, we store size multipliers inside UV0 (channel 0). This <code>Vector2</code> allows us to assign particular size to each vertex. Therefore, without changing the grass size in <code>SkylikeGrassComputeRenderer</code>, we can use the painter tool to vary grass size easily. This applies to grass color as well.</p><p>Again, to know more about the tool, please check out MinionsArt’s website.</p><ul><li><a href="https://www.patreon.com/posts/geometry-grass-46836032">Geometry Grass Shader + Tool video + update</a> (by MinionsArt)</li></ul><h2 id="Compute-Shader"><a href="#Compute-Shader" class="headerlink" title="Compute Shader"></a>Compute Shader</h2><h3 id="Learning-Resources"><a href="#Learning-Resources" class="headerlink" title="Learning Resources"></a>Learning Resources</h3><p>Compute shaders provide the possibility that we can send processing tasks from CPU to GPU. These tasks include but is not limited to procedural generation (e.g. terrain creation), physics simulation, etc. In our case, we use them to replace the role of geometry shader in the graphics pipeline. Compute buffers are the places where these two processing units communicate data. We will define some data structures here.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/twin1.jpg" alt="Comparison between CPU and GPU (source is attached)"></p><p>There are a bunch of great tutorials regarding compute shaders. I recommend going over the following videos in order to have a conceptual and practical overview of this technique.</p><ol><li><a href="https://youtu.be/BrZ4pWwkpto">Getting Started with Compute Shaders in Unity</a> (by Game Dev Guide)</li><li><a href="https://youtu.be/EB5HiqDl7VE">Intro to Compute Shaders in Unity URP! Replace Geometry Shaders</a> (by NedMakesGames)</li></ol><p>From the first video, you basically learn what compute shader is and how it works. From the second one, it is more like a step-by-step tutorial that teaches you to create an interesting effect. The author also made several follow-up videos on using compute shaders in practice.</p><p>To be honest, once you have done the second one, you will find the setup very intimidating. Unlike using geometry shaders, everything has to be defined manually, which makes the code a bit lengthy and tedious. Also, during the procress you have to be careful, because it could be difficult to find out why it does not work. From my experience in Unity 2019 4.18 f1, it makes Unity crash more frequently as well. </p><p>Therefore, one tip is that if you execute the renderer script in <code>[ExecuteInEditMode]</code> every time before you update the script you’d better disable the object first and enable it after you believe the code is right.</p><h3 id="Rendering-Workflow"><a href="#Rendering-Workflow" class="headerlink" title="Rendering Workflow"></a>Rendering Workflow</h3><p>Once you are familiar with compute shaders, it is time to apply them to actual usage. Let us first recall what the rendering flow looks like if you use the geometry shader. Data from a mesh is uploaded to GPU’s buffers and gets passed down from vertex shaders to fragment shaders. Actually there are other shaders in between but here we just ignore them for now. The geometry shader is placed in the middle.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/5c7ag.png" alt="Rendering Workflow with Geometry Shaders"></p><p>However, if we use compute shaders to implement the same functionality, the ordering is quite different. In this case, the compute shader goes first. We use C# script to upload mesh data from CPU to GPU and to trigger the compute shader to start processing the data. This data will then be stored in a specific compute buffer from which the vertex shader can read the processed data (vertices and triangles). Compute Shaders are not placed between vertex and fragment shaders.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/44sn3.png" alt="Rendering Workflow with Compute Shaders"></p><p>As a novice to this topic, I felt confused because I did not notice the difference and still had the original workflow in my mind. Again, once you notice the difference, you will understand why those data structures in compute buffers are defined in such ways.</p><h3 id="Compute-Shader-Setup"><a href="#Compute-Shader-Setup" class="headerlink" title="Compute Shader Setup"></a>Compute Shader Setup</h3><p><strong>[Source Code]</strong> <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasscompute-compute">SkylikeGrassCompute.compute</a></p><p>To write a compute shader for our grass, we first need to define some structures to manage the data. Again, if you find something not being described here, please go through the two videos about compute shaders first!</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SourceVertex</span><br><span class="line">&#123;</span><br><span class="line">    float3 positionOS;</span><br><span class="line">    float3 normalOS;</span><br><span class="line">    float2 uv;      <span class="comment">// widthMultiplier, heightMultiplier</span></span><br><span class="line">    float3 color;   <span class="comment">// brush color</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> DrawVertex</span><br><span class="line">&#123;</span><br><span class="line">    float3 positionWS;</span><br><span class="line">    float2 uv;</span><br><span class="line">    float3 brushColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> DrawTriangle</span><br><span class="line">&#123;</span><br><span class="line">    float3 normalOS;</span><br><span class="line">    float3 pivotWS;         <span class="comment">// for billboard effect</span></span><br><span class="line">    DrawVertex vertices[<span class="number">3</span>]; <span class="comment">// three points on the triangle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>SourceVertex</code> represents the data from the mesh (remember the mesh is created by the painter tool). <code>DrawVertex</code> and <code>DrawTriangle</code> represent the data generated from this compute shader and they should be redefined in the vertex shader. Then we have the buffers as follows:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StructuredBuffer&lt;SourceVertex&gt;       _SourceVertices;</span><br><span class="line">AppendStructuredBuffer&lt;DrawTriangle&gt; _DrawTriangles;</span><br></pre></td></tr></table></figure><p>After that, we define some variables before writing the kernel function. They will be set up by the renderer script.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>      _NumSourceVertices;</span><br><span class="line">float4x4 _LocalToWorld;  <span class="comment">// UNITY_MATRIX_M</span></span><br><span class="line"><span class="type">float</span>    _CurrentTime;   <span class="comment">// _Time</span></span><br></pre></td></tr></table></figure><p>Note that in a compute shader we cannot access many built-in shader variables and functions such as <code>_Time</code>, <code>UNITY_MATRIX_M</code>, etc. We have to define them by ourselves and set them via C# scripts. It is a mistake you might make. Therefore, I recommend not including these <code>.hlsl</code> files at the first place. If you plan to use them, make sure the variables or functions you use are supported in compute shaders.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Grass-Texture-Plane"><a href="#Grass-Texture-Plane" class="headerlink" title="Grass Texture Plane"></a>Grass Texture Plane</h3><p>Before moving to the renderer section, let us understand how to draw the triangles needed to hold the grass texture.</p><p>If you are new to shader scripts, I suggest going over the following tutorials:</p><ol><li><a href="https://www.cyanilux.com/tutorials/intro-to-shaders/">Intro to Shaders</a> (by Cyanilux)</li><li><a href="https://roystan.net/articles/grass-shader.html">Grass Shader</a> (by Roystan)</li><li><a href="https://github.com/Unity-Technologies/Graphics/tree/master/com.unity.render-pipelines.universal/Shaders">Unity URP Shader Examples</a></li></ol><p>The first one teaches you HLSL shaders from scratch, while the second one is a good practical tutorial to help you get more familiar with shader scripts and geometry shader (but it is not written for URP).  Unity URP shader examples are also a great place where you can find answers to your questions.</p><p>To display a texture, we need two triangles to make up a plane to hold the texture. At the end of the shader, we append these two triangles (six vertices) to <code>_DrawTriangles</code> buffer.</p><h4 id="Size-Variations"><a href="#Size-Variations" class="headerlink" title="Size Variations"></a>Size Variations</h4><p>Texture size is defined by <code>_TexWidth</code> and <code>_TexHeight</code>. The size can further be changed by two ways: </p><ol><li>Multipliers from painter brush</li><li>Randomness</li></ol><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_TexWidth *= sv.uv.x;   <span class="comment">// width multiplier</span></span><br><span class="line">_TexHeight *= sv.uv.y;  <span class="comment">// height multiplier</span></span><br><span class="line"></span><br><span class="line">_TexWidth *= <span class="built_in">clamp</span>(rand(sv.positionOS.zyx), <span class="number">1</span> - _TexRandomWidth, <span class="number">1</span> + _TexRandomWidth);</span><br><span class="line">_TexHeight *= <span class="built_in">clamp</span>(rand(sv.positionOS.xyz), <span class="number">1</span> - _TexRandomHeight, <span class="number">1</span> + _TexRandomHeight);</span><br><span class="line"><span class="comment">// for uniform size</span></span><br><span class="line"><span class="type">float</span> sizeMultiplier = <span class="built_in">clamp</span>(rand(sv.positionOS.yxz), <span class="number">1</span> - _TexRandomSize, <span class="number">1</span> + _TexRandomSize);</span><br><span class="line">_TexWidth *= sizeMultiplier;</span><br><span class="line">_TexHeight *= sizeMultiplier;</span><br></pre></td></tr></table></figure><p>Vertex positions are defined by <code>_TexFloatHeight</code>, size, and absolute world directions (<code>world up</code>, <code>world right</code>). Rotating the object does not affect the rotation of grass.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8tx4z.png" alt="Triangles on Different Types of Surfaces"></p><h4 id="Wind"><a href="#Wind" class="headerlink" title="Wind"></a>Wind</h4><p>To apply swaying effect on grass, vertex positions are changed based on <code>_CurrentTime</code>. However, rather than using absolute world directions, we go with directions based on the surface (something like the basis vectors in tangent space).</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/h16u4.gif" alt="Swaying on the Surface"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float3 v0 = sv.positionOS.xyz;</span><br><span class="line">float2 windOffset = float2(<span class="built_in">sin</span>(_CurrentTime.x * _WindSpeed + v0.x)</span><br><span class="line">                               + <span class="built_in">sin</span>(_CurrentTime.x * _WindSpeed + v0.z * <span class="number">2</span>)</span><br><span class="line">                               + <span class="built_in">sin</span>(_CurrentTime.x * _WindSpeed * <span class="number">0.1</span> + v0.x),  <span class="comment">// right</span></span><br><span class="line">                           <span class="built_in">cos</span>(_CurrentTime.x * _WindSpeed + v0.x * <span class="number">2</span>)</span><br><span class="line">                               + <span class="built_in">cos</span>(_CurrentTime.x * _WindSpeed + v0.z));  <span class="comment">// forward</span></span><br><span class="line"><span class="type">float</span> windLeaningOffset = windOffset.x * _WindLeaningDist * <span class="number">0.01</span>;</span><br><span class="line">windOffset *= _WindStrength * <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/j1w4w.gif" alt="Leaning Effect"></p><p>The variable <code>windLeaningOffset</code> controls the amount of distance that the grass leans. Currently it just leans randomly. If you are interested in making the effect that the grass leans towards the direction it moves, check out the code <a href="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0u3hh.png">here</a>. It is a bit tricky to get the actual moving direction because we will apply billboard effect to the grass in the vertex shader, which make it always face the camera.</p><h4 id="Interactivity"><a href="#Interactivity" class="headerlink" title="Interactivity"></a>Interactivity</h4><p>The code snippet comes from <a href="https://www.patreon.com/posts/grass-geometry-1-40090373">here</a>. It is straightforward.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/paz32.gif" alt="Interactivity"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interactivity</span></span><br><span class="line">float3 dis = <span class="built_in">distance</span>(_MovingPosition, positionWS);</span><br><span class="line">float3 radius = <span class="number">1</span> - saturate(dis / _InteractorRadius);</span><br><span class="line"><span class="comment">// in world radius based on objects interaction radius</span></span><br><span class="line">float2 interactorOffset = positionWS.xz - _MovingPosition.xz; <span class="comment">// position comparison</span></span><br><span class="line">interactorOffset *= radius; <span class="comment">// position multiplied by radius for falloff</span></span><br><span class="line"><span class="comment">// increase strength</span></span><br><span class="line">interactorOffset = <span class="built_in">clamp</span>(interactorOffset.xy * _InteractorStrength, <span class="number">-0.8</span>, <span class="number">0.8</span>);</span><br></pre></td></tr></table></figure><h4 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h4><p>Applying LOD is a great way to improve performance in a large outdoor environment. When the distance between the grass and the camera is greater than <code>_HideDistance</code>, the grass does not show up.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/usb0f.gif" alt="Level of Detail (LOD), Hide Distance = 20"></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float3 positionWS = mul(_LocalToWorld, float4(sv.positionOS, <span class="number">1</span>)).xyz;</span><br><span class="line"><span class="built_in">float</span> distanceFromCamera = distance(positionWS, _CameraPositionWS);</span><br><span class="line"><span class="keyword">if</span> (distanceFromCamera &gt; _HideDistance)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Combined"><a href="#Combined" class="headerlink" title="Combined"></a>Combined</h4><p>With all the offset calculations above, it is ready to put them into a function and set up the output data.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate each vertex for output triangles</span></span><br><span class="line">DrawVertex GenerateVertex(float3 positionWS, float3 rightDirWS, float3 forwardDirWS,</span><br><span class="line">                          <span class="type">float</span> startHeight, <span class="type">float</span> verticalOffset, <span class="type">float</span> horizonOffset,</span><br><span class="line">                          float2 windOffset, <span class="type">float</span> windLeaningOffset, float2 interactorOffset,</span><br><span class="line">                          float2 uv, float3 color)</span><br><span class="line">&#123;</span><br><span class="line">    DrawVertex output;</span><br><span class="line">    <span class="comment">// Position</span></span><br><span class="line">    positionWS += float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>) * (startHeight + verticalOffset);</span><br><span class="line">    positionWS += float3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) * horizonOffset;</span><br><span class="line">    <span class="comment">// Offset</span></span><br><span class="line">    positionWS += rightDirWS * (windOffset.x + windLeaningOffset - interactorOffset.x);</span><br><span class="line">    positionWS += forwardDirWS * (windOffset.y - interactorOffset.y);  <span class="comment">// forward</span></span><br><span class="line">    output.positionWS = positionWS;</span><br><span class="line">    <span class="comment">// UV</span></span><br><span class="line">    output.uv = uv;</span><br><span class="line">    <span class="comment">// Color</span></span><br><span class="line">    output.brushColor = color;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Main(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bottom-Left Triangle</span></span><br><span class="line">    DrawTriangle tri = (DrawTriangle) <span class="number">0</span>;</span><br><span class="line">    tri.<span class="keyword">vertices</span>[<span class="number">0</span>] = GenerateVertex(positionWS, surfaceRightDirWS, surfaceForwardDirWS,</span><br><span class="line">                                    _TexFloatHeight, <span class="number">0</span>, -_TexWidth / <span class="number">2</span>, windOffset, -windLeaningOffset,</span><br><span class="line">                                    interactorOffset, float2(<span class="number">1</span>, <span class="number">0</span>), sv.color);</span><br><span class="line">    tri.<span class="keyword">vertices</span>[<span class="number">1</span>] = GenerateVertex(positionWS, surfaceRightDirWS, surfaceForwardDirWS,</span><br><span class="line">                                    _TexFloatHeight, <span class="number">0</span>, _TexWidth / <span class="number">2</span>, windOffset, -windLeaningOffset,</span><br><span class="line">                                    interactorOffset, float2(<span class="number">0</span>, <span class="number">0</span>), sv.color);</span><br><span class="line">    tri.<span class="keyword">vertices</span>[<span class="number">2</span>] = GenerateVertex(positionWS, surfaceRightDirWS, surfaceForwardDirWS,</span><br><span class="line">                                    _TexFloatHeight, _TexHeight, -_TexWidth / <span class="number">2</span>, windOffset, windLeaningOffset,</span><br><span class="line">                                    interactorOffset, float2(<span class="number">1</span>, <span class="number">1</span>), sv.color);</span><br><span class="line">    tri.normalWS = worldUp;</span><br><span class="line">    float3 pivotWS = (tri.<span class="keyword">vertices</span>[<span class="number">1</span>].positionWS + tri.<span class="keyword">vertices</span>[<span class="number">2</span>].positionWS) / <span class="number">2.0</span>;</span><br><span class="line">    tri.pivotWS = pivotWS;</span><br><span class="line">    _DrawTriangles.Append(tri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Top-Right triangle</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Renderer-Setup"><a href="#Renderer-Setup" class="headerlink" title="Renderer Setup"></a>Renderer Setup</h3><p><strong>[Source Code]</strong> <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrasscomputerenderer-cs">SkylikeGrassComputeRenderer.cs</a></p><p>At this time, we have finished writing the compute shader. Rather than using <code>MeshRenderer</code>, we write up our own renderer script to execute the task in the compute shader and trigger drawing methods.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkylikeGrassComputeRenderer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Structure</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> SourceVertex</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Vector3 position; <span class="keyword">public</span> Vector3 normal;</span><br><span class="line">        <span class="keyword">public</span> Vector2 uv;       <span class="keyword">public</span> Vector3 color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definitions of Buffers, Stride Constants, etc</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set up components</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Initialize</span></span><br><span class="line">        <span class="comment">// Set up buffer data and upload it to GPU</span></span><br><span class="line">        m_Initialized = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Initialized)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Release buffers</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_Initialized = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Refresh the output buffer</span></span><br><span class="line">        <span class="comment">// Update data (e.g. _CurrentTime, _LocalToWorld, etc)</span></span><br><span class="line">        <span class="comment">// Draw</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h2><p><strong>[Source Code]</strong> <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrass-shader">SkylikeGrass.shader</a>, <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrass-hlsl">SkylikeGrass.hlsl</a></p><p>Following the tutorial made by NedMakesGames, I found that splitting code into <code>.shader</code> and <code>.hlsl</code> files is a good way to organize lengthy shader code. In the <code>.shader</code> file, it mainly sets up SubShader, Pass, and enable keywords we need. In the <code>.hlsl</code> file, it first defines the buffer and structures we used before in the compute shader, which are <code>DrawVertex</code> and <code>DrawTriangle</code>. After that, it contains vertex and fragment functions.</p><p>Unlike many other vertex functions, in our case we retrieve the data by <code>SV_VertexID</code>. Once we have the data, we set it up in a <code>v2f</code> struct so the fragment function is able to retrieve the data it needs.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(<span class="type">uint</span> vertexID : SV_VertexID)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Initialize the output struct</span></span><br><span class="line">    v2f output;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the vertex from the buffer</span></span><br><span class="line">    DrawTriangle tri = _DrawTriangles[vertexID / <span class="number">3</span>];</span><br><span class="line">    DrawVertex input = tri.<span class="keyword">vertices</span>[vertexID % <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To achieve the billboard effect, we need to transform vertex positions such that the plane is always facing our main camera. There are already a bunch of methods existing on the Internet. I found the following video helpful.</p><ul><li><a href="https://www.youtube.com/watch?v=qGppGvgw7Dg&t=982s&ab_channel=Aperium">Unity Shader Tutorial - Billboard Shader</a> (by Aperium)</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Billboard</span></span><br><span class="line">float4 pivotWS = float4(tri.pivotWS, <span class="number">1</span>);</span><br><span class="line">float4 pivotVS = mul(UNITY_MATRIX_V, pivotWS);</span><br><span class="line"></span><br><span class="line">float4 worldPos = float4(input.positionWS, <span class="number">1</span>);</span><br><span class="line">float4 flippedWorldPos = float4(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>) * (worldPos - pivotWS) + pivotWS;</span><br><span class="line">float4 viewPos = flippedWorldPos - pivotWS + pivotVS;</span><br><span class="line">output.positionCS = mul(UNITY_MATRIX_P, viewPos);</span><br></pre></td></tr></table></figure><p>This code is pretty much the same with the one in the video. The pivot position of the grass plane is calculated in the compute shader. </p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vfeyh.png" alt="Calculate New View Position (ignore flipped world position)"></p><p>Personally, I did not completely understand all the detail, but I think it has something to do with the view matrix. It has changed what the matrix previously does such that it can rotate the grass plane towards us. Note that in the illustration it just ignores flipping, which is explained in the video. If you know this well, please teach me in the comment!</p><h2 id="Fragment-Shader"><a href="#Fragment-Shader" class="headerlink" title="Fragment Shader"></a>Fragment Shader</h2><p><strong>[Source Code]</strong> <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrass-shader">SkylikeGrass.shader</a>, <a href="https://gist.github.com/forkercat/fb6c030c17fe1e109a34f1c92571943f#file-skylikegrass-hlsl">SkylikeGrass.hlsl</a></p><p>In fragment shader, base color is lerped between <code>_BaseColor</code> and <code>_TopColor</code> based on the Y texture coordinate. I use two colors here but you can definitely turn it into one only. By multiplying the result with brush color, we are able to override the color for each grass entity via the painter tool.</p><p>Both ambient and diffuse components contribute to final color. You can tweak ambient strength to make it look good in a night scene, then increase diffuse strength to what you want. Setting a larger diffuse color sometimes gives you better result if you have bloom effect enabled.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Light mainLight = GetMainLight();</span><br><span class="line"></span><br><span class="line">float3 baseColor = lerp(_BaseColor, _TopColor, saturate(input.uv.y)) * input.brushColor;</span><br><span class="line"></span><br><span class="line">float3 ambient = baseColor * _AmbientStrength;</span><br><span class="line">float3 diffuse = baseColor * _DiffuseStrength;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(mainLight.direction, input.normalWS));</span><br><span class="line">diffuse *= NdotL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Combine</span></span><br><span class="line">float4 combined = float4(ambient + diffuse, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>If you watch the grass carefully in Sky, you should notice that the grass is highlighted when players tramping on top of it. It is a subtle effect but I found it very interesting and the implementation is not difficult once you have the speed percentage along the moving direction of your player object (<code>current speed</code> &#x2F; <code>max speed</code>).</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/641jj.gif" alt="Highlighted Grass in Sky: Children of the Light"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interactor Highlight</span></span><br><span class="line"><span class="type">float</span> distFromMovingPosition = <span class="built_in">distance</span>(_MovingPosition, input.positionWS);</span><br><span class="line"><span class="keyword">if</span> (distFromMovingPosition &lt; _HighlightRadius)</span><br><span class="line">&#123;</span><br><span class="line">    combined.rgb *= (<span class="number">1</span> + _MovingSpeedPercent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At this point, you should be able to see an opaque and rectangular plane swaying above the surface. To make it look better, we enable alpha testing and transparency in <code>.shader</code> file, sample the alpha channel of the texture, and multiply it with the combined RGB and alpha values.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/sypqs.png" alt="Enable Transparency"></p><p>You can find the texture files at the beginning of this article. If you are a creative person, you can definitely create your own textures to make it more aesthetic.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Texture Mask Color (pure white + alpha)</span></span><br><span class="line">half4 texMaskColor = SAMPLE_TEXTURE2D(_BaseTex, sampler_BaseTex, input.uv);</span><br><span class="line"><span class="keyword">return</span> combined * texMaskColor;  <span class="comment">// I also multiply rgb values, but it is okay if it is pure white</span></span><br></pre></td></tr></table></figure><h2 id="Other-Stuff"><a href="#Other-Stuff" class="headerlink" title="Other Stuff"></a>Other Stuff</h2><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>So far, I have not noticed any performance issue. Although after adding a huge amount of grass to the scene and even at the same time turning off LOD, there is no significant drop of FPS. I will follow up on that if I discover any issue.</p><h3 id="Known-Issues"><a href="#Known-Issues" class="headerlink" title="Known Issues"></a>Known Issues</h3><ol><li>Shadow cast does not work as expected. Currently I do not figure out why. It has some weird effect. If two renderers enable shadow cast at the same time, it starts blinking. However, for my game, I do not intend to enable shadow cast for now.</li><li>In Metal, the console sometimes pops up many warnings, which is annoying. Is it a bug? I haven’t not found a solution to that yet.</li></ol><p>Thanks for reading! If you like this grass, please let me know in the comment!</p><h2 id="References-Credits"><a href="#References-Credits" class="headerlink" title="References &amp; Credits"></a>References &amp; Credits</h2><ul><li>MinionsArt<ul><li><a href="https://www.youtube.com/watch?v=xKJHL8nQiuM&ab_channel=MinionsArt">Unity - I made an Interactive Grass Shader + Tool</a></li><li><a href="https://www.patreon.com/posts/geometry-grass-46836032">Geometry Grass Shader + Tool video + update</a></li><li><a href="https://www.patreon.com/posts/grass-geometry-1-40090373">Grass Geometry Shader with Interactivity (Part 1, the shader)</a></li><li><a href="https://www.patreon.com/posts/grass-geometry-2-40077798">Grass Geometry Shader with Interactivity (Part 2, the editor tool)</a></li><li><a href="https://www.patreon.com/posts/geometry-grass-47447321">Geometry Grass Shader for URP</a></li></ul></li><li>Ned Makes Game<ul><li><a href="https://www.youtube.com/watch?v=EB5HiqDl7VE&ab_channel=NedMakesGames">Intro to Compute Shaders in Unity URP! Replace Geometry Shaders</a></li><li><a href="https://www.youtube.com/watch?v=DeATXF4Szqo&ab_channel=NedMakesGames">Grass Fields in Unity URP! Generate Blades with Compute Shaders!</a></li></ul></li><li>Game Dev Guide: <a href="https://www.youtube.com/watch?v=BrZ4pWwkpto&ab_channel=GameDevGuide">Getting Started with Compute Shaders in Unity</a></li><li>Kyle Halladay: <a href="http://kylehalladay.com/blog/tutorial/2014/06/27/Compute-Shaders-Are-Nifty.html">Getting Started With Compute Shaders In Unity</a></li><li>Cyanilux: <a href="https://www.cyanilux.com/tutorials/intro-to-shaders/">Intro to Shaders</a></li><li>Roystan: <a href="https://roystan.net/articles/grass-shader.html">Grass Shader</a></li><li>Unity-Technologies: <a href="https://github.com/Unity-Technologies/Graphics/tree/master/com.unity.render-pipelines.universal/Shaders">URP Shader Examples</a></li><li>Aperium: <a href="https://www.youtube.com/watch?v=qGppGvgw7Dg&t=982s&ab_channel=Aperium">Unity Shader Tutorial - Billboard Shader</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Grass </tag>
            
            <tag> Shader </tag>
            
            <tag> Compute Shader </tag>
            
            <tag> Sky </tag>
            
            <tag> URP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understand Interface and Abstract Class in Java</title>
      <link href="/2019/11/12/049_Understand%20Interface%20and%20Abstract%20Class%20in%20Java/"/>
      <url>/2019/11/12/049_Understand%20Interface%20and%20Abstract%20Class%20in%20Java/</url>
      
        <content type="html"><![CDATA[<p><code>Interface</code> and <code>abstract class</code> are similar that I was sometimes confused about their differences, or didn’t know when I should use each. There are a lot of posts about their differences in terms of usage details, but many of them do not cover differences in design. I looked up on the internet and summarized some key points I learned.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/f8pqi.jpg" alt="Java Interfaces vs. Abstract Classes, by Jakob Jenkov"></p><span id="more"></span><p>Reference:</p><ul><li><a href="https://www.zhihu.com/question/20149818">接口和抽象类有什么区别？</a></li><li>Java 廖雪峰基础教程</li><li><a href="https://www.junhaow.com/studynotes/cs61b/cs61b%20p2.html">CS 61B | Part 2</a></li><li><a href="https://www.softwaretestinghelp.com/core-java-interview-questions/">Top 50+ Core Java Interview Questions And Answers</a></li><li><a href="https://www.zhihu.com/question/41166418">Java 8接口有default method后是不是可以放弃抽象类了？</a></li></ul><h2 id="Design-Aspect"><a href="#Design-Aspect" class="headerlink" title="Design Aspect"></a>Design Aspect</h2><p><strong>First</strong>, we should explore why language designers have created these two things (understand their purposes). In essence, <code>actions</code> are abstracted by interfaces, while <code>roots of classes</code> are abstracted by abstract classes. By saying roots of classes, they refer to the essence or origin of those classes.</p><p>For example, in terms of eating, we can define an interface <code>IEat</code> that abstracts all kinds of eat actions (eat by forks, eat by hands). It is reasonable that a class can implement multiple interfaces, say a man can have multiple ways of eating. As for abstract classes, <code>Man</code> and <code>Woman</code> classes can be abstracted by a <code>Human</code> abstract class. We cannot instantiate a <code>Human</code> class since it is abstract, but we can do that for its concrete subclasses. A class inherits from only one abstract class. We don’t allow a <code>Man</code> subclassing from a <code>Human</code> class and an <code>Animal</code> class at the same time, which is irrational.</p><p><strong>Second</strong>, we see how they are applied in Java class design.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ap3pq.png" alt="List Hierarchy"></p><p><code>Iterable</code>, <code>Collection</code>, <code>List</code> are interfaces. From this illustration, we can say that:</p><ul><li><strong>Idea #1:</strong> Interfaces represent levels of abstraction.</li><li><strong>Idea #2:</strong> Abstract classes are used to put publicly shared logic.</li><li><strong>Idea #3:</strong> Abstraction levels: <code>Interface</code> &gt; <code>Abstract Class</code> &gt; <code>Implementation Class</code></li></ul><p>Then, let’s have a look at the more complex illustration in CS 61B lecture notes.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/06diu.png" alt="The Whole Shebang, CS 61B"></p><p>In fact, <code>ArrayList</code>, <code>AbstractList</code>, <code>AbstractCollection</code> all implement <code>List</code> interface. I temporarily don’t know why it is designed that way.</p><p>The takeaway of this part is to understand the three ideas above, understanding that the major role of interfaces is to define levels of abstraction.</p><h2 id="Usage-Aspect"><a href="#Usage-Aspect" class="headerlink" title="Usage Aspect"></a>Usage Aspect</h2><p><strong>Similarity:</strong></p><ol><li>Both of them cannot be instantiated. Only their concrete subclasses can be done in this way.</li><li>In an interface, default modifiers for methods are <code>public</code>, <code>abstract</code>.</li><li>Both require implementations of all abstract methods. In a subclass inheriting from an abstract class, if abstract methods are not implemented, the subclass should also be defined as an abstract class. Also, all abstract methods cannot be <code>static</code> and <code>private</code>.</li></ol><p><strong>Differences:</strong></p><ol><li>A class can implement <code>multiple interfaces</code>, while it can only inherit from <code>one abstract class</code>.</li><li>An interface only allows method <code>declaration</code>, while an abstract class allows both <code>declaration</code> and <code>implementation</code>. So, we can say that <strong>interfaces are for design and abstract classes are for refactoring</strong>. <span class="purple">Marked</span></li><li>An abstract class can have no abstract methods. <span class="purple">weird</span></li><li>An interface allows <code>static final member variables</code> (constants), but instance variables. An abstract class can have <code>instance variables</code>.</li><li>An interface doesn’t have any <code>constructor</code>, while an abstract class have a <code>default constructor</code> and it is called whenever the concrete subclass is instantiated.</li></ol><h2 id="Default-Method-in-Java-8"><a href="#Default-Method-in-Java-8" class="headerlink" title="Default Method in Java 8"></a>Default Method in Java 8</h2><p>In Java 8, an interface has default methods in which we can write implementation logic. The purpose of adding this new feature is that adding new methods does not require us to modify the code in the class that implements this interface (no re-compilation).</p><p>For example, in Java SE 7, there is no <code>sort()</code> in <code>List</code>; and in Java SE 8, <code>sort()</code> is added in <code>List</code>. If we had a class <code>MyList</code> implements <code>List</code> in the pass and <code>sort()</code> in Java SE 8 is not a default method, we need to implement <code>sort()</code> in <code>MyList</code> and re-compile the source file. With the help of default methods, the default implementation is provided. <code>MyList</code> won’t be changed.</p><p>Also, we notice that although we have default methods in Java 8, they cannot replace abstract classes because they don’t have states (instance variables).</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A General Approach to Convert Recursion to Iteration</title>
      <link href="/2019/09/21/048_A%20General%20Appraoch%20to%20Convert%20Recursion%20to%20Iteration/"/>
      <url>/2019/09/21/048_A%20General%20Appraoch%20to%20Convert%20Recursion%20to%20Iteration/</url>
      
        <content type="html"><![CDATA[<p>Generally, we prefer to write recursive solutions for tree, linked list, backtracking, and DFS&#x2F;BFS problems since the structure of these problems could be recursively defined.</p><blockquote><p>Recursion is good choice for search, enumeration, and divide-and-conquer. — EPI</p></blockquote><p>Thus, the steps that lie in the recursive function correspond to the way we think of the problem. Later, we will see how the code of preorder traversal works and then convert it to an iterative version, and finally to an optimized iterative version that we usually write if an iterative version is required.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursive version (Easy to Read)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// base case</span></span><br><span class="line">  foo(root); <span class="comment">// print or ...</span></span><br><span class="line">  preorder(root.left);</span><br><span class="line">  preorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="No-Stack-Tail-Recursion"><a href="#No-Stack-Tail-Recursion" class="headerlink" title="No Stack (Tail-Recursion)"></a>No Stack (Tail-Recursion)</h2><p>In the past, many people told me that every recursive function could be rewritten as an iterative function. It is true, but when I start writing the code I usually get confused of storing parameters and intermediate return values.</p><p>As for the intermediate return values, I learned that recursion can be easily removed from a <strong>tail-recursive</strong> program by using a while-loop—no stack is needed (from EPI). Let’s take factorial computation as an example.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not a tail-recursive version</span></span><br><span class="line"><span class="comment">// returns n * (n - 1) * ... * 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The above function is not tail-recursive because we store <code>n</code> in the stack frame along the way. Its value would be used after we get the returned value from <code>factorial(n - 1)</code>.</p><p>One common way of converting a recursive function to a tail-recursive function is <strong>by passing the values we would have stored by parameters</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(factorial(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// A tail-recursive version</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> result)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">  result *= n;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can also implement it iteratively without much effort.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-Return-Value-Tree-Traversal-by-Me"><a href="#No-Return-Value-Tree-Traversal-by-Me" class="headerlink" title="No Return Value (Tree Traversal), by Me"></a>No Return Value (Tree Traversal), by Me</h2><h3 id="General-Conversion"><a href="#General-Conversion" class="headerlink" title="General Conversion"></a>General Conversion</h3><p>Now let’s go through the example of tree preorder traversal to illustrate how we convert a recursive function to an iterative one.</p><p>First, we need to <code>mark states</code> in the recursive function. We mark states at the beginning of the function and after each call of recursive calls.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">  <span class="comment">// S1: begin</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// base case</span></span><br><span class="line">  foo(root); <span class="comment">// print or ...</span></span><br><span class="line">  preorder(root.left);</span><br><span class="line">  <span class="comment">// S2: left done</span></span><br><span class="line">  preorder(root.right);</span><br><span class="line">  <span class="comment">// S3: finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since we have one parameter, two stacks are required. The extra one is for states. In the while loop, we handle each state respectively. Here is the code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderItr</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">  <span class="comment">// Init</span></span><br><span class="line">  Stack&lt;TreeNode&gt; nodeST = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  Stack&lt;String&gt; stateST = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (nodeST.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// pop a node</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> nodeST.pop(); <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stateST.pop();</span><br><span class="line">    <span class="comment">// handle each state respectively</span></span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;S1: begin&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// return --&gt; continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      foo(root); <span class="comment">// print or ...</span></span><br><span class="line">      nodeST.push(x); stateST.push(<span class="string">&quot;S2: left done&quot;</span>);</span><br><span class="line">      nodeST.push(x.left); stateST.push(<span class="string">&quot;S1: begin&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">&quot;S2: left done&quot;</span>)) &#123;</span><br><span class="line">      nodeST.push(x); stateST.push(<span class="string">&quot;S3: finish&quot;</span>);</span><br><span class="line">      nodeST.push(x.right); stateST.push(<span class="string">&quot;S1: begin&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// State 3: finish</span></span><br><span class="line">      <span class="comment">// at the end of the function, so do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code is quite long, but it actually looks well-organized. After “stressful” examination, you might wonder how the two lines of code below work:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeST.push(x); stateST.push(<span class="string">&quot;S2: left done&quot;</span>);</span><br><span class="line">nodeST.push(x.left); stateST.push(<span class="string">&quot;S1: begin&quot;</span>);</span><br></pre></td></tr></table></figure><p>Here is the idea. Before doing a recursive call, we should do two things:</p><ol><li>Save the current state (<code>stateST.push(S2: left done)</code>)</li><li>Push the new state (<code>stateST.push(S1: begin)</code>)</li></ol><p>If you think it is difficult to understand how it works, consider the fact that the state helps direct us to the specific code segment in the loop. For example, the new state always goes with the state <code>S1: begin</code> because we will do it from the beginning of the function.</p><p><strong>Note:</strong> The order matters! Since stack is an <code>FILO</code> structure, we should push the current state such that we could retrieve it later after we handle the new state.</p><p>By now, you should have seen that the iterative version that works well. However, it looks pretty wordy to some extent. In the next section, you will see how it is converted to a version that we often encounter.</p><h3 id="Further-Optimization"><a href="#Further-Optimization" class="headerlink" title="Further Optimization"></a>Further Optimization</h3><p>The iterative version we usually encounter is as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderItr</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">  <span class="comment">// Init</span></span><br><span class="line">  Stack&lt;TreeNode&gt; nodeST = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (nodeST.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// pop a node</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> nodeST.pop();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123; <span class="comment">// base case</span></span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// return --&gt; continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo(root); <span class="comment">// print or ...</span></span><br><span class="line">    nodeST.push(x.right);</span><br><span class="line">    nodeST.push(x.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In fact, we will modify the wordy code in the previous section and get the above code.</p><p>First, we can safely remove the last state <code>S3: finish</code> because there is no code inside the <code>else</code> branch. The statement <code>nodeST.push(x); stateST.push(&quot;S3: finish&quot;);</code> is also removed. Think about it why.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (nodeST.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// pop a node</span></span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> nodeST.pop(); <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stateST.pop();</span><br><span class="line">  <span class="comment">// handle each state respectively</span></span><br><span class="line">  <span class="keyword">if</span> (s.equals(<span class="string">&quot;S1: begin&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123; <span class="comment">// base case</span></span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// return --&gt; continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo(root); <span class="comment">// print or ...</span></span><br><span class="line">    nodeST.push(x); stateST.push(<span class="string">&quot;S2: left done&quot;</span>); <span class="comment">// A</span></span><br><span class="line">    nodeST.push(x.left); stateST.push(<span class="string">&quot;S1: begin&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// S2: left done</span></span><br><span class="line">    nodeST.push(x.right); stateST.push(<span class="string">&quot;S1: begin&quot;</span>); <span class="comment">// B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Then it comes to the most interesting part. We will delete <code>A</code> and put <code>B</code> into that spot. As mentioned before, we could safely remove the empty <code>else</code> if there is no code in it. <strong>Why?</strong></p><p>Try to ponder it in this way. The intention of <code>A</code> is to execute the code in <code>S2: left done</code>. We can put the job in <code>B</code> over here. Notice that by doing <code>A</code> we actually create a signal that notifies us to do the job in <code>B</code>, which also creates a signal <code>S1: begin</code> inside the stack to notify some future execution. Therefore, we can cut the indirect process and integrate two parts. Here is the code after the modification.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (nodeST.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// pop a node</span></span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> nodeST.pop(); <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stateST.pop();</span><br><span class="line">  <span class="comment">// handle each state respectively</span></span><br><span class="line">  <span class="keyword">if</span> (s.equals(<span class="string">&quot;S1: begin&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123; <span class="comment">// base case</span></span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// return --&gt; continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo(root); <span class="comment">// print or ...</span></span><br><span class="line">    nodeST.push(x.right); stateST.push(<span class="string">&quot;S1: begin&quot;</span>); <span class="comment">// B</span></span><br><span class="line">    nodeST.push(x.left); stateST.push(<span class="string">&quot;S1: begin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Finally, since there is only one state, we can remove the outer <code>if statement</code> and also delete the <code>stateST</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (nodeST.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// pop a node</span></span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> nodeST.pop(); <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stateST.pop();</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123; <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// return --&gt; continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo(root); <span class="comment">// print or ...</span></span><br><span class="line">  nodeST.push(x.right); stateST.push(<span class="string">&quot;S1: begin&quot;</span>); <span class="comment">// B</span></span><br><span class="line">  nodeST.push(x.left); stateST.push(<span class="string">&quot;S1: begin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>By now, is there any difference between the code above and the iterative version we usually encounter?</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7zcka.jpg"></p><h2 id="With-Return-Value-Symmetric-Tree-by-Elon-Xu"><a href="#With-Return-Value-Symmetric-Tree-by-Elon-Xu" class="headerlink" title="With Return Value (Symmetric Tree), by Elon Xu"></a>With Return Value (Symmetric Tree), by Elon Xu</h2><p>Cont’d</p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Iteration </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意 Java 中数组和范型的协变性（Covariant）</title>
      <link href="/2019/02/26/047_%E6%B3%A8%E6%84%8F%20Java%20%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98%E6%80%A7%EF%BC%88Covariant%EF%BC%89/"/>
      <url>/2019/02/26/047_%E6%B3%A8%E6%84%8F%20Java%20%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98%E6%80%A7%EF%BC%88Covariant%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的协变性"><a href="#数组的协变性" class="headerlink" title="数组的协变性"></a>数组的协变性</h2><p>如果类 <code>Base</code> 是类 <code>Derived</code> 的父类，那么 <code>Base[]</code> 就是 <code>Derived[]</code> 的父类。</p><p>因此，我们的代码可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number[] array1 = <span class="keyword">new</span> <span class="title class_">Number</span>[<span class="number">2</span>];</span><br><span class="line">array1[<span class="number">0</span>] = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">array1[<span class="number">1</span>] = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">System.out.println(array1[<span class="number">0</span>]);  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">Number[] array2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">array2[<span class="number">0</span>] = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">array2[<span class="number">1</span>] = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">System.out.println(array2[<span class="number">0</span>]);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>但是，数组的协变性可能会导致一些难以发现的错误，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Error A */</span></span><br><span class="line">Object[] array3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">array3[<span class="number">0</span>] = <span class="number">10</span>;  <span class="comment">// -&gt; array[0] = Integer.valueOf(10)</span></span><br></pre></td></tr></table></figure><p><code>Error A</code> 可以通过编译，<code>Object[]</code> 类型的引用（注意左边是引用）可以指向一个 <code>String[]</code> 类型的对象。但是，这在运行的时候会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayStoreException: java.lang.Integer</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Error B */</span></span><br><span class="line">Number[] array4 = <span class="keyword">new</span> <span class="title class_">Number</span>[<span class="number">2</span>];</span><br><span class="line">array4[<span class="number">0</span>] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>Error B</code>这种错误可以在编译的时候出现。</p><h2 id="范型类不具有协变性"><a href="#范型类不具有协变性" class="headerlink" title="范型类不具有协变性"></a>范型类不具有协变性</h2><p>最后，范型类 <code>不具有协变性</code>，如 <code>List&lt;Base&gt;</code> 不会是 <code>List&lt;Derived&gt;</code> 的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  <span class="comment">// 在这里直接凉了</span></span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">List&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  <span class="comment">// 一起凉了</span></span><br></pre></td></tr></table></figure><p><strong>为什么范型是不协变的？</strong></p><p>因为这样做会破坏要提供的类型的安全范型。如果能够将 <code>List&lt;Integer&gt;</code> 赋值给 <code>List&lt;Number&gt;</code>，那么下面的代码将允许将非 <code>Integer</code> 的内容放入 <code>List&lt;Integer&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Number&gt; numList = intList;  <span class="comment">// error</span></span><br><span class="line"><span class="comment">/* Type mismatch: cannot convert from List&lt;Integer&gt; to List&lt;Number&gt; */</span></span><br><span class="line">numList.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">1.23</span>)); </span><br></pre></td></tr></table></figure><p><code>numList</code> 实际上引用的是一个 <code>List&lt;Integer&gt;</code>，只能存 <code>Integer</code> 或者其 <code>子类</code>，所以在第二行就禁止了这种赋值行为。<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code> 两者是不同的类，且没有继承关系。</p><p>如果需要这样的赋值，比如作为函数的参数，可以这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; numList = intList;   <span class="comment">// 使用通配符 ?</span></span><br></pre></td></tr></table></figure><p><strong>为什么数组不支持范型？</strong></p><p>假设数组支持范型，数组是在运行时才去判断数组元素的类型约束（此时范型信息已被擦除），因为无法做类型约束。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/2e1a9edbae55">Java 数组协变</a></li><li><a href="https://blog.csdn.net/xsc_c/article/details/18010499">Java——协变数组和类型擦除(covariant array &amp; type erasure)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 协变性 </tag>
            
            <tag> Covariant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好好调戏 Java 范型中的通配符以及边界限定规则</title>
      <link href="/2019/02/14/046_%E5%A5%BD%E5%A5%BD%E8%B0%83%E6%88%8F%20Java%20%E8%8C%83%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%BE%B9%E7%95%8C%E9%99%90%E5%AE%9A%E8%A7%84%E5%88%99/"/>
      <url>/2019/02/14/046_%E5%A5%BD%E5%A5%BD%E8%B0%83%E6%88%8F%20Java%20%E8%8C%83%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%BE%B9%E7%95%8C%E9%99%90%E5%AE%9A%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="通配符-与-T-的区别"><a href="#通配符-与-T-的区别" class="headerlink" title="通配符 ? 与 T 的区别"></a>通配符 ? 与 T 的区别</h2><p><code>T</code>：作用于模版上，用于将数据类型进行参数化，不能用于实例化对象。<br><code>?</code>：<code>在实例化对象的时候</code>，不确定泛型参数的具体类型时，可以使用通配符进行对象定义。（有点像 C++ 的 auto、C 语言的 void * 指针）</p><p><code>&lt;T&gt;</code> 等同于 <code>&lt;T extends Object&gt;</code><br><code>&lt;?&gt;</code> 等同于 <code>&lt;? extends Object&gt;</code></p><span id="more"></span><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yb7zv.jpg" alt="一图看懂Java泛型通配符"></p><h2 id=""><a href="#" class="headerlink" title="&lt;? super MyClass&gt;"></a>&lt;? super MyClass&gt;</h2><p>以 <code>set</code> 的角度去看待。</p><p><code>MyClass</code> 是我们知道的提示（一个边界）：</p><ul><li>不允许调用 get 方法获得 MyClass 的引用（这里是指 MyClass 的 get&#x2F;set 方法）<ul><li>因为你不知道用什么去「接收&#x2F;容纳」这个 <code>? super MyClass</code>（不能确定上界），只能用 <code>Object</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">abc</span> <span class="operator">=</span> &lt;? <span class="built_in">super</span> MyClass&gt;.get();</span><br></pre></td></tr></table></figure></li></ul></li><li>允许调用 set 方法传入 MyClass 的引用<ul><li>因为 <code>&lt;? super MyClass&gt;</code> 表示的类对象不是 MyClass，就是它的父亲。（作为「左值」）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="built_in">super</span> MyClass&gt;.set(XXX); <span class="comment">// XXX 可以是 MyClass，或者它的子类</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>当使用 <code>&lt;? super MyClass&gt;</code> 的时候，表明未知类的继承结构处于 Object 和 MyClass 之间，这时编译器只能确定任何返回该未知类型的方法，返回的变量都是 Object 的子类，所以返回的类型就只能确定为 Object，比如 getter 方法。（函数返回的时候，或者赋值给左边的值的时候）</p><p>此外，<code>set</code> 的情况还包括使用该未知类型作为参数的方法，该参数一定是 MyClass 或者其父类，所以可以传递 MyClass 及其子类进去。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">  <span class="comment">// 把 src 的每个元素复制到 dest 中</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">      <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i);</span><br><span class="line">      dest.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 这样就可以 copy List&lt;Integer&gt; to List&lt;Number&gt;</span></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title="&lt;? extends MyClass&gt;"></a>&lt;? extends MyClass&gt;</h2><p>以 <code>get</code> 的角度去看待。</p><p><code>MyClass</code> 是我们知道的提示（一个边界）：</p><ul><li>允许调用 get 方法获得 MyClass 的引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">clz</span> <span class="operator">=</span> &lt;? <span class="keyword">extends</span> <span class="title class_">MyClass</span>&gt;.get();  <span class="comment">// 因为我们知道 MyClass 是上界</span></span><br></pre></td></tr></table></figure></li><li>不允许调用 set 方法传入 MyClass 的引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">MyClass</span>&gt;.set(XXX);  <span class="comment">// 但我们不知道下界是什么，只能取个极限 null（XXX = null）</span></span><br></pre></td></tr></table></figure></li></ul><p>使用 <code>&lt;? extends MyClass&gt;</code> 的时候，未知类型一定是 MyClass 的子类，但向下延伸到无穷尽，无法判断。所以返回未知类型的方法的返回类型有一个上界，就是 MyClass，即返回类型确定为 MyClass。但是使用未知类型的方法，因为向下继承无限延伸，无法判断下界，所以不能使用该方法。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="&lt;?&gt; 通配符"></a>&lt;?&gt; 通配符</h2><p>使用 <code>&lt;?&gt;</code> 的时候，可以当作 <code>&lt;? extends Object&gt;</code>，即上界是 Object。</p><p>可以使用 get 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">abc</span> <span class="operator">=</span> &lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;.get();</span><br></pre></td></tr></table></figure><p>不可以使用 set 方法（或者只能 set null）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;.set(XXX);  <span class="comment">// 无法推断 ? 的下界，所以也无法确定 XXX 的上界。</span></span><br></pre></td></tr></table></figure><p>注意：<code>Pair&lt;?&gt;</code> 和 <code>Pair</code> 不同（不要想当然以为 <code>Pair&lt;?&gt;</code> 可以被放入任何东西！）</p><ul><li><code>Pair&lt;?&gt;</code> 相当于 <code>Pair&lt;? extends Object&gt;</code></li><li><code>Pair&lt;Object&gt;</code> 可以调用 set 方法放入任何东西</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairHelper</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限定通配符 <code>&lt;?&gt;</code> 很少使用，可以用 <code>&lt;T&gt;</code> 替换它：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ya0vn.jpg"></p><h2 id="其它快速判断的方法"><a href="#其它快速判断的方法" class="headerlink" title="其它快速判断的方法"></a>其它快速判断的方法</h2><h3 id="get-put-principle"><a href="#get-put-principle" class="headerlink" title="get-put principle"></a>get-put principle</h3><p>选择限定通配符时的快速判断方法（get-put principle）：</p><ul><li>Use an <code>extends</code> wildcard when you only <code>get values</code> out of a structure.</li><li>Use a <code>super</code> wildcard when you only <code>put values</code> into a structure.</li><li><code>Don&#39;t use</code> a wildcard when you do both.</li></ul><h3 id="PECS"><a href="#PECS" class="headerlink" title="PECS"></a>PECS</h3><p>PECS（Producer，Extends，Consumer，Super）来源于 Effective Java。</p><ul><li><p>Producer（extends）</p><p>这里是生产者的意思。当你要从某个参数中获取某个类型的数据，那么应该声明这个参数类型为 <code>&lt;? extends T&gt;</code>。比如，<code>List&lt;? extends Number&gt; list</code> 表明 list 是一个生产者，你可以从其中取出 Number 对象（或者其实是子类，但是你不一定知道）。<br>（等同于 get values）</p></li><li><p>Consumer（super）</p><p>这里是消费者的意思。当某个参数将要消费（使用）到某个类型的数据，那么应该声明这个参数类型为 <code>&lt;? super T&gt;</code>。比如，<code>Collection&lt;? super E&gt; collect</code> 表明 collect 可以消费（使用）或者被放入类型为 E（甚至是子类）的数据。</p></li><li><p>既要生产又要消费，那就不要使用通配符了。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000013365487">一图看懂Java泛型通配符</a></li><li><a href="https://blog.csdn.net/claram/article/details/51943742">Java泛型三：通配符详解 extends super</a></li><li><a href="https://www.jianshu.com/p/6dc9d9adbce0">Java泛型 - 通配符以及原始类型(Raw Type)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 通配符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANSI C 标准中关于指针赋值的约束条件</title>
      <link href="/2019/01/18/044_ANSI%20C%20%E6%A0%87%E5%87%86%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6/"/>
      <url>/2019/01/18/044_ANSI%20C%20%E6%A0%87%E5%87%86%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>先看一段包含警告的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **p)</span> &#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    foo(argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// warning: argument is incompatible with prototype</span></span><br></pre></td></tr></table></figure><p>我们可能认为，由于实参 <code>char *s</code> 与形参 <code>const char *p</code> 应该是相容的（标准库中所有的字符串处理函数都是这样写的），那么，为什么实参 <code>char **argv</code> 与形参 <code>const char **p</code> 却不能相容呢？</p><span id="more"></span><h2 id="容易混淆的-const"><a href="#容易混淆的-const" class="headerlink" title="容易混淆的 const"></a>容易混淆的 const</h2><p>回答上述问题前先看一下关键字 const 的用法和实际使用的含义。注意，它不能把变量变成常量！在一个符号前加上 const 限定符只是<strong>表示这个符号不能被赋值</strong>。</p><blockquote><p>这意味着，我们可以取一个 const 变量的地址，并且可以改变它的值（但最好还是不要这样）。回首往事，const 关键字原先如果命名为 readonly 就好多了，因为 readonly 没有不能改变的意思（外部可以去改变），而 const 只表示自身不会变。const 的最简单用法：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num1 = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>当在赋值号两边加上指针，就要注意了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *num2 = &amp;num1;</span><br><span class="line"><span class="type">int</span> i = <span class="number">27</span>;</span><br><span class="line">num2 = &amp;i;</span><br></pre></td></tr></table></figure><p>const 修饰符修饰的不是 int 指针，而是 int 本身，意味着 int 不能被改变，而 int 指针的值（地址）可以被改写。const 最有用的地方就是用来修饰函数的形参，这样表示该函数不会去修改实参指针所指向的数据内容。它声称「我给你一个指向它的指针，但你不能修改它」。这个约定类似于 <code>void *</code> 的用法。尽管它可以用于任何类型，但通常被限定于把指针从一种类型转换为另一种类型。</p><p>总结：</p><ul><li>int const *p（int 只读）</li><li>const int *p（int 只读）</li><li>int * const p（指针只读）</li><li>int const * const p（都只读）</li></ul><h2 id="指针赋值的约束条件"><a href="#指针赋值的约束条件" class="headerlink" title="指针赋值的约束条件"></a>指针赋值的约束条件</h2><p>回到问题本身，ANSI C 标准中有这么一句话（约束条件）：</p><blockquote><p>每个实参都应该具有自己的类型，这样它的值就可以赋值给它所对应的形参类型的对象（该对象的类型不能含有限定符）。</p></blockquote><p>这就是说参数传递过程类似于赋值。所以，这样的代码也是非法的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **cp;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> **ccp;</span><br><span class="line">ccp = cp;</span><br></pre></td></tr></table></figure><p>要使指针的赋值合法，必须满足下列约束条件：</p><ol><li>两个操作数都是指向有限定符或无限定符的相容类型的指针。</li><li>左边指针所指向的类型必须具有右边指针所指向类型的全部限定符（「无限定符」也被看作是一种限定符）。</li></ol><p>先来看一下为什么实参 <code>char *</code> 和 <code>const char *</code> 匹配，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *cp;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ccp;</span><br><span class="line">ccp = cp;</span><br></pre></td></tr></table></figure><p>它之所以合法，是因为它满足：</p><ul><li>左操作数是一个指向有 const 限定符修饰的 char 的指针。</li><li>右操作数是一个指向没有限定符修饰的 char 的指针。（相当于空集可以包含于其它集合）</li><li>char 类型与 char 类型是相容的，左操作数所指向的类型具有右操作数所指向的类型的限定符（无 + const）。</li></ul><p>注意，反过来就不能赋值了，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp = ccp; <span class="comment">// 产生警告</span></span><br></pre></td></tr></table></figure><p>类似地，<code>const char **</code> 是一个指向没有限定符修饰的指针类型。注意两个指针<strong>本身</strong> <code>const char **</code> 和 <code>char **</code> 都没有被 const 限定符修饰。然而，它们指向的类型不一样，<code>const char **</code> 指向 **const char ***，<code>char **</code> 指向 **char ***。</p><ul><li><code>const char</code> 和 <code>char</code> → 相容</li><li><code>const char *</code> 和 <code>char *</code> → 不相容（注意注意！有点奇葩！）</li><li>我猜 <code>char * const</code> 和 <code>char *</code> 是相容的。</li></ul><p><strong>相容性是不能传递的。</strong></p><p>换言之，</p><ul><li>左操作数的类型是 FOO_2，它是一个指向 FOO 的指针，而 FOO 是一个没有限定符的指针，它指向一个带有 const 限定符的 char 类型。</li><li>右操作符的类型是 BAZ_2，它是一个指向 BAZ 的指针，而 BAZ 是一个没有限定符的指针，它指向一个没有限定符的字符类型。</li></ul><p><code>FOO</code> 和 <code>BAZ</code> 所指向的类型是相容的，而且它们本身都没有限定符，所以两者之间可以赋值（注意只是单向的）。但是 <code>FOO</code> 和 <code>BAZ</code> 所指向的类型相容并不意味着 <code>FOO_2</code> 和 <code>BAZ_2</code> 所指向的类型也相容，所以即使 <code>FOO_2</code> 和 <code>BAZ_2</code> 都没有限定符，但它们之间不能进行赋值（双向都不行，因为所指向的对象本身不相容）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《C 专家编程》（Expert C Programming）p19-21</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> const </tag>
            
            <tag> Expert C Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是如何高效地使用 MacBook？</title>
      <link href="/2018/12/23/042_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8%20MacBook/"/>
      <url>/2018/12/23/042_%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8%20MacBook/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Junhao: In which way I can use my Mac efficiently?<br>Friend: Install Windows OS?<br>Junhao: ……</p></blockquote><p>自从 6 年前开始使用 Mac 系统，我就再也没有关过机了。Kidding！不过说真的，关机的次数可能不超过 30 次吧？在大二的时候，我换了一台新的 MacBook，也因此重装了一次系统，当时还不太会用 Time Machine 进行备份，弄得非常麻烦。现在嘛，如果我买新的 MacBook（如果有钱的话），我肯定直接恢复备份了，因为这几年来我的 MacBook 留下了很多配置和使用痕迹，如果让我重新手动配置，我会疯掉的~</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/dy7o5.jpg" alt="我的 MacBook"></p><span id="more"></span><p>直接进入正题，本文从 <code>使用心得</code> 和 <code>应用推荐</code> 两个方面做介绍。介绍中难免主观性很强，大家可以选择性地采纳我的建议，或者还是装个 Windows 吧（逃）。</p><p>在开始之前，我先贴一下电脑的基本信息：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ga5i1.png" alt="MacBook Pro Retina (13-inch, 2018)"></p><p>按键说明：<br><code>⌘</code>：Command<br><code>⌃</code>：Control<br><code>⌥</code>：Option（Alt）<br><code>⇧</code>：Shift</p><p>PS：我的系统是英文的，大家自行翻译啊。</p><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>我不使用多屏，也基本不会使用触摸板的手势功能，因为我感觉操作起来非常慢。下面是一些基本的操作方式：</p><ul><li>应用菜单：<code>F4</code> 键或移动鼠标至屏幕右上角（后面会介绍 Hot Corners）；</li><li>返回桌面：移动鼠标至屏幕右下角，如果想要在 App 中将图片拖到桌面，直接将图片拖至右下角即可；</li><li>应用管理：<code>F3</code> 键或按鼠标的中键（如果有的话）；</li><li>相同应用中不同窗口的切换：<code>⌘</code> + <code>~</code>（Markdown下打不出 1 左边那个键），这个功能非常有用，比如在 Word 中同时编辑多个文档，可以减少鼠标的移动；</li><li>退出应用：<code>⌘</code> + <code>Q</code>；</li><li>关闭窗口：<code>⌘</code> + <code>W</code>，不常用；</li><li>隐藏窗口：<code>⌘</code> + <code>H</code>，很常用，可以代替关闭窗口使用；</li><li>最小化窗口：<code>⌘</code> + <code>M</code>，没用；</li><li>任务管理窗口：<code>⌘</code> + <code>⌥</code> + <code>Esc</code>，用来结束未响应的任务；</li><li>锁屏：<code>⌘</code> + <code>⌥</code> + <code>关机键</code>；</li><li>系统&#x2F;应用设置：<code>⌘</code> + <code>,</code>，不要再手动点左上角的偏好设置了；</li><li>打印：<code>⌘</code> + <code>P</code>，在大部分应用中可以使用系统的打印功能，很方便；</li><li>移动标签（Tab）：<code>⌘</code> + <code>⇧</code> + <code>[</code>&#x2F;<code>]</code>，看到标签视图就可以用，如 Chrome；</li><li>搜索：<code>⌘</code> + <code>F</code>，八九不离十是这个快捷键，而替换是：<code>⌘</code> + <code>⇧</code> + <code>F</code>。</li></ul><p>Hot Corners：</p><p>在 Mission Control 设置界面里，左下角是 Hot Corners 的设置界面，我的设置如下：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/23v0z.jpg"></p><p>主要是方便返回桌面，其他功能可有可无，可以根据自己的需求进行设置。</p><p>以上只是最基本的操作，如果想要 100% 的效率提升效果，还需要使用 Snap、Magnet、Alfred 这三款软件，我会在应用推荐中单独介绍。</p><p>Finder：</p><ul><li><code>⌘</code> + <code>⇧</code> + <code>G</code>：可以快速访问某个路径下的文件夹；</li><li><code>⌘</code> + <code>1</code>&#x2F;<code>2</code>&#x2F;<code>3</code>&#x2F;<code>4</code>：快速切换不同的文件显示方式（我比较喜欢用第三种）。</li></ul><h3 id="更改修饰键"><a href="#更改修饰键" class="headerlink" title="更改修饰键"></a>更改修饰键</h3><p>说真的，把快捷键用好了，不仅可以解放鼠标，还可以解放触摸板。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/s4wsl.jpg" alt="键盘设置界面"></p><p>把 Key Repeat 和 Delay Until Repeat 调成这样可以加快打字速度。如果你想使用 <code>Fn</code> 键进行应用切换，可以勾选第四个选项，并结合 Snap 软件使用。</p><p>最牛逼的，也是我给别人推荐的最多的，是修改默认的修饰键。我不用 <code>Caps Lock</code> 键，因为大写字母可以通过 <code>⇧</code> 键（shift）来输入。我将 <code>Caps Lock</code> 键设置为 <code>⌃</code> 键（control），因为它原本的位置太恶心了，需要弯着小指去敲。这个设置是之后许多快捷键操作的基础，这样可以充分发挥 <code>⌃</code> 的作用。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/c6o0i.jpg" alt="我的修饰键"></p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>之前在学习 Emacs 的时候（幸好没有学太多 Vim 的操作，不然信仰就变了），我学习了大量的光标移动快捷键。它们的适用范围很广，Mac 系统和大部分应用（除了 Office）都支持这些快捷键。这真的彻底解放了方向键，提升打字速度。</p><ul><li><code>⌃</code> + <code>F</code>：向前移动光标</li><li><code>⌃</code> + <code>B</code>：向后移动光标</li><li><code>⌃</code> + <code>N</code>：向上移动光标</li><li><code>⌃</code> + <code>P</code>：向下移动光标</li><li><code>⌃</code> + <code>A</code>：将光标移至最前</li><li><code>⌃</code> + <code>E</code>：将光标移至最后</li><li><code>⌥</code> + <code>F</code>：向前移动光标至下一个单词</li><li><code>⌥</code> + <code>B</code>：向后移动光标至上一个单词</li></ul><p>常用的就是这几个，大家可以继续摸索。</p><p>此外，<code>⌃</code> + <code>N</code> 和 <code>⌃</code> + <code>P</code> 还常常用于菜单选项的遍历，如 Alfred 的结果、代码自动补全菜单等等。</p><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/h19zx.jpg"></p><p>在网上搜一下如何删除系统的默认输入法，只留一个第三方输入法就够了。这样可以快速地进行中英文切换，只需要按一下 <code>⇧</code> 键。</p><p>此外，搜狗中可以设置将 <code>“”</code> 更改为 <code>「」</code>。</p><h3 id="更改默认显示解析度"><a href="#更改默认显示解析度" class="headerlink" title="更改默认显示解析度"></a>更改默认显示解析度</h3><p>在系统 Display 设置中，可以更改显示解析度，这样做的目的是让 13 寸小屏可以显示更多的内容。很多人说默认的方式已经不错了，我想说的是，你试一下就知道了。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/hiw0g.jpg" alt="我选择的是介于 Default 和 More Space 中的显示比例"></p><h3 id="Chrome-的快捷键"><a href="#Chrome-的快捷键" class="headerlink" title="Chrome 的快捷键"></a>Chrome 的快捷键</h3><ul><li><code>⌘</code> + <code>N</code>：新窗口</li><li><code>⌘</code> + <code>⇧</code> + <code>N</code>：不留痕迹模式</li><li><code>⌘</code> + <code>~</code>：这样方便多个窗口进行切换，而不需要分屏</li><li><code>⌘</code> + <code>L</code>：激活输入网址栏（同学推荐的，很方便）</li><li><code>⌘</code> + <code>⇧</code> + <code>R</code>：删除缓存，重新加载页面</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>不需要用第三方的字典软件！<br>不需要用第三方的字典软件！<br>不需要用第三方的字典软件！</p><p>重要的事情说三遍！自带的 Dictionary 已经非常好用了，而且速度很快。再配合 Alfred 使用简直无敌。比较麻烦的是找到合适的词典文件，需要的可以通过邮件联系我。</p><p>如果嫌麻烦可以使用欧路字典，不过就是贵，而且有 bug。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/k2ozp.jpg" alt="我的字典"></p><h2 id="应用推荐"><a href="#应用推荐" class="headerlink" title="应用推荐"></a>应用推荐</h2><p>每安装一个新的应用，应该有这样的意识：</p><ol><li>通过 <code>⌘</code> + <code>,</code> 查看应用的偏好设置；</li><li>浏览左上方的菜单栏；</li><li>通过 CheatSheet 查看常用的快捷键（一款应用，装上后只要长按 <code>⌘</code> 就可以查看所在应用下的所有快捷键，如图所示）。</li></ol><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/l37bc.jpg" alt="CheatSheet 效果"></p><p>此外，应用要收钱怎么办？</p><p><strong>掏钱吧！</strong>Mac 的应用虽然贵，但是真的值得。如果几块钱的应用，我还是鼓励大家不要用盗版（况且很难找到盗版）。</p><p>如果你想买的应用很贵，我的建议是去淘宝搜一下这个应用，然后花几块钱买别人的账号去下载，这样可以省一笔钱，不过更新起来比较麻烦，一般需要截图发给卖家要新的密码。</p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>我不用系统自带的 Spotlight，因为它以前很难用，现在好不好用我就不知道了。Alfred 是一款替代 Spotlight 的应用，而且功能更强大。</p><p>我是通过 <code>⌘</code> + <code>⇧</code> + <code>Enter</code> 激活 Alfred，再按 <code>⌘</code> + <code>,</code> 可以进入偏好设置。</p><ul><li><p>搜索、打开文件</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/j53fv.jpg"></p></li><li><p>快速打开应用</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1ww4w.jpg"></p></li><li><p>查字典（与系统自带的 Dictionary 完美结合）</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/j30ol.jpg" alt="我设置输入「,」时为字典模式"></p></li><li><p>快速计算（我再也没打开过计算器了。。。）</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/70hxp.jpg"></p></li><li><p>其他功能</p><ul><li>可以直接输入 url，免得切换到 Chrome 再输入；</li><li>可以设置「bd」为百度搜索、「gd」为谷歌搜索等等；</li><li>你慢慢挖掘吧，我只是用了最基本的功能。</li></ul></li></ul><h3 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a>Snap</h3><p>解放 Dock！对于常用的应用（如编辑器、微信、Finder），我不想用右手操作触摸板去 Dock 打开它，我想要设置一个全局快捷键，那就用 Snap 吧。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/kfqqu.jpg" alt="Snap"></p><p>我的设置如下：</p><ul><li><code>⌘</code> + <code>⌃</code> + <code>F</code>：Finder</li><li><code>⌘</code> + <code>⌃</code> + <code>E</code>：编辑器（VSCode）</li><li><code>⌘</code> + <code>⌃</code> + <code>1</code>：Emacs</li><li><code>⌘</code> + <code>⌃</code> + <code>2</code>：Sublime Text</li><li><code>⌘</code> + <code>⌃</code> + <code>W</code>：IDE（IntelliJ）</li><li><code>⌘</code> + <code>⌃</code> + <code>A</code>：Chrome</li><li><code>⌘</code> + <code>⌃</code> + <code>R</code>：iTerm2（终端，不介绍了，程序员必装的应用）</li><li><code>⌘</code> + <code>⌃</code> + <code>S</code>：MWeb</li><li><code>⌘</code> + <code>⌃</code> + <code>X</code>：自带字典 Dictionary</li><li><code>⌘</code> + <code>⌃</code> + <code>C</code>：自带记事本 Notes</li><li><code>⌘</code> + <code>⌃</code> + <code>V</code>：PDF Expert</li><li><code>⌘</code> + <code>⌃</code> + <code>Tab</code>：Spark Email</li><li><code>⌘</code> + <code>⌃</code> + <code>Z</code>：网易云（逃</li></ul><p>这样我就不需要分屏了！微信有人找我，我只需要按对应的快捷键就可以打开聊天框，然后再按一次回到正在工作的应用。如果没有 Snap，我需要手势切换分屏，或手动去 Dock 上打开微信。【最近因为切换微信太频繁了，我把它关掉了:-)】</p><p>PS：前面说到还可以用 <code>Fn</code> 键进行切换，我还是觉得不太方便。</p><h3 id="Magnet"><a href="#Magnet" class="headerlink" title="Magnet"></a>Magnet</h3><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ii8t4.jpg"></p><p>该应用可以通过拖拽或快捷键快速改变窗口的大小。我使用的快捷键如下：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/4leq5.jpg" alt="我的 Magnet 快捷键"></p><p>我主要用 <code>U</code>、<code>I</code>、<code>O</code>、<code>P</code>、<code>J</code>、<code>K</code>、<code>L</code>、<code>;</code> 和 <code>Enter</code> 键进行窗口大小的调整，可以快速地分屏（非全屏下）或最大化窗口。</p><p>说真的，操作起来真的太快了！</p><h3 id="PDF-Expert"><a href="#PDF-Expert" class="headerlink" title="PDF Expert"></a>PDF Expert</h3><p>最好用的 PDF 浏览器有没有？买了之后很后悔，后悔没有早点买！</p><p>功能非常多，开发者很走心。</p><p>有了它我就不再用 Preview（预览）来看 PDF 了。</p><p>PS：结合 iPad 使用更爽。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/owp7v.jpg" alt="PDF Expert 界面"></p><h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h3><p>国人做的一款 Markdown 笔记应用，方便管理 <code>.md</code> 文件，而且功能很多很强大（支持 mathjax）。注意，MWeb 2.0 和 MWeb 3.0 是分开收费的，我建议使用 2.0，因为 3.0 版存在不少问题，如卡顿。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/hvjnf.jpg" alt="MWeb 界面"></p><p>如果需要快速打开单个 <code>.md</code> 文件，可以使用 MacDown。</p><p>此外，上传图片可以使用 iPic。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>ToothFairy：快速连接 AirPods，这个真的超方便的！我设置的快捷键是：<code>⌘</code> + <code>⌃</code> + <code>T</code>，如图：</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/d3nzu.jpg"></p></li><li><p>iStat Menus：我主要用来看当前的下载速度和上传速度（逃）；</p></li><li><p>Scroll Reverser：鼠标用户的福音，反转鼠标状态下滚轮的滑动方向；</p></li><li><p>CleanMyMac 3：128 GB 用户的福音，花了我 100 软妹币；</p></li><li><p>DaisyDisk：方便查看文件大小、清楚系统空间，也是 128 GB 用户的福音；</p></li><li><p>ScreenFlow：视频剪辑软件，比 iMovie 好用，适合简单的视频剪辑；</p></li><li><p>Keka：解压软件，因为有时解压会出现乱码的现象，我还装了 The Unarchiver、BetterZip；</p></li><li><p>TypeFu：练习打字速度的软件，可参考<a href="https://junhaow.com/2016/06/17/%E7%BB%99%E4%BD%A0%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BEMac%E4%B8%8B%E7%9A%84%E6%89%93%E5%AD%97%E7%BB%83%E4%B9%A0%E7%A5%9E%E5%99%A8TypeFu/">给你推荐一款Mac下的打字练习神器TypeFu</a>；</p></li><li><p>IINA：视频播放软件，我还有装了 mpv，但在多数情况下还是 IINA 好用；</p></li><li><p>duet：如果你想把 iPad 当做第二个屏幕；</p></li><li><p>AirDroid：传输文件至其他设备，安卓用户的福音；</p></li><li><p>BombSquad：超级好玩的游戏，把手机当手柄，可以多个人联机，很欢乐；</p></li><li><p>Emacs：（逃）。</p></li></ul><p>先总结这么多，欢迎一起探讨更多有关 Mac 的「奇淫技巧」。</p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 使用心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边界计算与不对称边界（Asymmetric Bounds）的设计思想</title>
      <link href="/2018/11/15/041_%E8%BE%B9%E7%95%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%B8%8D%E5%AF%B9%E7%A7%B0%E8%BE%B9%E7%95%8C%EF%BC%88Asymmetric%20Bounds%EF%BC%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2018/11/15/041_%E8%BE%B9%E7%95%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%B8%8D%E5%AF%B9%E7%A7%B0%E8%BE%B9%E7%95%8C%EF%BC%88Asymmetric%20Bounds%EF%BC%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果一个数组有 10 个元素，那么这个数组下标的允许取值范围是什么？</p></blockquote><ul><li>对于 Fortran 语言，数组的下标取值缺省从 1 开始，且允许编程者另外指定数组下标的起始值。</li><li>对于 Algol 和 Pascal 语言，数组下标没有缺省的起始值，编程者必须明确指定每个数组的上下界。</li><li>对于标准的 Basic 语言，声明一个拥有 10 个元素的数组，实际上编译器分配了 11 个元素空间，下标范围从 0 到 10。</li></ul><p>在 C 语言中，一个拥有 n 个元素的数组，却不存在下标为 n 的元素，它的元素的下标范围是从 0 到 n - 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>这段代码的本意是将数组 a 中所有的元素赋值为 0。但代码中的 a[10] 将数组 a 之后的一个字（word）的内存被设置为 0。如果用来编译这段程序的编译器按照内存地址递减的方式来给变量分配内存，那么内存中数组之后的一个字实际上是分配给了整型变量 i。此时，本来循环计数器 i 的值为 10，<code>a[10] = 0</code> 使得 i 的值变成 0，这就陷入了一个死循环。</p><p>尽管 C 语言的数组会让新手感到困惑，但这种特别的设计正是其最大优势所在。在常见的程序错误中，最难于发现的一类是 <code>栏杆错误</code>，也被称为 <code>差一错误</code>（off-by-one error）。</p><blockquote><p>《C 专家编程》：C 语言的许多其他特性是<strong>为了方便编译器设计者而建立的。</strong>数组下标为什么从 0 开始而不是 1，因为编译器的设计者选择从 0 开始。<strong>偏移量的概念在他们心中已是根深蒂固</strong>。</p></blockquote><blockquote><p>100 英尺长的围栏每隔 10 英尺需要一根支撑用的栏杆，一共需要多少根栏杆呢？</p></blockquote><p>如果不加思考，给出的回答很可能是 10，而正确答案是 11，这就是 <code>栏杆错误</code>。它经常发生在循环中的越界问题中，比如 if 中的表达式应该用小于还是小于等于？</p><p>通常，解决这类问题可以参考以下两个原则：</p><ol><li>将问题简化，考虑最简单情况下的特例，然后将结果进一步外推。</li><li>仔细计算边界。</li></ol><p>比如，在写遍历、插入、删除链表中元素的代码时，我们可以先考虑没有元素、只有一个元素、两个元素的情况。若代码满足这几种简单的情况，通常可以满足所有情况。</p><p>再比如，假定整数 x 满足边界条件 <code>x &gt;= 16</code> 且 <code>x &lt;= 37</code>，那么此范围内 x 的可能取值有多少个？千万不要因为 37 - 16 &#x3D; 21，就直接认为是 21 个。正确的思路是这样的：</p><ul><li>右值 - 左值 &#x3D; NUM，还要加一还是减一，或是不变？</li><li>举出简单的情况：<code>x &gt;= 16</code> 且 <code>x &lt;= 16</code>、<code>x &gt;= 16</code> 且 <code>x &lt;= 17</code>。</li><li>计算后，前者：NUM &#x3D; 0，实际是 1；后者：NUM &#x3D; 1，实际是 2。</li><li>外推：个数 &#x3D; NUM + 1，有 22 个数。</li></ul><p>为了避免这种情况的发生，我们一般用一个 <code>下界点</code> 和一个 <code>上界点</code> 来表示一个数值范围，其中 <code>下界点</code> 包括在取值范围之中，而 <code>上界点</code> 不在取值范围内。在上例中，范围应该表示为 <code>x &gt;= 16</code> 且 <code>x &lt; 38</code>。</p><p>这种不对称的表达方式也许从数学上而言并不优美，但是对于程序员来说，这种设计有着令人吃惊的简化效果：</p><ol><li>取值范围的大小就是下界与上界之差。38 - 16 刚好等于 22，恰恰是不对称边界所包括的元素个数。</li><li>如果取值范围为空，那么下界等于上界，范围内个数为 0。</li><li>即使取值范围为空，上界也永远不可能小于下界。</li></ol><p>C 数组下标从 0 开始就是运用了这种不对称边界的设计，此时数组的上界就是数组元素的个数。因此，本文开头的代码段应该改写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123; <span class="comment">// 而不是写成 i &lt;= 9</span></span><br><span class="line">  a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种考虑不对称边界的方式是，把上界视作序列中第一个<strong>即将被占用</strong>的元素，而把下界视作序列中第一个<strong>即将被释放</strong>的元素，如图所示。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/z6pdt.jpg" alt="不对称边界示意图"></p><p>这种看待问题的方式对于处理各种不同类型的缓冲区特别有用。例如，某函数的功能是将长度无规律的输入数据送到缓冲区，每当这款内存被填满时，就将缓冲区的内容写出。缓冲区的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[N];</span><br></pre></td></tr></table></figure><p>再设置一个指针变量，指向缓冲区的当前位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *bufptr;</span><br></pre></td></tr></table></figure><p>我们是让指针 bufptr 始终指向缓冲区中最后一个已占有的字符，还是让它指向缓冲区中之后第一个未被占用的字符？若考虑「不对称边界」的设计思想，后一种选择更为贴切。</p><p>按照「不对称边界」的思想，我们可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*bufptr++ = c;  <span class="comment">// 先进行 ++ 运算，所以递增的是 bufptr 本身的值</span></span><br></pre></td></tr></table></figure><p>这个语句把输入字符 c 放到缓冲区中，然后指针 bufptr 递增 1，又指向缓冲区中下一个未被占用的字符。等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*bufptr = c;</span><br><span class="line">bufptr++;</span><br></pre></td></tr></table></figure><p>根据前面所说的第二条效果，当指针 bufptr 与 &amp;buffer[0]（或 buffer）相等时，缓冲区存放的内容为空，因此初始化时缓冲区为空可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufptr = &amp;buffer[<span class="number">0</span>]; <span class="comment">// 或者 buffer</span></span><br></pre></td></tr></table></figure><p>任何时候缓冲区中以存放的字符数都是 bufptr - buffer（字符类型占 1 个字节），因此我们可以通过将这个表达式与 N 进行比较，来判断缓冲区是否已满。当填满时，bufptr - buffer 就等于 N。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/5ayv9.jpg" alt="缓冲区示意图（灵魂画手）"></p><p>现在，我们写一下 bufwrite 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 指向要写入的字符串的第一个字符，n 是字符个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bufwrite</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bufptr == &amp;buffer[N]) <span class="comment">// 相当于 bufptr - buffer == N</span></span><br><span class="line">      flushbuffer(); <span class="comment">// 将缓冲区的数据写出，并重置指针 bufptr</span></span><br><span class="line">    *bufptr++ = *p++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>--n &gt;= 0</code> 是迭代 n 次的一种写法。为了验证这一点，我们可以考察最简单的特例，即 n &#x3D; 1（还记得前面说的原则吗？）。此外，<code>--n &gt;= 0</code> 的效果与 <code>n-- &gt; 0</code> 一样，一般前者更快（后者需要保存 n 的值，然后做递减，最后用保存的值做比较）。</p><p>值得注意的是，在 bufptr 与 &amp;buffer[N] 的比较中，buffer[N] 这个元素根本不存在，而我们仍然使用 <code>if (bufptr == &amp;buffer[N])</code> 代替了 <code>bufptr &gt; &amp;buffer[N - 1]</code> 的写法，原因在于我们要坚持「不对称边界」的原则：我们要比较指针 bufptr 与 缓冲区后一个字符的地址（即上界），而 &amp;buffer[N] 就是这个地址。</p><p>在此，我们并不需要引用一个不存在的元素，而只需要引用这个元素的地址。我们需要保证不对该引用解引，而且在 C 语言中这个地址是的确存在的（ANSI C 标准明确允许这种用法）。</p><p>最后，改进程序，使得它可以一次移动 k 个字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (--k &gt;= <span class="number">0</span>)</span><br><span class="line">    *dest++ = *source++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufwrite</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123; <span class="comment">// 先比较，所以用 &gt;</span></span><br><span class="line">    <span class="type">int</span> k, rem;</span><br><span class="line">    <span class="keyword">if</span> (bufptr == &amp;buffer[N])</span><br><span class="line">      flushbuffer();</span><br><span class="line">    rem = N - (bufptr - buffer); <span class="comment">// rem 剩余可分配的字符个数</span></span><br><span class="line">    k = n &gt; rem ? rem : n; <span class="comment">// n 是需要分配的字符数，若条件满足，下一次肯定要 flushbuffer()</span></span><br><span class="line">    <span class="built_in">memcpy</span>(bufptr, p, k);</span><br><span class="line">    bufptr += k;</span><br><span class="line">    p += k;</span><br><span class="line">    n -= k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释见注释。</p><p>以上就是不对称边界的两种应用方式。</p><p>参考：《C 陷阱与缺陷，C Traps and Pitfalls》P45（边界计算与不对称边界）</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C Traps and Pitfalls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何记住 C 语言运算符优先级表？</title>
      <link href="/2018/10/22/040_%E5%A6%82%E4%BD%95%E8%AE%B0%E4%BD%8F%20C%20%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%EF%BC%9F/"/>
      <url>/2018/10/22/040_%E5%A6%82%E4%BD%95%E8%AE%B0%E4%BD%8F%20C%20%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在开发中，我们很少关注运算符优先级的问题，因为我们可以滥用 <code>括号</code>，而且我觉得用括号可以厘清逻辑思路，也方便其他人阅读代码。常见的几种与优先级有关的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &amp;&amp; b != <span class="number">0</span>) &#123; &#125; <span class="comment">// A</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG != <span class="number">0</span>) &#123; &#125; <span class="comment">// B</span></span><br><span class="line">r = high&lt;&lt;<span class="number">4</span> + low; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>A 是比较常见的写法，先进行 <code>!=</code> 运算，再做 <code>&amp;&amp;</code> 运算。但我一般会写成 <code>(a &amp;&amp; (b != 0))</code>。</p><span id="more"></span><p>写 B 的本意是先计算 <code>flag &amp; FLAG</code>，再将结果与 0 比较。然而，由于 <code>!=</code> 优先级高于<code>&amp;</code>，上述式子会被解释为 <code>(flag &amp; (FLAG != 0))</code>，违背了本意。</p><p>因为移位运算符的优先级比加法运算符低，C 中的式子实际被解释为 <code>r = high &lt;&lt; (4 + low);</code>，会得到意想不到的结果。</p><p>用添加括号的方式虽然可以完全避免这类问题，但是表达式中有了太多的括号反而不容易理解（上面这种不算多）。因此，记住 C 语言中运算符的优先级是有益的。</p><p>然而，运算符优先级有 15 个，因此记住它们并不是一件容易的事。下面先看一下运算符优先级表：</p><p><strong>技巧：</strong>记符号类型，不记符号。</p><blockquote><p>前述运算符好像也叫做后缀运算符（postfix operators）。</p></blockquote><table><thead><tr><th align="center">符号类型</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">前述（Preceding）运算符</td><td align="center">() [] -&gt; .</td><td align="center">左 → 右</td></tr><tr><td align="center">单目运算符</td><td align="center">! ~ ++ -- - (type) * &amp; sizeof</td><td align="center"><strong>右 → 左</strong></td></tr><tr><td align="center">双目运算符（算术运算符）</td><td align="center">* &#x2F; %</td><td align="center">左 → 右</td></tr><tr><td align="center">&#124;</td><td align="center">+ -</td><td align="center">左 → 右</td></tr><tr><td align="center">（移位运算符）</td><td align="center">&lt;&lt; &gt;&gt;</td><td align="center">左 → 右</td></tr><tr><td align="center">（关系运算符）</td><td align="center">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td align="center">左 → 右</td></tr><tr><td align="center">&#124;</td><td align="center">&#x3D;&#x3D; !&#x3D;</td><td align="center">左 → 右</td></tr><tr><td align="center">（逻辑运算符）</td><td align="center">&amp;</td><td align="center">左 → 右</td></tr><tr><td align="center">&#124;</td><td align="center">^</td><td align="center">左 → 右</td></tr><tr><td align="center">&#124;</td><td align="center">&#124;</td><td align="center">左 → 右</td></tr><tr><td align="center">（条件运算符）</td><td align="center">&amp;&amp;</td><td align="center">左 → 右</td></tr><tr><td align="center">&#124;</td><td align="center">&#124;&#124;</td><td align="center">左 → 右</td></tr><tr><td align="center">三目运算符</td><td align="center">? :</td><td align="center"><strong>右 → 左</strong></td></tr><tr><td align="center">赋值运算符</td><td align="center">&#x3D;</td><td align="center"><strong>右 → 左</strong></td></tr><tr><td align="center">逗号运算符</td><td align="center">,</td><td align="center">左 → 右</td></tr></tbody></table><p>如果把这些运算符适当分组，并且理解各组运算符之间的相对优先级，那么就不难记住这张表了。</p><ul><li><p>优先级最高的前述运算符其实并不是真正意义上的运算符（数组下标、函数调用操作符、各结构体成员选择操作符）。</p></li><li><p>单目运算符的优先级仅次于前述运算符。在所有真正意义上的运算符上，它们的优先级最高。因为函数调用的优先级要高于单目运算符的优先级，所以如果 p 是一个函数指针，要调用所指向的函数需要这么写：<code>(*p)()</code>，即给 <code>*p</code> 加括号，否则编译器会解释为：<code>*(p())</code>；类型转换 <code>(type)</code> 也是单目运算符。</p></li><li><p>单目运算符的结合性是 <code>右 → 左</code>，因此 <code>*p++</code> 会被编译器解释为 <code>*(p++)</code>，即取指针 p 所指向的内容，然后将 p 本身递增 1；而 <code>(*p)++</code> 是先取指针 p 所指向的对象，然后将该对象递增 1。</p></li><li><p>双目运算符的优先级：</p><ul><li>算术运算符：乘除、加减</li><li>移位运算符：&lt;&lt;、&gt;&gt;</li><li>关系运算符：大于小于先，等于不等于后</li><li>逻辑运算符：位运算 &amp;、|、^</li><li>条件运算符：&amp;&amp;、||（条件运算符实际应为三目运算符）</li></ul><p>  关键是：</p><pre><code>  1. 任意一个逻辑运算符的优先级低于任何一个关系运算符。  2. 移位运算符的优先级比算术运算符要低，但是比关系运算符要高。  3. 6 个关系运算符的优先级并不相同，`==`和`!=`的优先级低于其他关系运算符的优先级。因此，对于这样的代码我们可以不用加括号：`a &lt; b == c &lt; d`。</code></pre></li><li><p>因为三目条件运算符优先级最低，这允许我们在三木条件运算符的条件表达式中包括关系运算符的逻辑组合，如：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tax_rate = income &gt; <span class="number">4000</span> &amp;&amp; residency &lt; <span class="number">5</span> ? <span class="number">3.5</span> : <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure></li><li><p>赋值运算符经常引起优先级的混淆，如下面这个例子：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (c = getc(in) != EOF)</span><br><span class="line">    putc(c, out);</span><br></pre></td></tr></table></figure><p>  在 while 语句的表达式中，c 似乎是首先被赋予函数 <code>getc(in)</code> 的返回值，然后再与 EOF 比较是否到达文件结尾以便决定是否终止循环。然而，由于赋值运算符的优先级要低于任何一个比较运算符（关系运算符、条件运算符），因此 c 的值实际上是函数 <code>getc(in)</code> 的返回值与 EOF 比较的结果。此处函数 <code>getc(in)</code> 的返回值只是一个临时变量，在与 EOF 比较后就被「丢弃」了。实际应该写成：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((c = getc(in)) != EOF)</span><br><span class="line">    putc(c, out);</span><br></pre></td></tr></table></figure></li><li><p>在所有的运算符中，逗号运算符的优先级最低。</p></li></ul><p>最后，我再总结一下优先级顺序：</p><ul><li>前述</li><li>单目</li><li>双目<ul><li>算术</li><li>移位</li><li>关系（大于小于在前，等于不等于在后）</li><li>逻辑（与、异或、或）</li><li>条件</li></ul></li><li>三目</li><li>赋值</li><li>逗号</li></ul><p>《C 专家编程》：有些专家建议在 C 语言中记牢两个优先级就够了（乘法和除法先于加法和减法），在涉及其他的操作符时一律加上括号。「我」认为这是条很好的建议。</p><p>参考：《C 陷阱与缺陷，C Traps and Pitfalls》P19（运算符的优先级问题）</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符优先级 </tag>
            
            <tag> C Traps and Pitfalls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐式转换：把 C 语言数组转换为指针</title>
      <link href="/2018/10/01/039_%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9A%E6%8A%8A%20C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E9%92%88/"/>
      <url>/2018/10/01/039_%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9A%E6%8A%8A%20C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>在某些情况下，C 语言中的数组会被隐式转换为指针类型，使得程序员对数组的操作更加灵活。在函数参数传递中，隐式转换总是在发生。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">(<span class="type">int</span> *b)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(b)); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">(<span class="type">int</span> c[])</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(c)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">5</span>];  <span class="comment">// 5 x 4 = 20 Bytes</span></span><br><span class="line">  foo1(a);   <span class="comment">// -&gt; 8 Bytes</span></span><br><span class="line">  foo2(a);   <span class="comment">// -&gt; 8 Bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数中，a 是一个数组。我们可能会认为在 foo2 中 b 的类型是整型数组类型（输出为 20），而实际上，无论是在 foo1 还是 foo2 中，b 的类型均为指向整型的指针类型，即输出的结果均为指针类型的大小（8 个字节）。</p><span id="more"></span><blockquote><p>实参：Actual Parameter<br>形参：Formal Parameter</p></blockquote><p>参数传递的隐式转换规则：</p><ul><li>若实参为一维数组，则形参是指向数组所存元素类型的指针；</li><li>若实参为多维数组，则形参是指向一维或多维数组的指针；</li><li><strong>转换并不是递归的</strong>，数组的数组会被改成为 <code>数组的指针</code>，而不是 <code>指针の指针</code>；而三维数组 <code>char ho[2][3][4]</code> 会被转换为 <code>char (*)[3][4]</code> 类型。</li></ul><p>为了进一步说明参数传递时发生的隐式转换，我们先了解一下以下几个类型以及它们之间的关系。</p><p>指针数组：<code>char *c[10]</code><br>指针の指针：<code>char **c</code></p><ul><li><p><code>指针数组</code> 本身是一个一维数组，存的是字符指针。</p></li><li><p><code>指针の指针</code> 本身是一个指针，指向的还是指针。注意它和 <code>二维数组</code> 的区别，<strong>可以说两者是毫无关系的</strong>。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> abc[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">char</span> **pp = abc; <span class="comment">// 会给出警告，类型不兼容。</span></span><br></pre></td></tr></table></figure></li></ul><p>二维数组：<code>char c[8][10]</code><br>数组指针（行指针）：<code>char (*c)[10]</code></p><ul><li><p><code>二维数组</code>本身是一个数组，存的还是数组。</p></li><li><p><code>数组指针（行指针）</code> 本身是一个指针，指向的是数组，一般和 <code>二维数组</code> 一起使用。我们要注意它和 <code>指针数组</code> 在写法上的区别（多了括号，先做 <code>*</code> 单目运算）。</p></li></ul><p>接着，我们看一下隐式转换如何被运用到上述类型中。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/l2atv.jpg" alt="实参与所匹配的形参（来源见参考）"></p><p>图中，数组的数组（即二维数组）被隐式转换为 <code>char (*)[10]</code>，称为 <code>数组指针</code> 或 <code>行指针</code>。指针数组 <code>char *c[10]</code> 被隐式转换为 <code>char **c</code>，称为 <code>指针の指针</code>。若实参本身是指针，则无需进行隐式转换。</p><p>最后，举两个例子来验证一下参数传递中是否发生了隐式转换。</p><ul><li><p><strong>例子 1</strong></p><p>  main 函数的 argv 参数被隐式转换为 <code>char **</code> 指针类型。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序 A 会出现 warning：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: sizeof on array function parameter will return size of &#x27;char *&#x27; instead of &#x27;char []&#x27; [-Wsizeof-array-argument]</span><br></pre></td></tr></table></figure><p>  两个程序输出都为 8，即指针类型的大小，而不是 argv 数组的大小，因为 argv 已经被转换为一个指针了。</p></li><li><p><strong>例子 2</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> (*fnum)[<span class="number">5</span>])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;foo: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(fnum));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;foo: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;fnum));</span><br><span class="line">  fnum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> num[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main: %lu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;num));</span><br><span class="line">  foo(num);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  输出：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main: 60</span><br><span class="line">main: 8</span><br><span class="line">foo: 8</span><br><span class="line">foo: 8</span><br></pre></td></tr></table></figure><p>  可以看到，在 foo 函数里，sizeof(fnum) 的大小是 8，而不等于 main 函数里的 60。因此，fnum 不再是数组，而是一个指针。如果将 <code>int (*fnum)[5]</code> 改成 <code>int fnum[][5]</code>，fnum 仍然是一个指针。</p><p>  <strong>注意：</strong>如果将 <code>int (*fnum)[5]</code> 改成 <code>int (*fnum)[]</code>，不会有警告和报错。如果此时在添加指针运算 <code>fnum++</code>，则编译器会报错，因为编译器不知道指针运算中偏移量是多少。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: arithmetic on a pointer to an incomplete type &#x27;int []&#x27;</span><br></pre></td></tr></table></figure><p>  此外，将 <code>int fnum[][5]</code> 改成 <code>int fnum[][]</code> 也会有报错。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: array has incomplete element type &#x27;int []&#x27;</span><br></pre></td></tr></table></figure></li></ul><p>总结：C is a nightmare.</p><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/40973588/answer/91761240">C 语言指针的指针和二维数组的区别？</a></li><li><a href="https://www.cnblogs.com/stoneJin/archive/2011/09/21/2184211.html">二维数组和指向指针的指针</a></li><li>Expert C Programming</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二维数组 </tag>
            
            <tag> 指针数组 </tag>
            
            <tag> 数组指针 </tag>
            
            <tag> 隐式转换 </tag>
            
            <tag> Expert C Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言数组：不要再叫我是指针了！</title>
      <link href="/2018/09/20/038_C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%EF%BC%9A%E4%B8%8D%E8%A6%81%E5%86%8D%E5%8F%AB%E6%88%91%E6%98%AF%E6%8C%87%E9%92%88%E4%BA%86%EF%BC%81/"/>
      <url>/2018/09/20/038_C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%EF%BC%9A%E4%B8%8D%E8%A6%81%E5%86%8D%E5%8F%AB%E6%88%91%E6%98%AF%E6%8C%87%E9%92%88%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>在整理有关指针和数组名之间的隐式转换、二维数组、指针数组等笔记时，总感觉自己对指针和数组本身概念的理解比较模糊，因此特地整理此文，梳理思路。</p><p><strong>指针和数组之间没有任何关系！</strong>指针就是指针，指针变量在 32 位系统下，永远占 4 个字节，其值为一个内存的地址。指针可以指向任何地方，但是不是任何地方都能通过这个指针变量访问到。数组就是数组，其大小与元素的类型和个数有关。定义数组时必须指定其元素的类型和个数。数组可以存任何类型的数据，但不能存函数。</p><p>为什么很多人容易把数组和指针混淆，甚至认为指针和数组是一样的？最主要的原因是它们都可以 <code>以指针形式</code> 和 <code>以数组下标形式</code> 这两种形式去访问。</p><span id="more"></span><h2 id="两种访问指针和数组的形式"><a href="#两种访问指针和数组的形式" class="headerlink" title="两种访问指针和数组的形式"></a>两种访问指针和数组的形式</h2><h3 id="访问一个指针"><a href="#访问一个指针" class="headerlink" title="访问一个指针"></a>访问一个指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里定义了一个指针变量 p，本身在栈上占 4 个字节，p 里存储的是一块内存的首地址。这块内存在常量区，其大小为 7 字节。由于这块内存没有名字，对这块内存的访问完全是 <code>匿名</code> 的。我们可以通过两种方式进行访问：</p><ul><li><p>以指针形式访问</p><p>  <code>*(p + 4)</code>，先取出 p 里存储的地址值，然后加上 4 个字符大小的偏移量，得到新的地址，最后取出新地址上的值。</p></li><li><p>以数组下标形式访问</p><p>  <code>p[4]</code>，<strong>但是编译器总是把以下标的形式的操作解析为以指针的形式的操作</strong>。因此，以下标的形式访问在本质上与以指针的形式访问没有区别，只是写法上不同。此外，比较有趣的是，我们可以将 <code>p[4]</code> 写成 <code>4[p]</code>，编译器并不会报错，因为它将 <code>4[p]</code> 解析为 <code>*(4 + p)</code>。</p></li></ul><h3 id="访问一个数组"><a href="#访问一个数组" class="headerlink" title="访问一个数组"></a>访问一个数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;123456&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里定义了一个数组 a，a 拥有 7 个字符类型的元素，其空间大小为 7 字节（包括 <code>&#39;\0&#39;</code>）。数组 a 本身在栈上，对 a 元素的访问必须先根据数组的名字 a 找到数组第一个元素的地址，然后根据偏移量找到相应的值。这是一种典型的 <code>具名+匿名</code> 访问。</p><ul><li><p>以指针形式访问</p><p>  <code>*(a + 4)</code>，a 这时候代表的是数组第一个元素的地址，然后加上 4 个字符的偏移量得到新的地址，最后取出地址上的值。</p></li><li><p>以下标形式访问</p><p>  <code>a[4]</code>，同理转换成以指针访问的形式。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由上面的分析，我们可以看到，指针和数组是两个完全不一样的东西，只是它们都可以 <code>以指针形式</code> 或 <code>以下标形式</code> 进行访问。访问指针是完全匿名的访问，而访问数组是典型的 <code>具名+匿名</code> 访问。最后，一定要注意的是 <code>以 XXX 形式访问</code> 这种表达方式。</p><h2 id="a-和-a-的区别"><a href="#a-和-a-的区别" class="headerlink" title="a 和 &amp;a 的区别"></a>a 和 &amp;a 的区别</h2><p>对于 <code>int a[4]</code>，a 有两种含义：</p><ul><li>指向第一个元素的指针</li><li>指向数组的指针</li></ul><p><strong>两者的值相等，但意义不同</strong>。在多数情况下，a 可以看做是指向第一个元素的指针，即在加减运算中表现为指向 int 类型的指针。（但注意的是，a 不是变量，不可以被赋值）</p><p>因此，我们可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = a; <span class="comment">// 等价于 int *p = &amp;a[0];</span></span><br></pre></td></tr></table></figure><p>然而，数组名 a 在以下两种情况下不能当做指向第一个元素的指针：</p><ol><li><p><code>sizeof(a)</code></p><p> 得到的是数组的大小，即 16 字节。而不是将其理解为 int 类型指针的大小，即 8 字节（假定在 64 位系统下）。<strong>但是就像之前说的，它表现为一个指向 int 类型指针。</strong></p></li><li><p><code>sizeof(&amp;a)</code></p><p> 得到的是指向长度为 4 的数组的指针（64 位下 8 字节），即 <code>int (*)[4]</code> 类型，运算时位移量是按照整个数组大小进行计算，即 <code>&amp;a + 1</code> 表示的是下一个数组。注意，这里的 4 不能省略，因为指向不确定长度的指针是没有意义的，编译器若不知道指向数组的大小，就无法获得位移量并编译指针的加减运算。<strong>它表现得像一个数组指针。</strong></p><p> 如果要定义一个指向该数组的指针，应该这么写：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = &amp;a; <span class="comment">// 而不是 int *p = &amp;a;</span></span><br><span class="line"><span class="comment">// sizeof(&amp;a) 的值为 8，指针类型的大小</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong>数组 a 并没有被转换成指针，尽管有的文章这么说。</p><h2 id="指针和数组的定义与声明"><a href="#指针和数组的定义与声明" class="headerlink" title="指针和数组的定义与声明"></a>指针和数组的定义与声明</h2><p>为了进一步说明指针和数组是两个独立的概念，我们还可以通过定义与声明的角度去理解。</p><h3 id="定义为数组，声明为指针"><a href="#定义为数组，声明为指针" class="headerlink" title="定义为数组，声明为指针"></a>定义为数组，声明为指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 1 - 定义</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 文件 2 - 声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *a;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: redeclaration of &#x27;abc&#x27; with a different type: &#x27;char *&#x27; vs &#x27;char [100]&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意到了吗，they are different types！</strong></p><p>数组就是数组，指针就是指针，它们是完全不同的两码事。<code>char a[100]</code> 是定义，系统为它分配了 100 字节的内存空间。在文件 2 下，编译器认为 a 是一个指针变量，在 64 位下占 8 个字节。虽然在文件 1 下，编译器知道 a 是一个数组，但在文件 2 下，编译器并不知道这一点，此时大小存在冲突。</p><p>此外，在文件 1 中，分配的内存空间中存的是 char 元素，是内容本身；而在文件 2 中，编译器将这些内容理解为 8 个字节的地址。</p><h4 id="进一步解释（参考-Expert-C-Programming）"><a href="#进一步解释（参考-Expert-C-Programming）" class="headerlink" title="进一步解释（参考 Expert C Programming）"></a>进一步解释（参考 Expert C Programming）</h4><p>首先，需要注意 <code>地址 y</code> 和 <code>地址 p 的内容</code> 两者的区别，这相当微妙，而且在大多数编程语言中我们用同一个符号来表示这两样东西。</p><ul><li>左值：出现在赋值符左边的符号，编译时可知，表示存储结果的地方。</li><li>右值：出现在赋值符右边的符号，运行时才知，表示为地址的内容。</li></ul><p>C 语言引入<strong>可修改的左值</strong>这个术语。数组名是个左值，但不能被修改。标准规定赋值符 <code>必须</code> 用可修改的左值作为它左边的操作数，即只能给可以修改的东西赋值，所以这就是为什么数组名不能被赋值的原因。</p><p>再看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> a[]; <span class="comment">// √</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *a; <span class="comment">// ✕</span></span><br></pre></td></tr></table></figure><p>这里的关键之处在于每个符号的地址在编译时可知。所以，如果编译器需要一个地址（可能还需要偏移量）来执行某种操作，它就可以直接进行操作，并不需要增加指令首先取得具体的地址。</p><p>相反，对于指针，必须首先知道在运行时取得它的当前值。第一个声明 <code>extern char a[]</code> 提示了 a 是一个数组，也就是一个内存地址（链接时符号都被替换成真正的地址）；第二个声明 <code>extern char *a</code> 告诉编译器 a 是一个指针，我们只知道指针本身所在的地址，而不知道它所指向 char 对象的地址（即变量的值）。</p><h3 id="定义为指针，声明为数组"><a href="#定义为指针，声明为数组" class="headerlink" title="定义为指针，声明为数组"></a>定义为指针，声明为数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 1 - 定义</span></span><br><span class="line"><span class="type">char</span> *a;</span><br><span class="line"><span class="comment">// 文件 2 - 声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> a[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: redeclaration of &#x27;abc&#x27; with a different type: &#x27;char [100]&#x27; vs &#x27;char *&#x27;</span><br></pre></td></tr></table></figure><p>同理。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，我们应该知道数组与指针的的确确是两码事了。他们之间是不可以混淆的，但是我们可以说「以 XXX 的形式」访问数组的元素或指针指向的内容。此外，以后一定要确认你的代码在一个地方定义为指针，在别的地方也只能声明为指针；在一个的地方定义为数组，在别的地方也只能声明为数组。</p><p><strong>注意：</strong>在指针参数中存在隐式转换，两者是可以转换的（可参考：<a href="https://www.junhaow.com/2018/10/01/039%20%7C%20%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9A%E6%8A%8A%20C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E9%92%88/">隐式转换：把 C 语言数组转换为指针</a>）。</p><p>指针与数组的特性总结（来源请看参考）：</p><table><thead><tr><th>指针</th><th>数组</th></tr></thead><tbody><tr><td>保存数据的地址，任何存入变量的数据都会被当做地址来处理。变量本身的地址由编译器另外存储，我们并不知道在哪里。</td><td>保存数据。数组名代表的是数组第一个元素的地址，而不是数组的地址；<code>&amp;数组名</code> 才是整个数组的地址。a 本身的地址由编译器另外存储，我们并不知道在哪里。</td></tr><tr><td>间接访问数据：访问是 <code>完全匿名</code> 的。首先取得变量的内容，把它作为地址，然后根据这个地址提取或写入数据。</td><td>直接访问数据：数组名就是整个数组的名字，数组内每个元素没有名字。只能通过 <code>具名+匿名</code> 的方式来访问某个元素，不能把整个数组当做一个整体进行读写操作。</td></tr><tr><td>通常用于动态数据结构，相关的函数有 malloc 和 free。</td><td>通常用于存储固定数目且数据类型相同的元素，隐式分配和销毁。</td></tr><tr><td>通常指向匿名数据（也可以指向具名数据）</td><td>自身为具名数据（数组名）</td></tr><tr><td>初始化时编译器并不为指针所指向的对象分配空间，只分配指针本身，除非在定义时同时赋值给指针一个字符串常量。</td><td>数组在初始化时为对象分配了空间。</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://c.biancheng.net/cpp/html/475.html">C 语言指针与数组之间的恩恩怨怨</a></li><li><a href="https://www.zhihu.com/question/41805285">C 中，数组名跟指针有区别吗？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU 的两种工作模式：实模式和保护模式</title>
      <link href="/2018/08/27/037_CPU%20%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/27/037_CPU%20%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。</p><h2 id="实模式（Real-Mode）"><a href="#实模式（Real-Mode）" class="headerlink" title="实模式（Real Mode）"></a>实模式（Real Mode）</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>实模式出现于早期 8086 CPU 时期，8086 也是第一款支持内存分段模型的处理器。当时，8086 只有一种工作模式，即实模式，但当时还没有这个说法。由于 CPU 的性能有限，一共只有 20 位地址线（地址空间只有 1M），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位的物理地址只能访问 64KB 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，访问 1 MB 的内存，必须采取一种特殊的方式。</p><span id="more"></span><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>第一个字段是由段寄存器提供的，是一个 16 位的段基址。第二字段是段内偏移量，它的值是由通用寄存器（如 EIP）来提供，所以也是 16 位。那么问题来了，两个 16 位的值如何组合成一个 20 位的地址呢？这里采用的方式是：把段寄存器所提供的段基址先向左移 4 位（或乘以 16），这样就变成了一个 20 位的值，然后再与 16 位的段偏移量相加。如下所示：</p><p>$$物理地址 &#x3D; 段基址 &lt;&lt; 4 + 段内偏移$$</p><p>所以，假设段基址的值是 <code>0xFF00</code>，段内偏移的值是 <code>0x0110</code>。则物理地址可表示为： </p><p>$$0xFF00 &lt;&lt; 4 + 0x0110 &#x3D; 0xFF000 + 0x0110 &#x3D; 0xFF110$$</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>在现代计算机上，实模式存在的时间非常短</strong>，所以一般我们是感觉不到它的存在。CPU 复位（reset）或加电（power on）的时候就是以实模式启动，在这个时候处理器以实模式工作，不能实现权限分级，也不能访问 20 位以上的地址线，也就只能访问 1M 内存。之后，加载操作系统模块，进入保护模式。</p><p>此外，在这种模式下，系统在计算实际地址的时候是按照对 1M 求模的方式进行的，这种技术被称为 wrap-around。也就是说，当程序员给出超过 1M（100000H ~ 10FFEFH）的地址时，为了保持逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从 0 开始计算。</p><p>然而，在实模式中整个物理内存被看成分段的区域，程序代码和数据位于不同区域，<strong>系统程序和用户程序没有区别对待</strong>，而且每一个指针都是指向「实在」的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，容易造成软件甚至系统崩溃。</p><h2 id="保护模式（Protected-Mode）"><a href="#保护模式（Protected-Mode）" class="headerlink" title="保护模式（Protected Mode）"></a>保护模式（Protected Mode）</h2><h3 id="起源-1"><a href="#起源-1" class="headerlink" title="起源"></a>起源</h3><p>最开始的程序寻址是直接的 <code>段基址 : 段内偏移</code> 模式，这样的好处是所见即所得，程序员指定的地址就是物理地址，物理地址对程序员是可见的。但这就带来一些问题：</p><ol><li>无法支持多任务</li><li>程序的安全性无法得到保证</li></ol><p>随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为现在的 32 根，所以可以访问的内存空间也从 1 MB 变为现在 4 GB，寄存器的位数也变为 32 位。因此，实模式下的内存地址计算方式就已经不再适用了，需要引入新的模式，即保护模式，实现更大空间的、更灵活的内存访问。</p><p>在保护模式下，全部 32 条地址线有效，可寻址高达 4 GB 的物理地址空间。扩充的存储器 <code>段式管理机制</code> 和可选的 <code>页式管理机制</code>，不仅为存储器共享和保护提供了硬件支持，而且为实现 <code>虚拟存储器</code> 提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境。四个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全及任务的隔离。</p><p>总的来说，保护模式出现的原因名副其实：<strong>保护进程地址空间</strong>。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在保护模式下，地址的表示方式与实模式是一样的，都是 <code>段基址 : 段内偏移</code>。不过，保护模式下 <code>段</code> 的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子&#x2F;段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了 <code>段基址</code>、<code>界限</code>、<code>属性（权限）</code>等内容。这个数据结构是 <code>全局描述符</code>（GDT，Global Descriptor Table），也有可能是 <code>本地描述符</code>（LDT，Local Descriptor Table）。它们存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大。</p><p>GDT 的作用是用来提供段式存储机制，这种机制是段寄存器和 GDT 中的描述符（段表项）共同支持的。每个描述符在 GDT 中占 8 字节，也就是 2 个双字（一个字等于两个字节，双字等于四个字节），或者说是 64 位。描述符的构成如下图所示：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/le2mx.jpg" alt="GDT 描述符示意图（来源见参考）"></p><p>其中：</p><ul><li>G 位是 <code>粒度位</code>（Granularity），用于解释段界限的含义；</li><li>D&#x2F;B 位是 <code>默认的操作数大小</code>（Default Operation Size），主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序；</li><li>L 位，是 <code>64 位代码段标志</code>，保留此位给 64 位处理器使用；</li><li>AVL 位，是 <code>可以使用的位</code>（Available），通常由操作系统来用，处理器并不使用它；</li><li>P 位是 <code>段存在位</code>（Segment Present），表示对应的段是否存在；</li><li>DPL 表示描述符的 <code>特权级</code>（Descriptor Privilege Level），<code>0 ~ 3</code>，0 表示最高特权级别，<strong>这里再次点明了为何叫保护模式</strong>；</li><li>S 位是 <code>描述符的类型位</code>（Descriptor Type），0 为系统段，1 为代码段或数据段；</li><li>TYPE 字段共 4 位，用于指示描述符的类型（X 执行、W 读写、R 读出、A 已访问）。</li></ul><p>很明显，描述符中指定了 32 位的 <code>段基址</code>，以及 20 位的 <code>段界限</code>。在实模式下，段基址并非是真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段基址是 32 位的，若加上段内偏移即为 <code>线性地址</code>。如果未开启分页功能，该线性地址就是 <code>物理地址</code>。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/m3h63.jpg" alt="GDT 和 LDT 示意图（来源见参考）"></p><p>GDT 和 LDT 的区别在于：</p><ol><li>全局可见（global）和局部可见（local）；</li><li>LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符；</li><li>LDT 本身是一个段，而 GDT 不是。</li></ol><p><strong>访问流程：</strong></p><ul><li>查找 GDT 在线性地址中的段基址（表本身的位置），需要借助 GDTR 寄存器；</li><li>通过该段基址和 <code>逻辑地址</code> 中的段标识符（selector），可以找到 LDT 段描述符；</li><li>通过 GDT 中的这个 LDT 段描述符可以找到 LDT 相应的基地址；</li><li>访问 LDT 需要使用 LDT 基地址和 LDT 段选择符（或叫段标识符），为了减少访问 LDT 时的段转换次数，LDT 段基址、LDT 段选择符、LDT 段限长都存放在 LDTR 寄存器中。</li></ul><p><strong>注意：</strong>这里和 <a href="https://junhaow.com/2018/08/15/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93/">关于操作系统内存管理的总结</a> 中关于段式内存管理的描述有点出入。这里多了 LDT，因此从 GDT 中获得的是 LDT 段描述符，而不再是段基址。</p><p>对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。系统可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；而 LDT 本身是一个段。</p><p>想知道更多可以参考第三篇文章，整理得很好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/fatsheep9146/p/5116426.html">MIT 6.828 JOS 学习笔记 6. Appendix 1: 实模式（real mode）与保护模式（protected mode）</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html">操作系统篇-浅谈实模式与保护模式</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">操作系统篇-分段机制与 GDT | LDT</a></li><li><a href="http://www.voidcn.com/article/p-cdfddfhd-dr.html">汇编学习（十七）X86汇编学习 (4) GDT</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU 工作模式 </tag>
            
            <tag> 实模式 </tag>
            
            <tag> 保护模式 </tag>
            
            <tag> Real Mode </tag>
            
            <tag> Protected Mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于操作系统内存管理的总结</title>
      <link href="/2018/08/15/036_%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/15/036_%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>许多年以前，当人们还在使用 DOS 或是更古老的操作系统的时候，计算机的内存还非常小。随着应用程序的规模逐渐膨胀，一个难题出现在程序员的面前，那就是应用程序太大以至于内存容纳不下该程序。</p><p>通常解决的办法是把程序分割成许多称为 <code>覆盖块</code>（overlay）的片段。覆盖块 0 首先运行，结束时他将调用另一个覆盖块。虽然覆盖块的交换是由操作系统完成的，<strong>但是必须先由程序员把程序先进行分割</strong>，这是一个费时费力的工作，而且相当枯燥。</p><span id="more"></span><p>人们必须找到更好的办法从根本上解决这个问题。不久人们找到了一个办法，这就是虚拟存储器（virtual memory）。<strong>虚拟存储器的基本思想是程序、数据、堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上。</strong></p><p>比如，对一个 16 MB 的程序和一个内存只有 4 MB 的机器，操作系统通过选择，可以决定各个时刻将哪 4 MB 的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段。而这个 16 MB 的程序<strong>在运行前不必由程序员进行分割</strong>。</p><ul><li>$1K &#x3D; 2^{10}\ (10\ bits) &#x3D; 1,024$</li><li>$1M &#x3D; 2^{20}\ (20\ bits) &#x3D; 1,048,576$</li><li>$1G &#x3D; 2^{30}\ (30\ bits) &#x3D; 1,073,741,824$</li><li>$1T &#x3D; 2^{40}\ (40\ bits) &#x3D; 1,099,511,627,776$</li></ul><p><strong>注意：</strong>要区分 <code>寻址能力</code> 和 <code>内容大小</code>，且寻址能力和内存大小没什么关系，而是与地址总线有关。每个地址表示一个 Byte（大写 B 表示字节，小写 b 表示位），32 位寻址能力为 $2^{32} &#x3D; 2^2 \times 2^{30} &#x3D; 4 \times G &#x3D; 4G$（没有 B），可表示的内容大小为 $4G \times 1\ Byte &#x3D; 4 GB$。</p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>在任何时候，计算机上都存在一个程序能够产生的地址集合，我们称之为 <code>地址范围</code>。这个范围是我们的程序能够产生的地址范围，如一个 32 位的 CPU，地址范围是 <code>0 ~ 0xFFFFFFFF</code>。我们把这个地址范围称为 <code>虚拟地址空间</code>，该空间中的某个地址叫做 <code>虚拟地址</code>（virtual address）。</p><blockquote><p>其实应该使用「逻辑地址」，后文会详细介绍「虚拟地址」的来源和概念，上面这段话使用这个概念只是方便与物理地址做对应，而虚拟地址实际上代表的是「偏移量」。</p></blockquote><p>与虚拟地址空间和虚拟地址相对应的则是 <code>物理地址空间</code> 和 <code>物理地址</code>（physical address），大多数时候系统所具备的物理地址空间只是虚拟地址空间的一个子集。比如，对于一台内存为 256 MB 的 32 位 x86 主机来说，它的虚拟地址空间范围是 <code>0 ~ 0xFFFFFFFF（4G）</code>，而物理地址空间范围是 <code>0 ~ 0x0FFFFFFF（256M，即 2^28）</code>。</p><blockquote><p>256 MB 内存可以存放 256 MB 大小的内容，表示这些内容需要的地址空间为 256 MB &#x2F; 1 Byte &#x3D; 256M。</p></blockquote><p>这里有一个<code>虚拟内存</code>（virtual memory）的概念，是对整个内存（不要和机器上插的那条对上号）的抽象描述，并不与实际的物理内存一一对应。有了这样的抽象，一个程序就能使用比真实物理地址大得多的地址空间，甚至多个进程能使用相同的地址，因为相同的虚拟地址转换后的物理地址并不一定相同。</p><blockquote><p>物理地址中很大一部分是留给内存条中的内存本身，但也常被映射到其他存储器上（显存、BIOS 等）。在没有使用虚拟存储器的机器上，虚拟地址被直接送到内存总线上，使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到存储器管理单元 MMU（Memory Management Unit），把虚拟地址映射为物理地址。</p></blockquote><p>进程使用虚拟地址，由操作系统协助相关硬件，把它转换成真正的物理地址。这个 <code>转换</code>，是所有问题讨论的关键，通常包括 <code>段式内存管理</code> 和 <code>分页内存管理</code>。</p><h3 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h3><p><strong>注意：</strong>读到这里，请读者将前文的 <code>虚拟地址</code> 换成 <code>逻辑地址</code>，下文的 <code>虚拟地址</code> 将是不同的概念。段式内存管理的任务是进行 <code>逻辑地址</code> 与 <code>物理地址</code> 的相互转换。</p><p>逻辑地址是访内指令给出的地址，也叫 <code>相对地址</code>，就是机器语言指令中用来指定一个操作数或是一条指令的地址。但是，它并不是我们平时写代码中遇到的类似 0xFFFF4B1C 的 <code>线性地址</code>。</p><p>在 Intel 32 位平台下，<code>逻辑地址</code>（logical address）是由 <code>段标识符</code>（selector）和 <code>段内偏移</code>（offset）组成。段标识符是段寄存器（CS、DS、SS、ES 等）的值，其中前 13 位为索引信息，后 3 位是硬件信息；段内偏移是 IP、EIP 寄存器的值。通过 <code>段标识符</code> 去 GDT（全局描述符表）里取得 <code>段基址</code>（segment base address）然后加上 <code>段内偏移</code>，这就得到了 <code>线性地址</code>（linear address）。如果不再使用页式内存管理，线性地址也就是 <code>物理地址</code>。</p><ul><li>逻辑地址 &#x3D; 段标识符 : 段内偏移</li><li>段标识符 → 段基址</li><li>线性地址 &#x3D; 段基址 + 段内偏移</li></ul><p>关于寄存器可参考：<a href="https://junhaow.com/2018/06/10/%E5%85%B3%E4%BA%8E%20C%20%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%20PCAL%20%E7%9A%84%E6%80%BB%E7%BB%93/">关于 C 语言编译流程 PCAL 的总结</a></p><h4 id="虚拟地址究竟是什么👻？"><a href="#虚拟地址究竟是什么👻？" class="headerlink" title="虚拟地址究竟是什么👻？"></a>虚拟地址究竟是什么👻？</h4><p>参考知乎上的一个回答（文末有链接）：</p><blockquote><p>问题来了，为什么没提到虚拟地址，这是个什么东西？其实在 Intel IA-32 手册里并没有提到这个术语，但是在内核的确是用到了这个概念，比如 __va 和 __pa 这两个宏定义。看似神秘的虚拟地址究其本质就是程序里面使用的地址比如一个指针值，指针的本质就是 EIP 寄存器里的值，说直白点，<strong>虚拟地址就是 EIP 寄存器的值</strong>。你会发现我们上面说过，逻辑地址由段标识符和段内偏移两部分组成，其中段内偏移也是 EIP 寄存器的值，所以结论为：<strong>逻辑地址的段内偏移正是虚拟地址，它俩是一个东西</strong>。</p></blockquote><p>逻辑地址 &#x3D; 段标识符 : 段内偏移（虚拟地址）</p><blockquote><p>既然搞明白了逻辑地址和虚拟地址的关系，那么我们再来看下，线性地址和虚拟地址是什么关系。在上面讲到的段式内存管理中，Linux 内核会将段基址设成 0，于是就有 <code>线性地址 = 0 + 段内偏移</code>，又因为虚拟地址就是段内偏移，所以算出的<strong>线性地址在数值上等于虚拟地址</strong>，注意，仅仅是数值上等于。</p></blockquote><p>在 Linux（Windows 也是）下：线性地址 &#x3D; 0 + 段内偏移（虚拟地址）</p><blockquote><p><strong>网上很多资料认为逻辑地址是虚拟地址的别名，其实它们不是一个东西</strong>。还有很多资料把线性地址当作虚拟地址的别名，其实它们也不是一个东西，只是 Linux 在 x86 下将它们弄得数值相等而已，虽然值相等但是本质不同。</p></blockquote><p>到这里，三者之间的关系就讲明白了，虽然逻辑地址的概念很清晰，但是虚拟地址和线性地址依然可以不作区分，因为区分了也没什么用，内核里这俩概念是通用的。不过，知道点区别还是不至于在某些时候把自己搞晕，尤其是有些书和教程里面这两个词不说缘由就混着用。</p><p>这三者关系为何如此混乱？</p><blockquote><p>按照 Intel 的设计，段式内存管理中的段类型分为三种：代码段、数据段、系统段（TSS 之类的），实在是太麻烦了。我们只靠页式内存管理就已经可以完成 Linux 内核需要的所有功能，根本不需要段映射，但是段映射这玩意儿又关不掉，那就只能上点手段了。于是，Linux 内核将所有类型的段的段基址都设成 0，段限长都设成最大（具体数值不展开讲了，涉及到段描述符结构，很麻烦，这里理解成地址总线的最大寻址限度即可），那么这样一来所有段都重合了，也就是不分段了，此外由于段限长是地址总线的寻址限度，所以这也相当于所有段跟整个线性空间重合了。</p></blockquote><blockquote><p>虚拟地址本来是在段内的偏移量，现在段就是整个线性空间，所以虚拟地址就成了在整个线性空间内的偏移量，这和线性地址的概念一样，所以内核开发者都已经将虚拟地址和线性地址当作一个东西了。像是《Understand The Linux Kernel》这本书里面为了避免混淆，除了在开头和术语表中引用了虚拟地址这个术语之外，其他地方全是用的线性地址。</p></blockquote><h3 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h3><p>如果再把线性地址分成四段，用前三段分别作为索引去 PGD（page global directory）、PMD（page middle directory）、PT（page table）里查表，最终就会得到一个 <code>页表项</code>（page table entry），里面存着的值是一页物理内存的起始地址，把它加上线性地址中第四段的内容（页内偏移）就得到了最终的 <code>物理地址</code>。</p><p>大多数使用虚拟存储器的系统都采用这种称为 <code>分页</code>（paging）的机制。虚拟地址空间被划分成 <code>页</code>（page）单位，而相应的物理地址空间也被进行划分，单位是 <code>页桢</code>（frame）。<strong>页和页桢的大小必须相同，因为内存和外围存储器之间的传输总是以页为单位的</strong>。比如，在前文内存为 256 MB 的例子中，页的大小为 4 KB，其对应 4G 的虚拟地址空间和 256M 的物理地址空间，它们分别包含了 1M 个页和 64K 个页桢。</p><blockquote><p>$1G &#x3D; 1M \times 1K$</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/29918252/answer/163114415">Linux 线性地址，逻辑地址和虚拟地址的关系？</a></li><li><a href="https://blog.csdn.net/prike/article/details/52722934">逻辑地址、线性地址和物理地址的关系（转）</a></li><li><a href="http://bbs.chinaunix.net/thread-2083672-1-1.html">我理解的逻辑地址、线性地址、物理地址和虚拟地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统内存管理 </tag>
            
            <tag> 寻址 </tag>
            
            <tag> 地址 </tag>
            
            <tag> 虚拟地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习 i++ 和 ++i 的本质区别</title>
      <link href="/2018/08/07/035_%E5%AD%A6%E4%B9%A0%20i++%20%E5%92%8C%20++i%20%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/08/07/035_%E5%AD%A6%E4%B9%A0%20i++%20%E5%92%8C%20++i%20%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>最近在朋友圈看到一篇解释 <code>i++</code> 和 <code>++i</code> 的文章，觉得非常有意思，就把要点记录下来。</p><blockquote><p>你的解释不是我想要的…</p></blockquote><p>先看两段代码 <code>HelloWorld_1</code> 和 <code>HelloWorld_2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld_1.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        System.out.println(i); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld_2.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i = ++i;</span><br><span class="line">        System.out.println(i); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家应该一眼就知道运行结果，第一段代码是 0，第二段代码是 1，但关键是：<strong>为什么只是换了一下顺序，结果就不一样了？</strong></p><p>一般的解释：<code>i = i++</code>，会先赋值，再加一，所以结果是 0，而 <code>i = ++i</code>，会先把 i 加一，然后再赋值，所以结果是 1。</p><blockquote><p>全场感叹，都向那位同学投以敬佩的目光，毕竟他的理论足以解释现象。</p></blockquote><p>然而，提问的人说了一句，<strong>“你的解释不是我想要的……”</strong></p><p>一般的解释不能说不对，但是没有说到关键点上，因为这是以<strong>高级语言的角度</strong>来解释的。为了深入理解，我们需要从<strong>更低级的层面</strong>去获取答案。</p><p>Java 的跨平台靠 JVM（Java 虚拟机）这个翻译官来实现。你写好的代码，会被编译成一个 <code>.class</code> 文件，也就是 Java 字节码文件，这里面记录的是一系列要在 JVM 执行的指令。接着，你拿着这份字节码指令，去到任意一个 JVM（Linux 的 JVM、OS X 的 JVM），它们都会帮你把它翻译成不同平台所对应的机器指令（机器码）。这就实现了跨平台。</p><p>回到问题，<code>i++</code> 和 <code>++i</code> 为什么会不一样呢？我们先通过 <code>javac</code> 和 <code>javap</code> 命令获得字节码指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld_1.java</span><br></pre></td></tr></table></figure><p>可以得到 <code>HelloWorld_1.class</code> 文件。class 文件里面都是二进制的数据，因为这些都是告诉 JVM 要做什么事情的指令，而机器只看得懂二进制。所以，我们需要对这个二进制反汇编，把它变成人类看得懂的语言。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c HelloWorld_1.class</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>为了方便比较，源代码中的 <code>System.out.println(i)</code> 已被删掉。</p><p>命令执行后，控制台打印出一系列的字节码指令，其中main函数的字节码指令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: iconst_0</span><br><span class="line">     <span class="number">1</span>: istore_1</span><br><span class="line">     <span class="number">2</span>: iload_1</span><br><span class="line">     <span class="number">3</span>: iinc <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">     <span class="number">6</span>: istore_1</span><br><span class="line">     <span class="number">7</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这一串的指令，主要涉及到两个数据结构，一个是操作数栈（operand stack），另一个是局部变量表（local variable）。前者是栈，后者是数组。</p><ol><li><p>iconst_0</p><p> 把一个值为 0 的 int 值压到操作数栈中。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/tfego.jpg"></p></li><li><p>istore_1</p><p> 从操作数栈中弹出一个值，存放到局部变量表下标为 1 的位置（为什么不是 0 或者 2 ？因为前面有个 String 数组的参数 args，所以不是 0。又因为方法是 static 的，没有 this 引用，所以不是 2）。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bgwky.jpg"></p><p> 以上两条指令对应的是第一行代码 <code>int i = 0</code>，它实现了给 i 赋值，并且把 i 放到局部变量表的功能。接下来是 <code>i = i++</code> 对应的指令。</p></li><li><p>iload_1</p><p> 把局部变量表中索引为 1 的值压到操作数栈中（表中的值仍存在）。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gjmyj.jpg"></p></li><li><p>iinc 1, 1</p><p> 对局部变量表索引为 1 的值进行加一操作。iinc 指令第一个参数代表索引值，第二个参数代表加多少。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/metfe.jpg"></p><p> 此时，局部变量表中 i 的值等于 1，为什么最后打印出来还是 0 呢？问题出在最后一条指令。</p></li><li><p>istore_1</p><p> 从操作数栈中弹出一个值，将它赋值给局部变量表中索引为 1 的值。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ptguh.jpg"></p><p> 完蛋，这下 i 又变成 0 了！</p></li></ol><p>这就是 i 为 0 的本质原因。向别人解释的时候可以总结为以下三点：</p><ol><li>赋值的本质是<strong>两步操作</strong>，先将等号右边的值压进操作数栈（iload），再将操作数栈中的值弹出至局部变量表中对应的位置上（istore）。</li><li>++ 的本质是 <code>iinc</code> 指令，操作的对象<strong>局部变量表</strong>，而不是操作数栈。</li><li><code>i = i++</code> 对应三条指令的顺序是：iload_1、iinc 1,1、istore_1。</li></ol><p>至于 <code>i = ++i</code>，它与前者的区别在 iload_1 和 iinc 的顺序上。当 iinc 在前，赋值前局部变量表中对应的值已为 1，且赋值操作的两条指令相邻，不存在归零现象。</p><p>最后，本文所提到的操作数栈和局部变量表只是 JVM 运行时数据区域中很小的一块（JVM Stack， 虚拟机栈），完整的模型图如下：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gegfj.jpg" alt="JVM 运行时数据区域图"></p><p>参考：<a href="https://mp.weixin.qq.com/s/WlfauLoyJtMeINL336XatQ">Java 第一课 by Bridge4You</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不要再混淆 C 语言变量的声明和定义</title>
      <link href="/2018/07/31/034_%E4%B8%8D%E8%A6%81%E5%86%8D%E6%B7%B7%E6%B7%86%20C%20%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/"/>
      <url>/2018/07/31/034_%E4%B8%8D%E8%A6%81%E5%86%8D%E6%B7%B7%E6%B7%86%20C%20%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，我们对变量的 <code>声明</code>（Declaration）和 <code>定义</code>（Definition）的理解如下：</p><ul><li><strong>声明</strong>：用于向程序表明变量的类型和名字。在程序中，变量可以被多次声明。</li><li><strong>定义</strong>：用于为变量分配存储空间，还可以为变量指定初始值。在程序中，变量有且只有一个定义。</li></ul><p><strong>两者主要区别：</strong>是否在内存中分配了空间。</p><blockquote><p>只要记住下面的内容即可分清定义和声明：<br>声明相当于 <code>普通</code> 的声明：它所说明的并非本身，而是描述在其他地方创建的对象。<br>定义相当于 <code>特殊</code> 的声明：它为对象分配内存。<br>——《Expert C Programming》</p></blockquote><span id="more"></span><h2 id="进一步解读"><a href="#进一步解读" class="headerlink" title="进一步解读"></a>进一步解读</h2><ul><li>定义也是声明，定义变量时我们声明了它的类型和名字。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;  <span class="comment">// 可以叫「声明」或「定义」，但「定义」更为准确</span></span><br></pre></td></tr></table></figure></li><li>声明并<strong>不一定</strong>是定义，如 extern 声明。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;  <span class="comment">// 只能叫「声明」</span></span><br></pre></td></tr></table></figure></li><li>带有初始化式的声明是定义。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">5</span>; <span class="comment">// 只能在函数体外初始化</span></span><br></pre></td></tr></table></figure></li><li>函数的声明和定义区别比较简单，带有花括号<code>&#123;&#125;</code>的是定义，否则是声明。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo1</span><span class="params">(<span class="type">int</span> x)</span>;     <span class="comment">// 声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo2</span><span class="params">(<span class="type">int</span> x)</span> &#123; &#125;  <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="程序模块化设计"><a href="#程序模块化设计" class="headerlink" title="程序模块化设计"></a>程序模块化设计</h2><p>模块是一个 <code>.h</code> 文件和一个 <code>.c</code> 文件的结合，头文件 <code>.h</code> 中是对于该模块接口的声明。</p><ul><li>若模块提供给其它模块调用的外部函数及数据需在 <code>.h</code> 中文件中添加 <code>extern</code> 关键字声明。</li><li>模块内的函数和全局变量需在 <code>.c</code> 文件开头添加 <code>static</code> 关键字，注意不是在 <code>.h</code> 文件。</li></ul><p><strong>注意：</strong>不要把变量定义放入 <code>.h</code> 文件，这样容易导致重复定义的错误。</p><p>在 C++ 中，有以下三个例外：</p><ol><li>值在编译时就已知的 const 变量的定义可以放到头文件中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">(<span class="number">10</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>类的定义可以放到头文件中</li><li>inline 函数</li></ol><p>这三个对象可以定义在多个源文件中，只要在每个源文件中的定义相同即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/gatieme/article/details/50640424#t1">C 语言中声明和定义详解</a></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 声明 </tag>
            
            <tag> 定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言无符号与有符号整型溢出的区别</title>
      <link href="/2018/07/15/033_C%20%E8%AF%AD%E8%A8%80%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B8%8E%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/15/033_C%20%E8%AF%AD%E8%A8%80%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B8%8E%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="无符号整型溢出"><a href="#无符号整型溢出" class="headerlink" title="无符号整型溢出"></a>无符号整型溢出</h2><p>对于无符号整型溢出，在 C 的规范中这是有定义的行为，溢出后的数会以 <code>2^(8 * sizeof(type))</code> 作模运算，也就是说，如果一个无符号字符型（1 字节，8 位）溢出了，会把溢出的值与 256 求模。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">0xff</span>; <span class="comment">// 1111 1111</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ++x);    <span class="comment">// 结果为：0</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="有符号整型溢出"><a href="#有符号整型溢出" class="headerlink" title="有符号整型溢出"></a>有符号整型溢出</h2><p>对于有符号整型的溢出，C 的规范定义是 <strong>Undefined Behavior</strong>，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。</p><p><strong>注意：</strong>用补码表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> x = <span class="number">0x7f</span>;  <span class="comment">// 0111 1111 表示最大的正数</span></span><br><span class="line"><span class="comment">// 0xff就是 -1 了，因为最高位是 1 也就是负数了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ++x);   <span class="comment">// -128</span></span><br></pre></td></tr></table></figure><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/426yr.jpg" alt="数据表示示意图（逆时针看）"></p><p><code>++x</code> 的结果为 <code>1000 0000</code>，因为这是补码，所以值为 <code>-128</code>。</p><p>所以，有符号整型的溢出规律 <code>一般</code> 呈环形变化。</p><p>如果还是觉得不能理解可以看一下补码的表示方法：<a href="https://www.junhaow.com/2018/04/20/024%20%7C%20%E5%85%B3%E4%BA%8E%E8%A1%A5%E7%A0%81%E7%9A%84%E6%80%BB%E7%BB%93/">关于补码的总结</a></p><h2 id="整型溢出可能导致死循环"><a href="#整型溢出可能导致死循环" class="headerlink" title="整型溢出可能导致死循环"></a>整型溢出可能导致死循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 32767</span></span><br><span class="line"><span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (len &lt; MAX_LEN) &#123;</span><br><span class="line">    len += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>short 是 2 字节长的有符号整型类型，能表示 <code>-32768 ~ 32767</code> 范围内的整数。当 len 的值为 <code>32766</code> 时，加 2 运算使得其溢出，值为 <code>-32768</code>，而不是 <code>32768</code>，如此不断循环。加 1 不会出现这样的问题，当 len 为 <code>32767</code> 时，循环将会终止。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typedef 的几种用法总结</title>
      <link href="/2018/07/08/032_typedef%20%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/08/032_typedef%20%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="用途一：简单类型"><a href="#用途一：简单类型" class="headerlink" title="用途一：简单类型"></a>用途一：简单类型</h2><p>定义一种类型的别名，而不只是简单的宏替换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UNIT;</span><br></pre></td></tr></table></figure><p>可以用作同时声明指针类型的多个对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pa, pb;   <span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pchar;</span><br><span class="line">pchar pa, pb;   <span class="comment">// both are pointers to char</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p><ul><li>typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如你可以定义 1 为 ONE。</li><li>typedef 是由 <code>编译器</code> 执行解释的，#define 语句是由 <code>预编译器</code> 进行处理的。</li><li>typedef 如果放在所有函数之外，作用域是从定义开始直到文件结尾，反之则到函数结尾；#define 不管放在哪里，作用域都是从定义开始直到整个文件结尾。</li></ul><h2 id="用途二：结构体"><a href="#用途二：结构体" class="headerlink" title="用途二：结构体"></a>用途二：结构体</h2><p>在以前的 C 语言版本中，声明 struct 新变量时，必须要带上 struct，即形式为：<code>struct 结构名 变量名</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure><p>而在 C99 和 C++ 中，则可以直接写：<code>结构名 变量名</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line">Point p1;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以下某些写法是错误的，应该尽量避免。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point1</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Point1</span> <span class="title">next</span>;</span>  <span class="comment">// 不能在定义中使用自己</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point2</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Point2</span> *<span class="title">next</span>;</span>  <span class="comment">// 可以使用指向自己的指针，因为不需要分配空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有这一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *item;</span><br><span class="line">  pNode next;</span><br><span class="line">&#125; *pNode;</span><br></pre></td></tr></table></figure><p>用上面代码定义一个结构时，在 C 和 C++ 中都是错误的定义，编译器会报错，为什么呢？莫非 C 语言不允许在结构中包含指向它自己的指针吗？</p><p>C 语言当然允许在结构中包含指向它自己的指针（上一个例子），我们可以在建立链表等数据结构的实现上看到无数这样的例子，上述代码的根本问题在于 typedef 的应用。</p><p>根据我们上面的阐述可以知道：新结构体建立的过程中遇到了 pNext 域的声明，类型是 pNode，要知道 pNode 表示的是类型的新名字，那么在类型本身还没有建立完成的时候，这个类型的新名字也还不存在，也就是说这个时候编译器根本不认识通过 typedef 定义的 pNode。</p><p>解决办法有以下两种。可以不用 typedef 创建的新类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *item;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *pNode;</span><br></pre></td></tr></table></figure><p>或者先让 typedef 语句执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNode</span>;</span> <span class="comment">// 先说明 typedef</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *item;</span><br><span class="line">  pNode next;</span><br><span class="line">&#125;; <span class="comment">// 注意：在这个例子中，你用 typedef 给一个还未完全声明的类型起新名字。C 语言编译器支持这种做法。</span></span><br></pre></td></tr></table></figure><h2 id="用途三：支持平台无关"><a href="#用途三：支持平台无关" class="headerlink" title="用途三：支持平台无关"></a>用途三：支持平台无关</h2><p>用 typedef 来定义与平台无关的类型。比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure><p>在不支持 long double 的平台二上，改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> REAL;</span><br></pre></td></tr></table></figure><p>在连 double 都不支持的平台三上，改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> REAL;</span><br></pre></td></tr></table></figure><p>也就是说，当跨平台时，<strong>只要改下 typedef 本身就行，不用对其他源码做任何修改</strong>。</p><p>标准库就广泛使用了这个技巧，比如 size_t。另外，因为 typedef 是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏更加稳健，编译器会对类型进行检查。</p><h2 id="用途四：复杂类型"><a href="#用途四：复杂类型" class="headerlink" title="用途四：复杂类型"></a>用途四：复杂类型</h2><p>给复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MyIntArray[<span class="number">100</span>];  <span class="comment">// 数组类型</span></span><br><span class="line">MyIntArray abc;   <span class="comment">// abc 是一个整型数组，长度为 100</span></span><br></pre></td></tr></table></figure><p>理解复杂声明可用「右左法则」：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。如：</p><p><strong>规律：</strong>一般情况下，和定义变量的语法一样，前面加上 typedef，变量名即变成了类型名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*MyFuncPoint)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">// 我们定义 void (*MyFuncPoint)(int); 时，MyFuncPoint 是一个变量</span></span><br><span class="line"><span class="comment">// MyFuncPoint 是一个指向返回值为 void、参数为整型类型的函数的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*func[<span class="number">5</span>])</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="comment">// 注意 [] 的优先级比 * 高</span></span><br><span class="line"><span class="comment">// func 是一个数组，数组里面可以存放 5 个元素，这些元素是指向返回值为整型、参数为指向整型的指针的函数的指针</span></span><br><span class="line"><span class="comment">// X[]：X 是数组，X()：X 是函数，X 中没有解引决定不是指针</span></span><br></pre></td></tr></table></figure><p>通过上面的例子，我们发现直接定义复杂类型的变量非常麻烦，特别是在需要重复定义多次的时候。因此，我们可以善用 typedef 进行简化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default method - define variable signal</span></span><br><span class="line"><span class="type">void</span> (*signal)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p><code>signal</code> 是一个函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef method</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*HANDLER)</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// 先定义 HANDLER 为该类型的函数指针</span></span><br><span class="line">HANDLER signal;</span><br><span class="line"><span class="comment">// 通过 typedef 还可以简写函数声明。如果没有 HANDLER，将需要很冗长的代码去表达这个意思</span></span><br><span class="line">HANDLER <span class="title function_">MyFunc</span><span class="params">(<span class="type">int</span>, HANDLER)</span>;</span><br><span class="line"><span class="comment">// 或者用在数组</span></span><br><span class="line">HANDLER MyArray[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/csyisong/archive/2009/01/09/1372363.html">关于 typedef 的用法总结</a></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typedef </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言变量内存对齐的作用与规则</title>
      <link href="/2018/07/03/031_C%20%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%A7%84%E5%88%99/"/>
      <url>/2018/07/03/031_C%20%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>现代计算机体系中 CPU 按照双字、字、字节访问存储内存，并通过总线进行传输，若未经过一定规则的数据对齐，CPU 的访址操作与总线的传输操作将会异常的复杂，所以现代编译器中都会对内存进行自动的对齐。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li><p>平台原因（移植原因）</p><p> 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。比如，有些架构的 CPU 在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。</p></li></ol><span id="more"></span><ol start="2"><li><p>性能原因</p><p> 经过内存对齐后，CPU 的内存访问速度大大提升。比如，有些平台每次读都是从偶地址开始，如果一个 int 型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这 32 位，而如果存放在奇地址开始的地方，就需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 32 位数据。显然，这在读取效率上下降很多。</p><p> 假设 CPU 要读取一个 int 型 4 字节大小的数据到寄存器中，分两种情况讨论（假定内存读取粒度为 4）：</p><p> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2y2bf.jpg" alt="CPU 读取内存示意图"></p><ul><li><p>从 0 字节开始：CPU 只需读取内存一次即可把这 4 字节的数据完全读取到寄存器中。</p></li><li><p>从 1 字节开始：此时该 int 型数据不是位于内存读取边界上，这就是一类内存未对齐的数据，需要读 2 次。</p></li></ul></li></ol><h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><h3 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h3><p>在默认情况下，编译器规定各成员<strong>变量存放</strong>的起始地址相对于<strong>结构</strong>的起始地址的 <code>偏移量</code> 必须为该<strong>变量的类型所占用的字节数</strong>的倍数。</p><table><thead><tr><th>类型</th><th>对齐倍数（偏移量相对于类型的字节大小）</th></tr></thead><tbody><tr><td>char</td><td>1 倍</td></tr><tr><td>short</td><td>2 倍</td></tr><tr><td>int</td><td>4 倍</td></tr><tr><td>float</td><td>4 倍</td></tr><tr><td>double</td><td>8 倍</td></tr></tbody></table><p>各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节 <code>编译器</code> 会自动填充。同时，编译器为了<strong>确保结构的大小为结构的字节边界数</strong>（即该结构中<strong>占用最大空间的类型</strong>所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> dda; <span class="comment">// 起始偏移量为0，刚好是double（8）的倍数，占用8个字节</span></span><br><span class="line">    <span class="type">char</span> cda;   <span class="comment">// 起始偏移量为8，是char的倍数（1），占用1个字节</span></span><br><span class="line">    <span class="type">int</span> ida;    <span class="comment">// 起始偏移量位9，不是int（4）的倍数，要补3个字节（全是0），所以占了 3 + 4 = 7</span></span><br><span class="line">    <span class="comment">// 此时占用空间为16，是double的倍数，不用再补</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct2</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> cda;    <span class="comment">// 占1字节</span></span><br><span class="line">    <span class="type">double</span> dda;  <span class="comment">// 偏移1，要补7，7+8=15，占了15字节</span></span><br><span class="line">    <span class="type">int</span> ida;     <span class="comment">// 偏移16，不用补，占了4字节，此时偏移了20，不是double的倍数，要补4</span></span><br><span class="line">    <span class="comment">// 所以总共24字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="对齐参数"><a href="#对齐参数" class="headerlink" title="对齐参数"></a>对齐参数</h3><p>默认的对齐方式为 8 字节。有时，我们自己可以设定变量的对齐方式，<code>#pragma pack(n)</code> 来设定变量以 n 字节对齐。n 字节对齐就是说变量存放的起始地址的偏移量有两种情况：</p><p><strong>默认对齐方式：</strong>按照变量的类型大小对齐。</p><ol><li><p>如果该变量的类型所占用的字节数<strong>小于等于 n</strong>，那么偏移量必须满足默认的对齐方式（必须为类型大小的整数倍）；</p></li><li><p>如果该变量的类型所占用的字节数<strong>大于 n</strong>，那么偏移量必须为 n 的倍数，不满足默认的对齐方式。</p></li></ol><p>此外，结构的总大小也有约束条件，分下面两种情况：</p><ol><li><p>如果所有成员变量类型所占用（所分配的空间）的字节数<strong>小于等于 n</strong>，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数（即默认对齐方式）；</p></li><li><p>否则，结构的总大小必须为 n 的倍数。</p></li></ol><p>或者，我们也可以这样表述（读者可以自行对比和理解，很重要！）：</p><ol><li><p>对于结构的各个成员，第一个成员位于偏移为 0 的位置，以后每个数据成员的偏移量必须是 <code>min(n, 这个数据成员的自身长度)</code> 的倍数；</p></li><li><p>结构（或联合）本身也要进行对齐，对齐将按照 <code>min(n, 结构（或联合）最大数据成员长度)</code> 进行对齐。</p></li></ol><p><strong>总结：</strong>类型大小小于等于 n，看类型大小；大于 n，看 n；n 是个阈值。</p><h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) <span class="comment">//保存对齐状态 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4) <span class="comment">//设定为4字节对齐 </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> m1; <span class="comment">// 1 &lt;= n, 1 byte</span></span><br><span class="line">　　 <span class="type">double</span> m4;  <span class="comment">// 8 &gt; n, 其偏移量为1，偏移量要为n = 4的倍数，所以补足3个字节（原来默认要补足7个字节），所以m4占 3+8 = 11，原来占了15字节</span></span><br><span class="line">    <span class="type">int</span> m3; <span class="comment">// 此时偏移量为12，4 &lt;= n，满足默认的，是4的倍数，所以分配4个字节。</span></span><br><span class="line">　　<span class="comment">// 此时分配了16字节，大于等于n，必须是n的倍数。</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) <span class="comment">//恢复对齐状态 </span></span></span><br></pre></td></tr></table></figure><p>以上结构的大小为 16，下面分析其存储情况：</p><ul><li><p>首先为 m1 分配空间，其偏移量为 0，满足我们自己设定的对齐方式（4 字节对齐），m1 占用 1个字节。</p></li><li><p>然后开始为 m4 分配空间，这时其偏移量为 1，由于 double 占用 8 个字节（大于 4），需要补足 3 个字节以满足 4 字节对齐，而 m4 本身占用 8 个字节，即分配了 11 个字节。（默认情况则需要 15 字节，节省了空间）</p></li><li><p>接着为 m3 分配空间，这时其偏移量为 12，m3 占用 4 个字节（小于等于 4），偏移量仅需满足 int 类型大小的倍数，因此不用填补。</p></li><li><p>最后，此时已经为所有成员变量分配了空间，共分配了 <code>4 + 8 + 4 = 16</code> 个字节。因为所有各个变量的类型大小并不满足小于等于 n（double 不满足），所以结构总大小必须满足为 n 的倍数，因此不用填补。</p></li></ul><p><strong>总结：</strong>调小对齐参数可以节省存储空间，如给 m4 分配空间时，节省了 4 个字节。</p><h4 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8) <span class="comment">// n = 8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">long</span> b; <span class="comment">// 偏1，补7，7 + 8 = 15</span></span><br><span class="line">    <span class="comment">// 1 + 15 = 16（64位）（32位是8）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">d</span>;</span> <span class="comment">// 偏1，占 16，大于 8，按照 8 对齐，补 7，7 + 16 = 23</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> e; <span class="comment">// 偏24，占 8，小于等于 8，按照本身 8 对齐，不用填补</span></span><br><span class="line">    <span class="comment">// 1 + 23 + 8 = 32，有成员的类型大小大于参数 8，因此结构体大小按照 8 对齐，不用填补。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>S1 中，成员 a 占 1 字节，默认按 8 字节对齐，指定对齐参数为8，偏移量为 0，不用填补字节；成员 b 占 4 个字节，默认是按 8 字节对齐，偏移量为 1，这时就按 8 字节对齐，需要填补 7 个字节，且本身占 8 个字节，所以 <code>sizeof(struct S1)</code> 应该为 16。（假定 long 为 8 字节，即在 64 位机器下）</p><p>S2 中，c 和 S1 中的 a 同理。而 d 是个结构体，它占 16 个字节，大于参数 8，按照参数 n 对齐，即 8 字节对齐，补 7 个字节，所以共分配了 23 个字节。接着，成员 e 占 8 个字节，小于等于 8，按照本身类型大小 8 字节对齐，不用填补。最后，S2 中有成员的类型大小大于参数 8，因此结构体大小按照 8 字节对齐。由于此时偏移量为 32，为 8 的倍数，因此无需再填补，所以 <code>sizeof(struct S2)</code> 应该为 32。</p><p><strong>注意：</strong>有的地方说 S2 中 S1 的对齐应该按照 S1 中最大的对齐参数进行对齐，即 8。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/49ddb946a226">内存对齐到底是怎么回事？</a></li><li><a href="http://www.cnblogs.com/wuyudong/p/memory-alignment.html">C 语言内存对齐详解</a></li><li><a href="http://www.cppblog.com/snailcong/archive/2009/03/16/76705.html">内存对齐的规则以及作用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 K&amp;R C、ANSI C、C89、C99 和 C11 的历史总结</title>
      <link href="/2018/06/29/030_%E5%85%B3%E4%BA%8E%20K&amp;R%20C%E3%80%81ANSI%20C%E3%80%81C89%E3%80%81C99%20%E5%92%8C%20C11%20%E7%9A%84%E5%8E%86%E5%8F%B2%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/29/030_%E5%85%B3%E4%BA%8E%20K&amp;R%20C%E3%80%81ANSI%20C%E3%80%81C89%E3%80%81C99%20%E5%92%8C%20C11%20%E7%9A%84%E5%8E%86%E5%8F%B2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="K-R-C"><a href="#K-R-C" class="headerlink" title="K&amp;R C"></a>K&amp;R C</h2><p>1978年，Dennis Ritchie 和 Brian Kernighan 合作推出了《The C Programming Language》的第一版（按照惯例，经典著作一定有简称，该著作简称为 K&amp;R），书末的参考指南（Reference Manual）一节给出了当时 C 语言的完整定义，成为那时 C 语言事实上的标准，人们称之为 K&amp;R C。从这一年以后，C 语言被移植到了各种机型上，并受到了广泛的支持，使 C 语言在当时的软件开发中几乎一统天下。</p> <span id="more"></span><h2 id="C89（ANSI-C）"><a href="#C89（ANSI-C）" class="headerlink" title="C89（ANSI C）"></a>C89（ANSI C）</h2><p>随着 C 语言在多个领域的推广、应用，一些新的特性不断被各种编译器实现并添加进来。于是，建立一个新的「无歧义、与具体平台无关的 C 语言定义」成为越来越重要的事情。1983 年，ASC X3（ANSI 属下专门负责信息技术标准化的机构，现已改名为 INCITS）成立了一个专门的技术委员会 J11（委员会编号，全称是 X3J11），负责起草关于 C 语言的标准草案。1989 年，草案被 ANSI 正式通过成为美国国家标准，被称为 C89 标准。</p><h2 id="C90（ISO-C）"><a href="#C90（ISO-C）" class="headerlink" title="C90（ISO C）"></a>C90（ISO C）</h2><p>随后，TCPL（The C Programming Language）的第二版开始出版发行，书中内容根据 ANSI C（C89）进行了更新。1990 年，在委员会的努力下，ISO 批准了 ANSI C 成为国际标准。于是 ISO C（又称为 C90）诞生了。除了标准文档在印刷编排上的某些细节不同外，<strong>ISO C（C90）和 ANSI C（C89）在技术上完全一样</strong>。</p><h2 id="C95"><a href="#C95" class="headerlink" title="C95"></a>C95</h2><p>之后，ISO 在 1994、1996 年分别出版了 C90 的技术勘误文档，更正了一些印刷错误，并在 1995 年通过了一份 C90 的技术补充，对 C90 进行了微小的扩充，经过扩充后的 ISO C 被称为 C95。 </p><h2 id="C99"><a href="#C99" class="headerlink" title="C99"></a>C99</h2><p>1999 年，ANSI 和 ISO 又通过了最新版本的 C 语言标准和技术勘误文档，该标准被称为 C99 。之后还有 2011年的 C11 等版本，了解一下就好了。</p><p>现在，各种 C 编译器都提供了 C89（C90）的完整支持，对 C99 还只提供了部分支持，还有一部分提供了对某些 K&amp;R C 风格的支持。  </p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/qr5ea.jpg" alt="C 语言的各种版本"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C11 </tag>
            
            <tag> 标准 </tag>
            
            <tag> ANSI C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言全局变量初始化和符号重名的问题</title>
      <link href="/2018/06/17/029_C%20%E8%AF%AD%E8%A8%80%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/17/029_C%20%E8%AF%AD%E8%A8%80%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>全局变量是 C 语言语法和语义中一个很重要的知识点，首先它存在的意义可以从三个不同角度去理解：</p><ul><li>对于程序员来说，它是一个记录内容的 <code>变量</code>（variable）。</li><li>对于编译&#x2F;链接器来说，它是一个需要解析的 <code>符号</code>（symbol）。</li><li>对于计算机来说，它可能是具有地址的一块 <code>内存</code>（memory）。</li></ul><p>跨单元访问和持续生存周期这两个特点使得全局变量往往成为一段受攻击代码的突破口，了解这一点十分重要。</p><span id="more"></span><h2 id="强弱符号学说"><a href="#强弱符号学说" class="headerlink" title="强弱符号学说"></a>强弱符号学说</h2><p>在 C 语言里，全局变量如果不初始化的话，默认为 0。<code>int x = 0</code> 跟 <code>int x</code> 的效果看起来是一样的。但其实这里面的差别很大，<strong>强烈建议大家所有的全局变量都要初始化</strong>，因为编译器在编译的时候针对这两种情况会产生两种符号放在目标文件（*.o）的符号表中，对于初始化的，叫 <code>强符号</code>；未初始化的，叫 <code>弱符号</code>。</p><p>链接器在链接目标文件的时候，如果遇到两个重名符号，会有以下处理规则：</p><ol><li>如果有多个重名的强符号，则报错（error）；</li><li>如果有一个强符号，多个弱符号，则以强符号为准；</li><li>如果没有强符号，但有多个重名的弱符号，则「任选一个弱符号」or「先决议到 size 最大的那个，如果同样大小，则按照链接顺序选择第一个」。（具体要看编译器）</li></ol><p>事实上，<strong>这种规则是 C 语言里的一个大坑</strong>，编译器对这种全局变量多重定义的「纵容」很可能会无故修改某个变量，导致程序产生不确定的行为。</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h2><p>基于以上规则看下面的程序：(gcc 3.4.6)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x1: %d\n&quot;</span>, x);</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x2: %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var.c</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为两个文件里面的 x 都被初始化了，所以编译出来的两个目标文件里 x 都是强符号，链接的时候会报错：<code>multiple definition of &#39;x&#39;</code>，符合规则 1。</p><p>把 var.c 里面的 <code>int x = 0;</code> 改成 <code>int x;</code>，编译、链接无任何警告，运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: 1</span><br><span class="line">x: 2</span><br></pre></td></tr></table></figure><p>说明链接的时候以 main.c 中的 x 为准，foo 函数修改的是 main.c 中定义的 x，符合规则 2。</p><p>把 main.c 中的初始化也去掉，改成 <code>int x;</code>，编译、链接仍然很顺利，运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: 0      （全局变量初始化为 0）</span><br><span class="line">x: 2</span><br></pre></td></tr></table></figure><p>说明 main 函数和 foo 函数修改的是同一个 x，链接器自己选择了一个 x，符合规则3。</p><p>然而，在大部分情况下，我们不希望链接器为我们做决定。也许写 var.c 的人根本不知道 main.c 里面也有一个 x，foo 函数的本意也许并不是要修改 main.c 中的 x。因为这种问题引起的 bug 会很难查。</p><p>所以，我们要尽量把全局变量初始化，对于不想给别的文件引用的变量，也尽量用 static 修饰。除了链接时的表现不一样外，未初始化的符号在目标文件的 bss 段中，而初始化的符号在 data 段中。</p><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h2><p>先看 <code>t.h</code>、<code>foo.c</code> 和 <code>main.c</code> 这三个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t.h */</span></span><br><span class="line"><span class="comment">// #ifndef _H_</span></span><br><span class="line"><span class="comment">// #define _H_</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;t.h&quot;</span>  <span class="comment">// 包含t.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="type">char</span> a; <span class="comment">// 1 byte</span></span><br><span class="line">   <span class="type">int</span> b;  <span class="comment">// 3 + 4 = 7 bytes</span></span><br><span class="line">&#125; b = &#123; <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo:\t(&amp;a)=0x%08x\n\t(&amp;b)=0x%08x\n</span></span><br><span class="line"><span class="string">        \tsizeof(b)=%d\n\tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n&quot;</span>,</span><br><span class="line">        &amp;a, &amp;b, <span class="keyword">sizeof</span> b, b.a, b.b, main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;t.h&quot;</span>    <span class="comment">// 再次包含t.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> b; <span class="comment">// 4 bytes</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main:\t(&amp;a)=0x%08x\n\t(&amp;b)=0x%08x\n</span></span><br><span class="line"><span class="string">        \t(&amp;c)=0x%08x\n\tsize(b)=%d\n\tb=%d\n\tc=%d\n&quot;</span>,</span><br><span class="line">        &amp;a, &amp;b, &amp;c, <span class="keyword">sizeof</span> b, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解答：</p><p>这个程序里我们定义了四个全局变量，t.h 头文件定义了一个整型 a 且未初始化，main.c 里定义了两个整型 b 和 c 并且未初始化，foo.c 里定义了一个已初始化的结构体 b，还定义了一个函数指针变量 main。两个源文件里变量 b 和函数指针变量 main 被重复定义了（实际上可以看做代码段的地址）。但编译器并<strong>未报错（符合规则二）</strong>，只给出一条警告：</p><pre><code>/usr/bin/ld: Warning: size of symbol &#39;b&#39; changed from 4 in main.o to 8 in foo.o</code></pre><p>运行程序发现，main.c 打印中 b 大小是 4 个字节，而 foo.c 是 8 个字节，<strong>因为 sizeof 关键字是编译时决议的，而且两个源文件中对 b 类型定义不一样</strong>。但令人惊奇的是无论是在 main.c 还是 foo.c 中，a 和 b 都具有<strong>相同的地址</strong>，也就是说，b 被定义了两次，b 还是不同类型，但内存映像中只有一份拷贝。我们还看到：main.c 中 b 的值居然就是 foo.c 中结构体第一个成员变量 b.a 的值，这证实了前面的推断，<strong>即便存在多次定义（类型还可以不同），内存中只有一份初始化的拷贝。另外，在这里 c 是置身事外的一个独立变量</strong>。</p><pre><code>根据强弱符号学说，全局变量 a 和 b 存在重复定义。如果我们将 main.c 中的 b 初始化赋值，那么就存在两个强符号而违反了规则一，编译器报错。如果满足规则二，则仅仅提出警告，实际运行时决议的是 foo.c 中的强符号。而变量 a 都是弱符号，所以只选择一个，且由于类型大小相同，因按照目标文件链接时的顺序（这里假定没有`#ifndef _H_`，不然不会发生重复定义）。</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coolshell.cn/articles/10115.html">C 语言全局变量那些事儿</a></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全局变量 </tag>
            
            <tag> 符号 </tag>
            
            <tag> 冲突 </tag>
            
            <tag> 初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 C 语言编译流程 PCAL 的总结</title>
      <link href="/2018/06/10/028_%E5%85%B3%E4%BA%8E%20C%20%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%20PCAL%20%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/10/028_%E5%85%B3%E4%BA%8E%20C%20%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%20PCAL%20%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC-编译器"><a href="#GCC-编译器" class="headerlink" title="GCC 编译器"></a>GCC 编译器</h2><p>参考：<a href="https://blog.csdn.net/liqinghua1653/article/details/3901661">GCC 编译器介绍（转）</a></p><p>GCC 是 GNU 项目的编译器组件之一，也是 GNU 最具有代表性的作品。在 GCC 设计之初仅仅作为一个 C 语言的编译器，可是经过十多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada、C++、Java、Objective-C、Pascal、COBOL，以及支持函数式编程和逻辑编程的 Mercury，等等。而 GCC 也不再单是 GNU C Compiler 的意思，而是 GNU  Compiler Collection 也即是 GNU 编译器家族的意思了，目前已经成为 Linux 下最重要的编译工具之一。</p><span id="more"></span><p>用 GCC 编译程序生成可执行文件看起来似乎只通过编译一步就完成了，但事实上，使用 GCC 编译工具由 C 语言源程序生成可执行文件的过程并不单单是一个编译的过程，而要经过下面的四个过程，可总结为 <strong>PCAL</strong>：</p><ul><li>预处理（Pre-Processing）<code>cpp</code>：<code>.c/.cpp</code> → <code>.i</code> 预处理后</li><li>编译（Compiling）<code>cc</code>：→ <code>.s</code> 汇编代码</li><li>汇编（Assembling）<code>as</code>：→ <code>.o</code> 机器代码</li><li>链接（Linking）<code>ld</code>：→ <code>a.out</code> 可执行文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">as hello.s -o hello.o 或 gcc -c hello.s -o hello.o</span><br><span class="line">ld hello.o world.o -e main -o helloworld</span><br></pre></td></tr></table></figure><p>在实际编译的时候，GCC 首先调用 <code>cpp</code> 命令进行预处理，主要实现对源代码编译前的预处理，比如将源代码中指定的头文件包含进来。接着调用 <code>cc</code> 命令进行编译，作为整个编译过程的一个中间步骤，该过程会将源代码翻译生成汇编代码。汇编过程是针对汇编语言的步骤，调用 <code>as</code> 命令进行工作，生成扩展名为 <code>.o</code> 的目标文件。当所有的目标文件都生成之后，GCC 就调用连接器 <code>ld</code> 来完成最后的关键性工作 —— 链接。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8k8vg.jpg" alt="GCC 编译流程图"></p><h3 id="常用的编译选项"><a href="#常用的编译选项" class="headerlink" title="常用的编译选项"></a>常用的编译选项</h3><ul><li><code>-c</code>：这是 gcc 命令的常用选项。<code>-c</code> 选项告诉 GCC 仅把源程序编译为目标代码而不做链接工作，所以采用该选项的编译指令不会生成最终的可执行程序，而是生成一个与源程序文件名相同的以 <code>.o</code> 为后缀的目标文件。例如一个 <code>Test.c</code> 的源程序经过下面的编译之后会生成一个 <code>Test.o</code> 文件。</li><li><code>-S</code>：使用该选项会生成一个后缀名为 <code>.s</code> 的汇编语言文件，但是同样不会生成可执行程序。</li><li><code>-e</code>：该选项只对文件进行预处理，预处理的输出结果被送到标准输出（比如显示器）。</li><li><code>-v</code>：在 Shell 的提示符号下键入 <code>gcc -v</code>，屏幕上就会显示出目前正在使用的 gcc 版本的信息。</li><li><code>-x language</code>：强制编译器指定的语言编译器来编译某个源程序。</li><li><code>-O</code>和<code>-O2</code>：编译优化。</li><li><code>-o</code>：生成的名字。</li><li><code>-l&lt;DIR&gt;</code>：库依赖选项，指定库及头文件路径。在 Linux 下开发程序的时候，通常来讲都需要借助一个或多个函数库的支持才能够完成相应的功能。一般情况下，Linux 下的大多数函数都将头文件放到系统 &#x2F;usr&#x2F;include 目录下，而库文件则放到 &#x2F;usr&#x2F;lib 目录下。</li></ul><h3 id="常见的文件后缀"><a href="#常见的文件后缀" class="headerlink" title="常见的文件后缀"></a>常见的文件后缀</h3><ul><li><code>.cc</code>：C++ 源程序</li><li><code>.cxx</code>：C++ 源程序</li><li><code>.m</code>：Objective-C 源程序</li><li><code>.i</code>：预处理后的 C 文件</li><li><code>.ii</code>：预处理后的 C++ 文件</li><li><code>.s</code>：汇编语言源程序</li><li><code>.S</code>：汇编语言源程序</li><li><code>.h</code>：头文件，通常不出现在命令行上</li></ul><h2 id="详解-PCAL"><a href="#详解-PCAL" class="headerlink" title="详解 PCAL"></a>详解 PCAL</h2><p>参考：<a href="https://blog.csdn.net/u013230511/article/details/77171165">编译学习笔记系列</a></p><h3 id="预处理-Pre-Processing"><a href="#预处理-Pre-Processing" class="headerlink" title="预处理 Pre-Processing"></a>预处理 Pre-Processing</h3><p>略</p><h3 id="编译-Compiling"><a href="#编译-Compiling" class="headerlink" title="编译 Compiling"></a>编译 Compiling</h3><p>整个编译过程分成 <code>编译前端</code> 与 <code>编译后端</code>，前端负责生产<strong>与机器无关的中间代码</strong>，后端负责生成<strong>与机器有关的目标代码</strong>。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bw9rt.jpg" alt="编译前端和编译后端"></p><ul><li><p>词法分析（Lexical）</p><p>  源代码是由一个一个的字符组成，编译的第一步是将其中的字符序列使用扫描器（Scanner）分割成一系列单词或符号，在编译器中称为记号（Token）。 </p><p>  词法分析产生的记号一般可以分成「关键字」，「标识符」，「字面量（数字，字符串等）」，「特殊符号（+，-，&#x3D;）」。 </p><p>  在计算机语言中，我们说的语法的不同，在编译系统中最直接的便是词法分析的方法不同导致的。</p></li><li><p>语法分析（Grammar，如 LR、LL 分析）</p><p>  从词法分析过程中得到的 Token 序列，仅仅是简单的单词序列，并不能表达意义。语法分析这一过程，通过语法分析器（Grammar Parser）采用上下文无关语法分析手段，产生语法树。这个树是以表达式为节点的树。</p></li><li><p>语义分析（Semantic）</p><p>  从语法分析过程中得到的语法树，仅仅是完成了语法层面的分析，无法了解这个语句是否真正有意义，是否合法。语义分析过程便是<strong>对表达式中的变量与类型进行判断，分析其是否语义不匹配（编译完成后变量名不存在，只有相应的地址信息）。</strong></p></li><li><p>中间代码（语言）生成（Intermediate Representation）</p><blockquote><p>中间语言介于源语言和目标语言之间。常用的中间语言有逆波兰表示、三元式、四元式和树表示等。</p></blockquote><p>  将语义分析的步骤中得到的标识后的语法树（Commended Syntax Tree）通过源码级优化器（Source Code Optimizer）做优化，生成中间代码。</p></li><li><p>目标代码生成与优化</p><p>  从上步骤中拿到的中间代码是与机器无关的，通过此步骤中代码生成器（Code Generator）生成与机器相关的目标代码（即汇编代码）。</p></li></ul><p><strong>注意：</strong>这里所涉及的是上面 <code>PCAL</code> 中的 <code>Compiling</code> 一步而已，后面还需要对目标代码（汇编代码）进行汇编（机器代码）并链接（可执行文件）。</p><h3 id="汇编-Assembling"><a href="#汇编-Assembling" class="headerlink" title="汇编 Assembling"></a>汇编 Assembling</h3><p><strong>待整理！</strong></p><p>汇编由下面 3 类指令组成：</p><ol><li>汇编指令：如 mov、add 等，有着对应的机器码。</li><li>伪指令：没有对应的机器码，由编译器执行，计算机不执行。</li><li>其他符号：如 +、-、*、&#x2F; 等由编译器识别，没有对应的机器码。</li></ol><p>机器码中，指令和数据，存在存储器中没有区别。CPU 可以把它看作指令 <code>mov AX, BX</code>，也可以看作数据 <code>89D8H</code>。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>运算器：进行信息的处理</li><li>存储器（寄存器）：进行信息存储</li><li>控制器：控制各个器件进行各种操作</li></ul><p>对于汇编程序来说，CPU 中主要的部件是寄存器。如 8086 CPU 有 14 个寄存器：</p><p>AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW</p><p>其中：</p><ul><li><p>AX、BX、CX、DX：用来存放一般数据，大小是 16 位即 2 个字节</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/3l3eu.jpg" alt="寄存器大小示意图"></p><p>  8086 CPU 为了兼容上一代的 8 位 CPU，AX、BX、CX、DX 都可以分成两个独立的寄存器。如，AX 可分为 AH （AX 的高 8 位）和 AL（AX 的低 8 位）。</p></li><li><p>CS：代码段地址寄存器</p></li><li><p>DS：数据段寄存器（除了 CS、DS，还有 2 个段寄存器 SS、ES）</p></li><li><p>IP：指令指针寄存器，存放偏移地址</p></li></ul><p>80386 的指针寄存器有基址寄存器 EBP，堆栈指针寄存器 ESP 和指令指针寄存器 EIP。只需要了解基址寄存器 EBP 和堆栈指针寄存器 ESP 即可。指令指针寄存器 EIP 总是指向下一条要执行的指令的地址，一般情况下无需修改 EIP。</p><p>EBP 称为基址寄存器，可作为通用寄存器用于存放操作数，常用来代替堆栈指针访问堆栈中的数据。</p><p>ESP 称为堆栈指针寄存器，不可作为通用寄存器使用，ESP 存放当前堆栈栈顶的地址，一般情况下，ESP 和 EBP 联合使用来访问函数中的参数和局部变量。</p><h4 id="堆、栈及栈帧的组成"><a href="#堆、栈及栈帧的组成" class="headerlink" title="堆、栈及栈帧的组成"></a>堆、栈及栈帧的组成</h4><p>参考：<a href="https://blog.csdn.net/an_tang/article/details/70224374">程序的堆和栈及栈帧的组成</a></p><p><code>栈帧</code> 表示程序的函数调用记录，而栈帧又是记录在栈上面，很明显栈上保持了 N 个栈帧的实体，那就可以说栈帧将栈分割成了 N 个记录块，但是这些记录块<strong>大小不固定</strong>，因为栈帧不仅保存诸如：<strong>函数入参、出参、返回地址和上一个栈帧的栈底指针等信息，还保存了函数内部的自动变量（甚至可以是动态分配内存）</strong>。因此，不是所有的栈帧的大小都相同。</p><blockquote><p>栈帧相对于某个函数而言，就是该函数在栈中所占去的空间。</p></blockquote><p>要深入理解函数及其和指针的结合应用，需要理解 <code>程序栈</code>。大部分的现代的块结构语言，比如 C 语言都用到了程序栈来支持函数执行。调用函数时，会创建函数的栈帧并将其推到程序栈上。函数返回时，其栈帧从程序栈上弹出。</p><p>程序栈存放栈帧（stack frame）。栈帧有时候也称为 <code>活跃记录</code>（activation record）或 <code>活跃帧</code>（activation frame）。</p><h3 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接 Linking"></a>链接 Linking</h3><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_uninit_val;</span><br><span class="line"><span class="type">int</span> global_init_val = <span class="number">123</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_val <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器最后一步是将不同的目标文件结合到一起。<strong>在链接中，目标文件之间的相互拼合实际上是目标文件对地址的引用</strong>，具体到 C 语言，是 <code>函数和变量</code> 的引用。比如上面 hello.c 例子中，hello.c 中的 main 函数引用到了 stdio.h 中的 printf 函数。在 hello.c 生成目标文件时，调用 printf 的跳转<strong>暂时是无法知道具体的地址</strong>。在编译器将所有目标文件链接成执行文件时，<strong>将跳转 printf 的地址替换成真正 printf 实际地址。</strong></p><p>在链接中，我们将函数和变量统一称为 <code>符号</code>（Symbol），函数名或者变量名就是符号。</p><p>正因为链接时符号作为各个目标文件的的链接的主要的依据，因此管理好目标文件的符号非常重要。在可执行文件中将符号统一交由 <code>符号表</code>（Symbol Table）进行管理。</p><p>在编译后，C 会将符号保存至符号表中，且符号是用于链接同一个函数或变量的唯一标志，也就是说相同的一个程序中不可以拥有两个相同函数的实现。 </p><p>但这种方式导致了另外一个问题，一旦 C 程序变得庞大，函数或者全局变量的命名重名变得难以避免。当引用到其他的库时，需要时刻小心函数命名以防出现函数重名便需要非常的小心。这是C函数的一个历史包袱，为避免这种情况，一般的 C 函数库都加上特定的前缀进行区分。</p><p>但这种原始简单的区分方式只能暂时避免符号重名的情况，并不能根本的解决这问题。为解决这个问题，目前大部分新出的语言都提出了称为 <code>命名空间</code> 的方式用以解决这个问题，同样作为 C 语言的升级版 C++ 也通过支持命名空间（namespace）的方式解决符号冲突的问题。</p><p>我们知道 C++ 语言支持函数重载，也支持两个不同类中可以声明相同函数名的函数。这其实是通过符号修饰（name decoration）或称符号改编（name mangling）来实现的。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/9k027.jpg" alt="符号修饰"></p><p>这种通过添加符号将函数、变量的符号进行修饰的过程称为 <code>函数签名</code>。函数签名包含：函数名、函数命名空间、类名、参数类型。</p><p><strong>符号重名请看：</strong><a href="https://junhaow.com/2018/06/17/C%20%E8%AF%AD%E8%A8%80%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/">C 语言全局变量初始化和符号重名的问题</a></p><blockquote><p>函数的签名是指函数原型中<strong>除去返回值的部分</strong>，包括函数名、形参表和关键字 const（如果使用了的话）的信息。</p></blockquote><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>参考：<a href="https://blog.csdn.net/u013230511/article/details/77512799">编译、链接学习笔记（三）静态链接</a></p><p><strong>将多个目标文件链接成一个可执行文件</strong>的过程称为 <code>静态链接</code>。</p><h5 id="静态链接的两个步骤"><a href="#静态链接的两个步骤" class="headerlink" title="静态链接的两个步骤"></a>静态链接的两个步骤</h5><ol><li><p>文件混合<br> 合并各个目标文件中相同的段，并且将所有目标文件的符号表中的符号统一放置到 <code>全局的符号表</code> 中。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/r7gyb.jpg" alt="符号表合并"></p></li><li><p>符号解析与重定位<br> 读取段中的数据，重定位信息，调整代码中变量和函数的地址，将外部符号的引用地址使用伪地址进行填充。</p></li></ol><h4 id="进程装载"><a href="#进程装载" class="headerlink" title="进程装载"></a>进程装载</h4><p>参考：<a href="https://blog.csdn.net/u013230511/article/details/78010034">编译、链接学习笔记（四）进程装载</a></p><h5 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h5><p>程序是指计算机可执行文件在磁盘中的保存方式，他是一对预编译好的指令和数据的集合文件。而进程是计算机将程序按照一定规则运行的过程。两者相比<strong>程序是一个静态的概念，进程是一个动态的概念</strong>。</p><h5 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h5><p>每个进程运行起来后，操作系统为其分配了进程独立拥有的 <code>虚拟地址空间</code>（Virtual Address Space）。这空间的大小是由计算机操作系统以及 CPU 的位数共同决定。CPU 的物理属性决定了空间的最大值，除此之外，操作系统也会决定其访问空间的权限等。</p><p>在操作系统来看，我们知道一个计算机的物理内存其实是有限的，而且操作系统层面上看还要支持多个进程的并发运行。操作系统并不会真的分配实际大小的内存空间，只是给进程一个<strong>假象</strong>，让进程看起来拥有非常大空间，实际情况是操作系统通过分配时间片运行进程并不断切换，让进程「看起来」拥有一段连续且非常大的内存空间。</p><p>如果从 C 程序的角度而言，最简单的可从指针的位数来看地址的空间大小。在 32 位机器下，指针的长度也为 4 个字节；在 64 位机器下，指针长度为 8 个字节。</p><p>进程虚拟地址空间都是在操作系统的操作之下，<strong>并非所有的地址空间都可以访问</strong>，只能使用由操作系统分配的地址。如访问非操作系统分配的内存空间，操作系统将会强制结束进程。Windows 下会遇到「进行因非法操作需要关闭」，Linux 下出现「Segmentation Fault」，Mac OS 下会发生「EXE_BAD_ACCESS」。</p><h5 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h5><p>一个程序的执行一般伴随这个进程的建立。进程的建立包含如下三步：</p><ol><li><p>创建独立的虚拟内存空间。</p><p> 操作系统为进程创建独立的虚拟内存空间，实际的操作是为进程分配一个页目录（Page Directory），以及为创建映射函数所需要的数据结构。</p></li><li><p>读取可执行文件头，建立虚拟空间与可执行文件的映射关系。</p><p> 当程序运行时，一旦发生缺页，则需要依赖一套映射规则，将可执行文件的页映射到虚拟内存。此步骤则是建立虚拟内存和可执行文件的映射规则。<br> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/a4cem.jpg" alt="发生缺页"></p></li><li><p>指令寄存器指向可执行文件的入口，进程开始执行。</p><p> 操作系统通过将指令寄存器指向可执行文件的入口，将控制器交由进程。</p></li></ol><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>参考：<a href="https://blog.csdn.net/u013230511/article/details/78046286">编译、链接学习笔记（五）动态链接</a>、<a href="http://wiki.mbalib.com/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a></p><p>动态链接是指编译系统在链接阶段并不把目标文件和函数库文件链接在一起，而是等到程序在运行过程中需要使用时才链接函数库。</p><h5 id="动态链接的优点"><a href="#动态链接的优点" class="headerlink" title="动态链接的优点"></a>动态链接的优点</h5><ul><li><p>共享：多个进程可以共用一个 DLL（动态链接库，Dynamic Linking Library），比较节省内存，从而可以减少文件的交换。</p></li><li><p>部分装入：一个进程可以将多种操作分散在不同的 DLL 中实现，而只将当前操作的 DLL 装入内存。</p></li><li><p>便于局部代码修改：即便于代码升级和代码重用；只要函数的接口参数（输入和输出）不变，则修改函数及其 DLL 时，无需对可执行文件重新编译或链接。</p></li><li><p>便于适应运行环境：调用不同的 DLL，就可以适应多种使用环境并提供不同的功能。例如：不同的显示卡只需厂商为其提供特定的DLL，而操作系统和应用程序则不必修改。</p></li></ul><h5 id="动态链接的缺点"><a href="#动态链接的缺点" class="headerlink" title="动态链接的缺点"></a>动态链接的缺点</h5><ul><li><p>增加了程序执行时的链接开销。</p></li><li><p>程序由多个文件组成，因此增加了管理复杂度。</p></li></ul><h5 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h5><p>链接分为两种，一种是静态链接，另一种是动态链接。动态链接发生在程序运行时，其函数代码不出现在程序的可执行文件中；而静态链接发生在编译时，静态链接的函数代码实际被插入到程序的可执行文件中。</p><p>用于静态链接的函数通常保存在 OBJ 和 IJB 文件中。例如，编写一个由一些独立的编译单元（文件）组成的大型程序时，链接器在创建可执行文件时将每个模块 OBJ 文件结合起来，此时可执行文件将包含OBJ文件中的所有代码。</p><p>使用动态链接时，用于动态链接的函数代码保存在与程序的其他部分相独立的 DEF 文件中。用户的程序要包含链接 DLL 函数加载指令的少量代码，但并不将函数本身包括进来。<br>　　<br>函数的可执行代码位于一个 DLL 中，该 DLL 包含一个或多个<strong>已被编译、链接</strong>并与使用它们的进程分开存储的函数。<br>　　<br>目前主流的操作系统中，对于动态链接文件有不同的命名与扩展名：</p><ol><li>Linux：动态链接文件称为 <code>动态共享对象</code>（DSO，Dynamic Shared Object），以 <code>.so</code> 为扩展名。</li><li>Windows：动态链接文件称为 <code>动态链接库</code>（DLL，Dynamic Linking Library），以 <code>.dll</code> 为扩展名。 </li><li>Mac OS：动态链接文件也称为 <code>动态链接库</code>（DLL，Dynamic Linking Library），以 <code>.dylib</code> 为扩展名。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>已在文中各标题下。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> 编译 </tag>
            
            <tag> 链接 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 目标文件 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中变量的四种存储类型</title>
      <link href="/2018/05/30/027_C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/30/027_C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><blockquote><p>The auto and register specifiers give the declared objects automatic storage class, and may be used <strong>only within functions</strong>. Such declarations also serve as definitions and cause storage to be reserved.</p></blockquote><p>也就是说动态分配和释放存储空间。当我们定义一个变量时，不给它初始值，它的值是不确定的。</p><p>我们之前编写程序的时候很少显式用到 auto 定义变量。<strong>如果定义的变量前面没有加static，编译系统会默认为是 auto 的存储方式</strong>，会把变量存放在动态存储区。</p><span id="more"></span><p>auto 修饰符的定义里有这么一句「进入包含变量声明的代码时，变量开始存在。当程序离开这个代码块时，变量<strong>自动</strong>消失。它所占用的内存可被用来做别的事情」。auto 修饰的变量是存储在堆栈中的，而全局变量存储在静态存储区中，所以我们不能用 auto 修饰全局变量。</p><p>auto 存储类型说明的变量都是<strong>局部于</strong>某个程序范围内的，只能在某个程序范围内使用，通常在函数体内或函数中的复合语句里。</p><p>如，有下述定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> k ;        <span class="comment">// 说明一个 auto 整型的 k 变量</span></span><br><span class="line"><span class="type">int</span> K ;             <span class="comment">// 省略了 auto，说明一个 auto 整型的 K 变量</span></span><br></pre></td></tr></table></figure><p>这两种定义方式是相同的，省略 auto 关键字也是我们常用的方式。</p><p><strong>注意：</strong>auto 只能用在函数体内，而不能用在全局变量中。</p><p>在 C 语言中使用 auto 定义的变量<strong>可以不予初始化</strong>，<strong>但在 C++ 中必须初始化</strong>。</p><p>此外，下面这种形式也是对的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val;   <span class="comment">// 当省略数据类型，只使用 auto 修饰变量，在 C 语言中默认变量为 int 型（函数参数类型，返回值类型等等很多默认也是 int）</span></span><br></pre></td></tr></table></figure><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>register 称为寄存器型，<strong>使用 register 关键词修饰变量的主要目的是想将所说明的变量放入寄存器存储空间中，我们知道寄存器数量有限，且位于 CPU 的内部，这样可以加快程序的运行速度。</strong>但正因为寄存器的资源相对较少，所以编译器会判断程序所指定的需要放在寄存器中的内容有没有必要放入寄存器中去，也就是说，编译器来决定是否将指定内容放入到寄存器中。如果没有必要放入寄存器中，就使用 auto 类型作处理。综上所述，register 是一个<strong>建议性</strong>关键字，编译器可以判断出是否去执行这样一个关键字，所以这个关键字在目前的用处不大。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> i，sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    sum += i;</span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>这个修饰符和 auto 相对，我们不能同时用<code>auto static int a = 10</code>。</p><p>static：称为静态存储类型，<strong>在 C 语言中，既可以在函数体内，也可在函数体外说明 static 存储类型的变量。</strong></p><p>在函数体内说明的 static 存储类型的变量也是一种局部变量，<strong>与 auto 最大不同点是：static 存储类型的变量在内存中是以固定地址存放的，而不是以堆栈方式存放的。</strong>只要整个程序还在继续运行，静态变量就不会随着程序段的结束而消失；static 修饰的变量只被初始化一次，且变量的值有继承性。</p><p>static 的作用有三条：</p><ul><li>第一个作用：<strong>隐藏</strong>，其他文件不可见</li><li>第二个作用：保持变量内容的<strong>持久</strong></li><li>第三个作用：默认<strong>初始化</strong>为 0</li></ul><p><strong>因此，static 的作用要区分全局（隐藏）和局部（保持持久）两种情况。</strong></p><h3 id="为什么是-0？"><a href="#为什么是-0？" class="headerlink" title="为什么是 0？"></a>为什么是 0？</h3><p>可参考：<a href="https://www.zhihu.com/question/49111720">为什么在C语言中静态变量的初值是 0</a></p><blockquote><ol><li>不同的内存区域在程序运行时特性是不同，大致分为静态空间、栈空间、堆空间。静态空间其实是跟着程序映像一起加载到内存里的，提前就写在映像里了。无论如何都会有个初始值，反正写啥都是写，不如写 0；而栈空间和堆空间是映像加载完之后系统分配的，为了提高效率系统不会主动替你清零，C 也不会，所以未初始化的变量是内存里原有的值。简单来说，原因是效率。全局和静态变量是在编译期就确定了地址和值，并不消耗运行时的时间。局部变量是在每次函数调用时在栈上产生，你可以自行选择是否初始化。</li></ol></blockquote><blockquote><ol start="2"><li>很简单的问题，编译时没有赋值的全局变量会放在 bss 段。编译以后，bss 段是用来占位并且没有意义的。只有当程序加载运行时，虚拟存储器给 bss 段分配空间，在这段空间里请求二进制 0，程序加载时会对整个 bss 段进行清 0 操作，所以 C 语言没有赋值的全局变量是 0。</li></ol></blockquote><p>我觉得 2 比较靠谱，1 没有说到点子上。</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern 称为外部参照引用型，使用 extern 修饰的变量是想引用在<strong>其它文件中或在函数体外部</strong>已经声明的变量。</p><p>如下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span> , a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序可以成功运行，输出 a 的值为 1，而如果改变一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span> , a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样在进行编译时，编译器会报错，提示变量 a 没有被定义，也就是说<strong>全局变量的作用范围是从定义处开始直至程序结束</strong>。现在，我们在该程序的基础上加上一句声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">// 注意不加类型 int 会出 warning</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在编译时，即使后面没有 a 的定义，也不会报错，链接时才报错。</p><p>在这里要注意 extern 关键字对于变量的类型说明可以省略，但对于变量的类型及值是<strong>没有任何改变权限的</strong>，也就是说在上面例子中的 extern 如果写成 extern float a; 或者是 extern int a &#x3D; 3; 编译时会提示错误。</p><p><strong>extern 扩大了外部变量的作用范围。</strong></p><p>我们知道头文件只要是存放函数和变量声明的，所以用 extern 声明的变量也尽量写在头文件中，如果写在 <code>.cpp</code> 或者 <code>.c</code> 文件中容易埋下苦果。</p><h3 id="如何在两个文件中访问同一个全局变量"><a href="#如何在两个文件中访问同一个全局变量" class="headerlink" title="如何在两个文件中访问同一个全局变量"></a>如何在两个文件中访问同一个全局变量</h3><p>方法一：不使用头文件</p><ol><li><code>a.c</code> 中 <code>int foo;</code></li><li><code>b.c</code> 中 <code>extern int foo;</code></li></ol><p>方法二：使用头文件（推荐，即不在 <code>.c</code> 或 <code>.cpp</code> 文件中使用 extern）</p><ol><li><code>a.h</code> 中 <code>extern int foo;</code>（注意如果不加 extern 可能会重复定义，发生冲突）</li><li><code>a.c</code> 中定义 <code>int foo;</code> 不必添加 <code>#include &quot;a.h&quot;</code></li><li><code>b.c</code> 中没有定义（也不能重复定义吧），需要添加 <code>#include &quot;a.h&quot;</code>（推荐）或者在代码中添加 <code>extern int foo;</code>（不推荐）</li></ol><h2 id="全局变量与静态全局变量"><a href="#全局变量与静态全局变量" class="headerlink" title="全局变量与静态全局变量"></a>全局变量与静态全局变量</h2><p>全局与局部对应。与静态 static 相对的是动态 auto 变量，如函数体内用 auto 修饰的变量，动态的意思体现在函数对变量内存空间的分配和释放上，是在函数调用和结束的时候进行的。</p><p>全局变量是不用 static 修饰的全局变量。<strong>我这里也很懵逼！在 C 语言中，全局变量本身是静态存储的，为什么还叫静态全局变量？我觉得叫 static 全局变量比较好。</strong></p><p>静态全局变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。</p><p>当程序由一个源文件构成时，全局变量与静态全局变量没有区别；当程序由多个源文件构成时，全局变量与静态静态变量不同。</p><p>静态全局变量的作用：</p><ol><li>不必担心其它源文件使用相同变量名，彼此相互独立；</li><li>在某源文件中定义的静态全局变量不能被其他源文件使用或修改；</li><li>只能在本文件中使用。具有内部链接的静态性，不允许在其他文件里调用。</li></ol><p>总的来说，把局部变量改变为静态变量后是改变了它的存储方式和生存期，而把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此 static 这个说明符在不同的地方所起的作用是不同的。为什么当初不设计成 file 关键字呢？表示该变量的作用域是文件。</p><p>Tips：</p><p><strong>（下面这几句话值得记住）</strong></p><ol><li><p>若全局变量仅在<strong>单个 C 文件</strong>中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；</p></li><li><p>若全局变量仅由<strong>单个函数</strong>访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；</p></li><li><p>如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用 static 变量（这样的函数被称为：带「内部存储器」功能的的函数）；</p></li><li><p>函数中必须要使用 static 变量的情况：当某函数的<strong>返回值为指针类型</strong>时，则必须是 static 的局部变量的地址作为返回值；若为 auto 类型，则返回为错误的指针（返回是值复制）。举个例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">foo1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;a; <span class="comment">// a 是局部变量，返回了 a 变量的地址</span></span><br><span class="line">    <span class="keyword">return</span> p1;    <span class="comment">// 所以外部再次访问的时候是随机值，但没 warning</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">foo2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="string">&quot;hahah&quot;</span>;  <span class="comment">// 字符存储在常量区，这种情况不需要 static</span></span><br><span class="line">    <span class="keyword">return</span> p2;    <span class="comment">// 打印 hahah</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">foo3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> p3[] = <span class="string">&quot;hahahhahah&quot;</span>;  <span class="comment">// 字符存储在栈，并非常量</span></span><br><span class="line">    <span class="keyword">return</span> p3;    <span class="comment">// 产生 warning，说返回了栈地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = foo1();</span><br><span class="line">    <span class="type">char</span> *pp = foo2();</span><br><span class="line">    <span class="type">char</span> *ppp = foo3();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ppp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.c:56:12: warning: address of stack memory associated with local variable &#x27;p3&#x27; returned [-Wreturn-stack-address]</span><br><span class="line">    return p3;</span><br><span class="line">           ^~</span><br><span class="line">1 warning generated.</span><br><span class="line">-2027492106</span><br><span class="line">hahah</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考的链接已在对应的标题下，大部分链接忘了记录，以后要记下来。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auto </tag>
            
            <tag> static </tag>
            
            <tag> register </tag>
            
            <tag> extern </tag>
            
            <tag> 全局变量 </tag>
            
            <tag> 静态变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 程序存储和运行时的几个区域</title>
      <link href="/2018/05/21/026_C%20%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8C%BA%E5%9F%9F/"/>
      <url>/2018/05/21/026_C%20%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="C-语言中有四个存储区"><a href="#C-语言中有四个存储区" class="headerlink" title="C 语言中有四个存储区"></a>C 语言中有四个存储区</h2><ul><li>栈区</li><li>堆区</li><li>数据区<ul><li>全局区（静态区）</li><li>常量区（字面量区）</li></ul></li><li>代码区</li></ul><p>我在网上找到了很多不同的版本，各有各的说法。最后，我觉得研究这个意义不大，因为不同的编译器有着不同的行为。但是，我们可以看到一些共通的地方。</p><span id="more"></span><ol><li><p>栈区（stack）：由<strong>编译器</strong>自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<strong>const 修饰的局部变量也是放在栈里的，而不是放在常量区！</strong></p></li><li><p>堆区（heap）：一般由<strong>程序员</strong>分配释放，若程序员不释放，程序结束时可能由系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p></li><li><p>数据区：包括 <code>静态全局区</code> 和<code> 常量区</code>，<strong>因此其实可以分为五区</strong>，如果要站在汇编角度细分的话还可以分为很多小的区。</p><ul><li><p>全局区（静态区，static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（bss 段，Block Started by Symbol）。程序结束后由系统释放。</p></li><li><p>常量区（注意是 <code>字面量 literal</code> 的意思，而不是 const 的意思）：常量字符串就是放在这里的，只有可读属性，比如 <code>char *s = &quot;hello world&quot;</code>，这时候 <code>&quot;hello world&quot;</code> 就在常量区。由于没有可写属性，所以修改内容会出错。<strong>另外，全局的 const 变量也放在常量区里</strong>，这和 C++ 程序设计语言里对 const 变量存放位置是不符合的，因为存储器各有各的差异。程序结束后由系统释放。【最后有代码示例】</p></li></ul><p> 其实可以把 <code>堆栈区</code> 统称为 <code>动态区</code>；<code>全局区</code> 也可以称为 <code>静态区</code>，或者统称为 <code>全局静态区</code>。</p></li><li><p>代码区：存放函数体的二进制代码。</p></li></ol><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/fcem1.jpg" alt="存储时&amp;运行时的几个区域"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/h6n6z.jpg" alt="栈和堆的「生长」方式"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/4qbf2.jpg" alt="堆和栈"></p><h2 id="再谈-bss-段"><a href="#再谈-bss-段" class="headerlink" title="再谈 bss 段"></a>再谈 bss 段</h2><p>bss 是（Block Started by Symbol）的缩写，是专门用来存储<strong>未初始化的全局变量和未初始化的静态变量</strong>的一块内存区域。有人便会有疑问，既然有专门存放数据的数据段（data），那么 bss 段的存在意义是什么？</p><p>这是因为未初始化的全局或静态变量因加载程序时未知其实际的值，程序其实不必为其分配内存空间。而且，bss 段可被读写，所以其实并不需要像 data 段一样，编译成目标文件后马上为其分配空间。利用 bss 段这种做法可以优化文件大小，无需分配过多的空间。</p><p>bss 段在目标文件中是<strong>不占空间的，只有大小信息</strong>，在加载程序时，为 bss 段分配空间。如果是有初始值的全局变量，那么一般是在 data 段中，<strong>该段的内容在目标文件中存在且有值的信息</strong>，加载程序的时候，加载器分配 data 段的空间，并把目标文件中的 data 段内容复制到内存中。</p><p><strong>但还是建议手动初始化，原因请参考编译流程中的符号表一节。</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/awkvx.jpg" alt="bss 段示意图"></p><h2 id="局部变量在内存栈中的存储方式"><a href="#局部变量在内存栈中的存储方式" class="headerlink" title="局部变量在内存栈中的存储方式"></a>局部变量在内存栈中的存储方式</h2><p><a href="https://blog.csdn.net/qq_19406483/article/details/77511447">C 语言局部变量在内存栈中的顺序</a><br><a href="https://blog.csdn.net/wuheshi/article/details/80135525">局部变量内存分配详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0       <span class="comment">// 栈是从高地址到低地址发展</span></span></span><br><span class="line">    <span class="type">int</span> a;  <span class="comment">// 0x7ffeec1c75c8  4 bytes（ca ~ c8）</span></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">// 0x7ffeec1c75c7  1 byte</span></span><br><span class="line">    <span class="type">int</span> c;  <span class="comment">// 0x7ffeec1c75c0  7 bytes （这里补了3个字节）</span></span><br><span class="line">    <span class="type">char</span> d; <span class="comment">// 0x7ffeec1c75bf  1 byte（低地址）</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">    d = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p \nb = %p  \nc = %p \nd = %p\n &quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">// 0x7ffeed77e5cb  1 byte</span></span><br><span class="line">    <span class="type">int</span> a;  <span class="comment">// 0x7ffeed77e5c4  7 bytes（偏移1，不是4的倍数，补了3个字节，3+4 = 7，符合内存对齐原则）</span></span><br><span class="line">    <span class="type">int</span> c;  <span class="comment">// 0x7ffeed77e5c0  4 bytes</span></span><br><span class="line">    <span class="type">int</span> d;  <span class="comment">// 0x7ffeed77e5bc  4 bytes</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">    d = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p \nb = %p   \nc = %p  \nd = %p\n &quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在网上还找到其它分配规则，但至少我的电脑不是这样的。</p><ul><li><p>规则 1：内存由低到高优先分配给占位 8 字节、4 字节、2 字节、1 字节的数据类型<br>  数据类型占位说明： </p><ul><li>8 字节：double、long long int </li><li>4 字节：int、float、long int、unsigned int </li><li>2 字节：short 、unsigned short </li><li>1 字节：char 、unsigned char</li></ul><p>  例如，分别定义下列变量，内存地址中由低到高分别为：<br>  double &lt; int &lt; short &lt; char </p></li><li><p>规则 2：同种占位的类型按定义变量的先后顺序内存地址会增加 </p></li><li><p>规则 3：在规则 2 前提下，定义数组不会和同种数据类型混占内存</p></li></ul><p>这样解释了为什么有些编码规范中建议的相同结构的定义在一起，不仅是美观，而且节省内存。</p><h2 id="局部变量在汇编代码的形式"><a href="#局部变量在汇编代码的形式" class="headerlink" title="局部变量在汇编代码的形式"></a>局部变量在汇编代码的形式</h2><p>参考：<a href="https://blog.csdn.net/tangl_99/article/details/5588">深入了解 C 语言（局部变量的定义）</a>、<a href="https://www.cnblogs.com/stormpeach/p/4322278.html">从汇编来看c语言之变量</a></p><p>汇编里面没有变量名的说法，是直接按顺序定位的。C 语言函数中的局部变量的空间一般都是放在堆栈里面。在进入函数前，通过 <code>SUB SP, +XX</code> 来为这些局部变量分配堆栈空间。然后，通过 BP 寄存器来对这些局部变量进行访问。函数结束时，<code>MOV SP, BP</code> 还原堆栈指针，局部变量随之而消失。最后以 <code>POP BP</code> 还原 BP，结束该函数。</p><p>值得注意的是，C 语言会自动为 C 函数中经常使用 int 类型变量设置成 resigter int。这样的局部变量就不是使用堆栈空间的了，而就是直接存放在 SI 寄存器。</p><h2 id="关于-const-小插曲"><a href="#关于-const-小插曲" class="headerlink" title="关于 const 小插曲"></a>关于 const 小插曲</h2><p>全局和局部的 const 的存储位置不同，说明 const 其实只是一个标识，检查发生在编译的时候。</p><p>详细请看：<a href="https://blog.csdn.net/u010276189/article/details/50947677">const 的实现原理</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">31231</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> e = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;a); <span class="comment">// e57e05e8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;b); <span class="comment">// e57e05e4</span></span><br><span class="line">    <span class="comment">// 静态 / 全局</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;c); <span class="comment">// a420018 静态区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;d); <span class="comment">// a41ffac 常量区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;e); <span class="comment">// a41ffb0 常量区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>已在对应的标题下。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储区 </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 unsigned 和 signed 类型相互转换的理解</title>
      <link href="/2018/05/06/025_%E5%85%B3%E4%BA%8E%20unsigned%20%E5%92%8C%20signed%20%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/05/06/025_%E5%85%B3%E4%BA%8E%20unsigned%20%E5%92%8C%20signed%20%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">-1</span>; <span class="comment">// 【补码】-1表示为 1111 1111（省略n个1，看机器是多少位） </span></span><br><span class="line">    <span class="type">char</span> b = a; <span class="comment">// signed char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %d&quot;</span>, a, b);    <span class="comment">// 从unsigned转换为signed，所以 a 前面填 0，表示为 255（00..0011111111），而 b 前面填符号位，即 1，表示为 -1（全部位为 1）</span></span><br><span class="line">    <span class="comment">// 注意 printf 的时候也有一次转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：255  -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">-1</span>; <span class="comment">// -1 表示为 1111 1111 1111 1111 1111 1111 1111 1111（32 位），给了 a 后变成 16 位，即 16 个 1，取右边 16 个 1。</span></span><br><span class="line">    <span class="type">short</span> b = a; <span class="comment">// 同理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %d&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：65535  -1</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>这是两段很简单的代码，我就以第二段代码为例。在计算机中，负数是以补码来存储的。</p><p>C 语言中常量整数 -1 的补码表示为 <code>0xFFFFFFFF</code>。截取后面 16 位 <code>FFFF</code> 赋值给变量 a（unsigned short）。此时 a &#x3D; 0xFFFF。<br><strong>（a 没有符号位，0xFFFF 转换为十进制为 65535）</strong></p><p>a 又将 <code>0xFFFF</code>，直接赋值给 short b。 此时 b &#x3D; 0xFFFF。<br><strong>（但是要注意，b是有符号的，0xFFFF 转换为十进制为-1）。</strong></p><p>执行 <code>printf(&quot;%d %d&quot;, a, b)</code> 的时候，要将 a 和 b 的值先转换为 int 型（相当于 signed int，有符号型）：</p><ol><li>unsigned → signed：a 没有符号所以转为 int 型为 <code>0x0000FFFF</code>，即 <code>65535</code></li><li>signed → signed：b 有符号所以转为 int 型为 <code>0xFFFFFFFF</code>，即 <code>-1</code></li></ol><p>再看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">-1</span>; <span class="comment">// 假设是32位计算机，-1表示为32个1</span></span><br><span class="line">    <span class="type">int</span> b = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %d&quot;</span>, a, b); <span class="comment">// -1 -1  这里都强制转换成 signed int 了，所以都是-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u  %u&quot;</span>, a, b); <span class="comment">// 4294967295 4294967295</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 printf 中的 %d 会将其强制转换成有符号整形数 -1，所以如果用 cout 输出 a，结果应该是 4294967295，或是用 %u 格式输出。</p><p><strong>只要记住：</strong>看原来被转换的是 signed 还是 unsigned。</p><ol><li><p>unsigned → signed 的时候，是直接复制到低位，<strong>高位填0</strong>。如果 signed 类型位数不够，只直接装载 unsigned 低位。</p></li><li><p>signed → unsigned 的时候，也是将补码直接复制到低位，<strong>高位填符号位</strong>。如果 unsigned 位数不够，只直接装载 signed 低位。</p></li></ol><p>编译器里面有标准的转换，这个是在整型运算的时候出现。<strong>标准转换的规则是：短的的向长的转；有符号的向无符号的转。</strong>如果被转换的数据比转换后的数据要长的话，转换可能会丢失高位数据。通常，编译器会给出警告。</p><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// a + b = 1111111111111111111111111111111110 = -2 但对于unsigned来说是一个很大的整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);  <span class="comment">// a向 unsigned int转换，但最终还是要看展示的格式</span></span><br><span class="line"><span class="comment">// 如果是 %u，我的电脑打印的是 4294967294</span></span><br></pre></td></tr></table></figure><p><strong>最终的展示结果还是要看 %u 还是 %d</strong>。无符号整数和有符号整数进行运算，是有符号整数向无符号整数靠齐。</p><p>从短到长依次为：short → unsigned short → int → unsigned int。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unsigned </tag>
            
            <tag> signed </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于补码的总结</title>
      <link href="/2018/04/20/024_%E5%85%B3%E4%BA%8E%E8%A1%A5%E7%A0%81%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/20/024_%E5%85%B3%E4%BA%8E%E8%A1%A5%E7%A0%81%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>原码：true code<br>补码：complemental code<br>反码：ones-complement</p><p>符号位都是用 0 表示「正」，用 1 表示「负」，而数值位，三种表示方法各不相同。</p><p>在计算机系统中，数值一律用<strong>补码</strong>来表示和存储。原因在于：</p><ul><li>可以将 <code>符号位</code> 和 <code>数值位</code> 统一处理</li><li><code>加法</code> 和 <code>减法</code> 也可以统一处理</li><li>此外，补码与原码可以 <code>相互转换</code>，其运算过程是相同的，不需要额外的硬件电路</li></ul><span id="more"></span><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ptvt9.jpg" alt="补码示意图"></p><p>可以理解为一个循环圈。</p><h2 id="补码的特性"><a href="#补码的特性" class="headerlink" title="补码的特性"></a>补码的特性</h2><ol><li>一个负整数的原码与其补码相加，和为模</li><li>对一个整数的补码再求补码，等于该整数自身</li><li>补码的正零与负零表示方法相同</li></ol><h2 id="整数的补码"><a href="#整数的补码" class="headerlink" title="整数的补码"></a>整数的补码</h2><p>求给定数值的补码分以下两种情况：</p><h3 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h3><p>正整数的补码是其二进制表示，与原码相同。</p><blockquote><p>【例 1】+9 的补码是 00001001。（备注：这个 +9 的补码是用 8 位 二进制来表示的，补码表示方式很多，还有 16 位二进制补码表示形式，以及 32 位二进制补码表示形式吗，64 位进制补码表示形式等。每一种补码表示形式都只能表示有限的数字。）</p></blockquote><h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><p><strong>求负整数的补码，将其对应正数二进制表示所有位取反（包括符号位，0 变 1，1 变 0）后加 1。</strong><br>同一个数字在不同的补码表示形式中是不同的。比如 -15 的补码，在8 位二进制中是 11110001，然而在 16 位二进制补码表示中，就是 1111111111110001。（以下都使用 8 位二进制来表示）</p><p><strong>记住：</strong>对正数的补码做处理，得到负数的补码；对负数的补码做处理，得到正数的补码。</p><blockquote><p>【例 2】求 -5 的补码。<br>-5 对应正数 5（00000101）→ 所有位取反（11111010）→ 加1（11111011）<br>所以 -5 的补码是 11111011。</p></blockquote><blockquote><p>【例 3】数 0 的补码表示是唯一的。<br>[+0]补 &#x3D; [+0]反 &#x3D; [+0]原 &#x3D; 00000000<br>[-0]补 &#x3D; 11111111+1 &#x3D; 00000000</p></blockquote><blockquote><p>-1 的补码表示为：对应正数 1（0000 0001），取反得（1111 1110），加 1 得（1111 1111）<br>-127 的补码表示为：对应正数 127（0111 1111），取反得（1000 0000），加 1 得（1000 0001）<br>-128 的补码表示为：对应正数 128（1000 0000），取反得（0111 1111），加 1 得（1000 0000）负数里面最小的数，即 -128</p></blockquote><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><p>补码加法：<code>[X+Y]补 = [X]补 + [Y]补</code></p><p>补码减法：<code>[X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补</code></p><h2 id="再思考"><a href="#再思考" class="headerlink" title="再思考"></a>再思考</h2><p>求补码为什么要反码 +1 ？</p><p>目的就是为了正负相加值溢出后归为 0 啊。（原码 + 反码 &#x3D; 1111 1111）</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0mwcm.jpg" alt="某大神的数学解释，我觉得记住上面那句话就好了，还有最上面那个示意图"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见数据类型大小的总结</title>
      <link href="/2018/04/12/023_%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/12/023_%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>C 中变量为什么需要被指定类型？</p><ol><li>变量的类型告诉编译器怎么处理这个变量的数据，指针加法运算</li><li>变量的类型告诉编译器要分配多少内存空间</li></ol><p>数据类型特别是<code>int</code>相关的类型在不同位数机器的平台下长度不同。C99 标准并不规定具体数据类型的长度大小，只规定级别。什么是<strong>级别</strong>？比如<code>int</code>的大小不能超过<code>long</code>。</p><span id="more"></span><p>还有什么是<code>字（word）</code>？</p><p>字的大小等于 CPU 指令大小，即代表一次处理信息的能力 &#x3D; 系统位，计算机从 32 位发展到 64 位的原因是寻址空间不足。</p><h2 id="常见基本数据类型的大小"><a href="#常见基本数据类型的大小" class="headerlink" title="常见基本数据类型的大小"></a>常见基本数据类型的大小</h2><p>单位：字节</p><table><thead><tr><th></th><th>16位</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td><td>2</td></tr><tr><td><strong>int 等于 unsigned int</strong></td><td>4</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>4</td><td><strong>8</strong></td></tr><tr><td>long long</td><td>&#x2F;</td><td>8</td><td>8</td></tr><tr><td>float</td><td>&#x2F;</td><td>4</td><td>4</td></tr><tr><td>double</td><td>&#x2F;</td><td>4</td><td>8</td></tr><tr><td><strong>pointer</strong></td><td>2</td><td>4</td><td>8</td></tr><tr><td>size_t</td><td>2</td><td>4</td><td>8</td></tr></tbody></table><p>注意到<code>int/long</code>和<code>float/double</code>类似，<code>long</code>和<code>double</code>只有在 64 位下才变成 8 字节。</p><table><thead><tr><th></th><th>unsigned</th><th>signed</th></tr></thead><tbody><tr><td>8位（1字节）</td><td>0 ~ 255</td><td>-128 ~ 127</td></tr><tr><td>16位（2字节）</td><td>0~65534</td><td>-32767~32766</td></tr><tr><td>32位（4字节）</td><td>0~4294967294</td><td>-2147483647~2147483646</td></tr><tr><td>64位（8字节）</td><td>0~1844亿亿1.8 x 10^19</td><td>dead</td></tr></tbody></table><p><strong>这两个表值得记住！</strong></p><h2 id="查看地址的方法"><a href="#查看地址的方法" class="headerlink" title="查看地址的方法"></a>查看地址的方法</h2><ul><li><code>%d</code>将所给存储单元以<code>十进制</code>有符号型形式输出</li><li><code>%p</code>将所给存储单元以<code>十六进制</code>输出指针变量对应的地址值</li><li><code>%x</code>将所给存储单元以<code>十六进制</code>形式输出</li></ul><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/6d0bl.jpg" title="我的机器"></p><p>为什么 64 位系统的地址在 C 语言中打印出来还是 32 位的呢？</p><p>查看地址用<code>%p</code>参数进行格式化，不然即使是 long 也同样的是被阉割成 32 位的，具体原因可能跟历史有关吧。（图中上半部分是<code>%x</code>的打印结果；<strong>在 64 位系统下，地址的长度为 48 位</strong>，且以<code>7ffe</code>为前缀的地址都是属于内存中的某块区域）</p><h2 id="float-double-的存储形式"><a href="#float-double-的存储形式" class="headerlink" title="float &amp; double 的存储形式"></a>float &amp; double 的存储形式</h2><p>float：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/4iwmi.jpg"></p><p>double：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/81g2i.jpg"></p><p>转换公式：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vrfy2.jpg"></p><p><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></p><h2 id="size-t-类型"><a href="#size-t-类型" class="headerlink" title="size_t 类型"></a>size_t 类型</h2><p>int 小于等于数据线宽度，size_t 大于等于地址线宽度。</p><blockquote><p><strong>From 知乎：</strong>size_t 存在的最大原因可能是<code>地址线宽度历史中经常都是大于数据线宽度的</code>。在数据只有 8 位的年代，地址率先进入 10 位、12 位；在数据 16 位的年代，地址也已经进入了 20 位，24 位。目前的 int 普遍是 32 位，而 size_t 在主流平台中都是 64 位。size_t 为什么存在？因为无论 int 还是 unsigned int 都很可能小于 size_t 需要的大小，所以必须有个 size_t。</p></blockquote><blockquote><p>这个名字很直观，是<code>sizeof (type)</code>的返回类型，就是表示一个 size。你说用 unsigned int 来替换，考虑如果你的代码在I16LP32平台下运行（比如第一代摩托罗拉68000），那就捉急了吧?</p></blockquote><p>为了跨平台，为了能保存足够大的<strong>非负整数</strong>，比如数组下标。</p><p>size_t 定义在标准头文件<code>&lt;stddef.h&gt;</code>中，是一个 unsigned 整型。C 的标准库这么做是为了代码的可移植性。不同的编译器，sizeof、strlen() 有不同的返回类型，用 size_t 可以在所有的标准 C 语言中提高代码的包容性。</p><ol><li>sizeof：获取操作数占用的内存空间字节数，返回类型 size_t。</li><li>strlen：获取字符数组实际使用的字节数（也是字符数，因为一个 char 类型占用一字节），不包含数组结尾符<code>&#39;\0&#39;</code>，返回类型 size_t。</li></ol><p>我的电脑上：<code>sizeof(size_t)</code>等于 8，相当于 unsigned long。</p><h2 id="size-t-与-unsigned-int-的区别"><a href="#size-t-与-unsigned-int-的区别" class="headerlink" title="size_t 与 unsigned int 的区别"></a>size_t 与 unsigned int 的区别</h2><p>size_t 和 unsigned int 有所不同，<strong>size_t 的取值范围是目标平台下最大可能的数组尺寸。</strong></p><p>最典型的，在 x64 下，unsigned int 还是 4，但 size_t 是 8。这意味着你在 x64 下最大可能开辟的数组尺寸是 $2^{64}$。如果你使用 int 或者 unsigned int，那么在 x64 下如果你的代码中全部使用它们作为数组的尺寸标记，那么你就会失去控制 $2^{32}$ 尺寸以上的数组的机会。虽然现在在 x64 上开辟一个大于 $2^{32}$ 大小的连续数组依然是个不大可能的事情，不符合实际需求，但是…… ↓↓↓</p><blockquote><p>“640K 内存对于任何人来说都足够了。” —— 比尔盖茨</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>忘了保存。。。（打了自己一巴掌）</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型大小 </tag>
            
            <tag> size_t </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不靠谱的概率笔记（基本概念的理解）</title>
      <link href="/2018/04/11/021_%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E6%A6%82%E7%8E%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/11/021_%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E6%A6%82%E7%8E%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概率的定义"><a href="#概率的定义" class="headerlink" title="概率的定义"></a>概率的定义</h2><p>感觉学习概率最重要的是把握<code>面积</code>和<code>比例</code>，是理解概念、公式的法宝。</p><p>以<code>新的视角</code>看待问题不是一件令人激动的事吗？<strong>概率是面积（测度）！</strong></p><blockquote><p>测度（Measure）是一个函数，它对一个<strong>给定集合的某些子集指定一个数</strong>，这个数可以比作大小、体积、概率等等。传统的积分是在区间上进行的，后来人们希望把积分推广到任意的集合上，就发展出测度的概念，它在数学分析和概率论有重要的地位。测度论是实分析的一个分支，研究对象有 $\sigma$ 代数、测度、可测函数和积分，其重要性在概率论和统计学中都有所体现。</p></blockquote><span id="more"></span><h3 id="蒙提霍尔问题（Monty-Hall-Problem）"><a href="#蒙提霍尔问题（Monty-Hall-Problem）" class="headerlink" title="蒙提霍尔问题（Monty Hall Problem）"></a>蒙提霍尔问题（Monty Hall Problem）</h3><p><strong>问题：</strong>A、B、C 三扇门，其中只有一扇是正确的门，打开后将能获得一辆跑车，而另两扇门后只有山羊。在决定选择某扇门后，还剩两个选项，其中至少有一个是错误选择。此时，主持人<strong>（知道正确的答案是什么）</strong>打开了没被选中的门中错误的那个，让挑战者确认了门后是山羊，并问道：“是否要重新选择？”</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/542mf.jpg" title="这可能是我画过最丑的羊🐑"></p><p>仔细想一下以下两条规则：</p><ul><li>如果第一次选择<code>正确</code>，重选必定错误（$\frac{1}{3}$）</li><li>如果第一次选择<code>错误</code>，重选必定正确（$\frac{2}{3}$ 即第一次选错的概率即为「重选后正确」的概率）</li></ul><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yzg0a.jpg" title="示例图"></p><p><strong>直观上的错误：</strong>假设挑战者选择 C 门，而主持人，而主持人打开了 A 门。于是，第一种情况将不再成立，只有两种可能。我觉得可以从以下方面去理解和思考：</p><ol><li><p>问题中要考虑主持人已打开错误的门的条件（prior）</p></li><li><p>如果挑战者第一次就选错了，主持人会不会打开一扇门让他再选呢？（肯定会！仔细想一下）</p></li><li><p>考虑有 100 扇门而主持人将打开其中 98 扇的情况（马住）</p></li><li><p>上帝视角观看所有情况<code>将不确定的事件（抽象的概率、生成机制）</code>转换为<code>确定的事件（统计观测值）</code>：</p><ul><li>每个会场同时进行游戏</li><li>每个会场按照事先确定好的剧本进行游戏（确定事件）</li><li>另一个角度，每个会场即为问题的一个平行世界 $\omega$ 且 $\omega \in \Omega$（下面有对三元组的解释）</li></ul></li></ol><table><thead><tr><th align="center">⭕️：跑车 ❌：山羊</th><th align="center">挑战者选择 A 门</th><th align="center">挑战者选择 B 门</th><th align="center">挑战者选择 C 门</th></tr></thead><tbody><tr><td align="center">主持人</td><td align="center">打开门 B 或 门 C</td><td align="center">打开门 A 或 门 C</td><td align="center">打开门 A 或 门B</td></tr><tr><td align="center">门 A 是正确答案</td><td align="center">⭕️ 40 个会场</td><td align="center">❌ 40 个会场</td><td align="center">❌ 40 个会场</td></tr><tr><td align="center">门 B 是正确答案</td><td align="center">❌ 40 个会场</td><td align="center">⭕️ 40 个会场</td><td align="center">❌ 40 个会场</td></tr><tr><td align="center">门 C 是正确答案</td><td align="center">❌ 40 个会场</td><td align="center">❌ 40 个会场</td><td align="center">⭕️ 40 个会场</td></tr></tbody></table><p>所以，当问题较为复杂时，常规视角下的语言和直觉将难以解决问题，<code>上帝视角</code>更为有效。如果只用语言表述，讨论可能会莫名其妙地转化为<code>哲学问题</code>，不知不觉中做出错误的判断。</p><h3 id="三元组和术语"><a href="#三元组和术语" class="headerlink" title="三元组和术语"></a>三元组和术语</h3><p>三元组大佬「也叫概率空间」：</p><p>$$(\Omega,\mathcal{F},P)$$</p><p>上文所说的每个平行世界 $\omega$ 也称为<code>样本</code>，由所有平行世界组成的集合 $\Omega$ 称为<code>样本空间</code>，$\Omega$ 的子集称为<code>事件</code>，记为 $\mathcal{F}$。$P$ 是一个集合「事件」的函数，称为<code>概率</code>「or 面积」。</p><h4 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h4><p>随机变量只是 $\Omega$ 中的<strong>函数</strong>而已，对于 $\Omega$ 中的各元素 $\omega$ 均有函数 $f(\omega)$ 「或 $X(\omega)$ 」返回相应的整数（$f$ 是一个确定的函数，返回情况是确定的，只是 $\omega$ 不确定而已）。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/j4gs0.jpg" title="灵魂画手的杰作"></p><p>从普通人的视角来看，随机值 $X$ 加上 $1$ 后得到的就是 $X+1$；从上帝视角来看，$X+1$ 表示的是各个世界中值为 $X(\omega) + 1$ 的函数。</p><p><strong>表示方法：</strong>$X(\omega)&#x3D;\alpha$，在点 $\omega$ 处，函数 $X$ 的值为 $\alpha$，而不是表示为「不确定的随机数 $X$ 可以取值为 $\alpha$」。</p><h3 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h3><p>概率分布<code>只考虑面积</code>，不涉及具体的平行世界。对于随机变量，哪一个世界中将得到哪一个值都已确定，而概率分布不涉及事件具体发生在哪一个世界。所以仅仅知道概率分布，我们无法求出随机变量的值。常见的形式为<code>概率分布表</code>。</p><h2 id="随机变量之间的关系"><a href="#随机变量之间的关系" class="headerlink" title="随机变量之间的关系"></a>随机变量之间的关系</h2><p>从面积的角度：</p><blockquote><p>概率是<code>面积</code>，条件概率是<code>面积比例</code>。</p></blockquote><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/n8hyp.jpg"></p><p>$\Omega$ 国有 3 个县（A、B、C），面积分别为 $P(A)$、$P(B)$、$P(C)$，且整个国家的总面积为 $1$。</p><p>$$P(A)+P(B)+P(C)&#x3D;1$$</p><p>这个国家的土地的用途有：住宅、工厂、农田，面积分别 $P(住宅)$、$P(工厂)$、$P(农田)$，且土地面积总和仍然为 $1$。</p><p>$$P(住宅)+P(工厂)+P(农田)&#x3D;1$$</p><h3 id="概念的预热"><a href="#概念的预热" class="headerlink" title="概念的预热"></a>概念的预热</h3><ul><li>联合概率：面积 $P(住宅,用途)$</li><li>边缘概率：面积 $P(住宅&#x3D;A)$<strong>（不考虑某个值的变化）</strong></li><li>条件概率：特定县、特定用途的<code>比例</code><strong>（条件概率就是一个比例）</strong></li><li>贝叶斯公式：倒推比例并理解其含义</li><li>独立性：比例相同的情况（如下）<ul><li>$P(住宅|A)&#x3D;P(住宅|B)&#x3D;P(住宅|C)&#x3D;P(住宅)$</li><li>$P(住宅,A)&#x3D;P(A)P(住宅|A)&#x3D;P(A)P(住宅)$</li></ul></li></ul><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>条件概率经常是理工科一些问题的焦点。这是因为在研究理工科问题时，我们常会采用控制变量法分析变量之间的关系，讨论变量 X 取特定值时变量 Y 的取值情况。如果没有误差，我们可以用函数 $Y&#x3D;f(X)$ 来表示它们的关系，但现实中很难确保 X 的观测值不变，这也就导致了 Y 的值无法确定，<strong>因此我们研究在 X 为某个特定值时 Y 的概率分布。</strong></p><p>概率论最多只能处理 X 与 Y 之间的相互关系，而无法判断哪一个是原因，哪一个是结果。</p><p>当引入时间的概念，如果事件 X 先于事件 Y 发生，<strong>至少说明 Y 不是 X 的原因</strong>，但不一定说明 X 是 Y 的原因。可能存在这种情况：有一个没能观测到的事件 A，是 X 与 Y 的原因。</p><p>我们可以通过<strong>主动介入</strong>来确定上述情况：X $\rightarrow$ Y 表示 X 的改变会引起 Y 的改变，反之不成立。</p><h3 id="分解联合概率（从右往左读更容易理解【面积-比例】）："><a href="#分解联合概率（从右往左读更容易理解【面积-比例】）：" class="headerlink" title="分解联合概率（从右往左读更容易理解【面积 + 比例】）："></a>分解联合概率（从右往左读更容易理解【面积 + 比例】）：</h3><p>$P(AA, BB, CC) &#x3D; P(AA | BB, CC)P(BB, CC) &#x3D; P(AA | BB, CC)P(BB | CC)P(CC)$</p><p>$P(AA,BB|CC)&#x3D;P(AA|BB,CC)P(BB,CC)$（左右乘以 $P(CC)$ 后和上一条式子一样）</p><p>$P(A, B, C, D) &#x3D; P(A, B | C, D)P(C|D)P(D)$</p><h3 id="用上面的概念解决三扇门问题"><a href="#用上面的概念解决三扇门问题" class="headerlink" title="用上面的概念解决三扇门问题"></a>用上面的概念解决三扇门问题</h3><p>设 X 是正确的门，Y 是挑战者选择的门，Z 是主持人打开的门。我们希望计算挑战者选择了门 3 且主持人打开了门 1 时，门 3 是正确答案时的条件概率（即不改变选择），即 $P(X &#x3D; 3 | Y &#x3D;3, Z&#x3D;1)$ 的值。</p><p>$$<br>\begin{aligned}<br>&amp;P(X&#x3D;3|Y&#x3D;3,Z&#x3D;1) &#x3D; \frac{P(X&#x3D;3,Y&#x3D;3,Z&#x3D;1)}{P(Y&#x3D;3,Z&#x3D;1)}\<br>&amp;&#x3D; \frac{P(X&#x3D;3,Y&#x3D;3,Z&#x3D;1)}{P(X&#x3D;1,Y&#x3D;3,Z&#x3D;1)+P(X&#x3D;2,Y&#x3D;3,Z&#x3D;1)+P(X&#x3D;3,Y&#x3D;3,Z&#x3D;1)}<br>\end{aligned}<br>$$</p><p>已知 X 的值可以假定是由骰子决定的，所以 $P(X&#x3D;1)&#x3D;P(X&#x3D;2)&#x3D;P(X&#x3D;3)&#x3D;\frac{1}{3}$</p><p>由于 Y 独立于 X（挑战者不知道关于门后的任何信息），也可以假定由骰子决定的，因为：</p><p>$$P(Y&#x3D;1)&#x3D;P(Y&#x3D;2)&#x3D;P(Y&#x3D;3)&#x3D;\frac{1}{3}$$</p><p>所以：</p><p>$$P(Y&#x3D;3|X&#x3D;1)&#x3D;P(Y&#x3D;3|X&#x3D;2)&#x3D;P(Y&#x3D;3|X&#x3D;3)&#x3D;\frac{1}{3}$$</p><p>于是，主持人打开门 1 的条件概率如下：</p><p>$P(Z&#x3D;1|X&#x3D;1, Y&#x3D;3)&#x3D;0$  …… 不可能打开正确的门<br>$P(Z&#x3D;1|X&#x3D;2, Y&#x3D;3)&#x3D;1$  …… 另一扇门是正确答案，因此只能打开门 $1$<br>$P(Z&#x3D;1|X&#x3D;3, Y&#x3D;3)&#x3D;\frac{1}{2}$  …… 剩下的两扇门都不是正确答案，因此概率为 $\frac{1}{2}$</p><p>综上可以得到：</p><p>$P(X&#x3D;1,Y&#x3D;3,Z&#x3D;1) &#x3D; P(Z&#x3D;1|X&#x3D;1,Y&#x3D;3)P(Y&#x3D;3|X&#x3D;1)P(X&#x3D;1)&#x3D;0$<br>$P(X&#x3D;2,Y&#x3D;3,Z&#x3D;1) &#x3D; \frac{1}{9}$（同理）<br>$P(X&#x3D;3,Y&#x3D;3,Z&#x3D;1)&#x3D; \frac{1}{18}$（同理）</p><p>最后得到：$P(X&#x3D;3|Y&#x3D;3,Z&#x3D;1)&#x3D;\frac{1}{3}$，这就是挑战者坚持最初选择的概率，且得到车的概率。</p><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>逆问题：需要从结果反推原因的问题。通常，原因 X 无法被直接观察、测量。此时，我们常会通过其结果 Y 来反推原因 X。很多工程问题都可以通过这种方式解释。</p><ul><li>通信：根据含有噪声的接收信号 Y 推测发送信号 X</li><li>语音识别：根据麦克风识别的音频波形数据 Y 推测语音信息 X</li><li>文字识别：根据扫描仪读取的图像数据 Y 推测用户书写的问童子 X</li><li>邮件自动过滤：根据收到的邮件文本 Y 推测邮件的类型 X（是否为广告等）</li></ul><p>注意：即使 X 相同，Y 也可能不同，因为大多数情况下都存在噪声与误差，我们不能使用 $Y&#x3D;f(X)$ 来表示两者的关系。</p><p>问题类型（非常重要❗️）：</p><ul><li>已知所有的：P(原因) 与 P(结果|原因)</li><li>求：P(原因|结果)</li></ul><p>在这类问题中，P(原因) 称为<code>先验概率</code>，P(原因|结果)称为 <code>后验概率</code>，分别用于表现事件是发生于结果 Y 取得之前还是之后。</p><h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>判定随机变量之间是否真的存在关联，如果 X 与 Y 无关，由 X 推 Y 就没有意义了。</p><p>「独立」与「互斥」不同<strong>（重要❗️）</strong>：</p><p>独立性并不意味着「事件 X &#x3D; 1 与 Y &#x3D; 1 不会同时发生」。<strong>这种互斥性反而表示 X 与 Y 不是独立的随机变量</strong>。此时，我们能够通过 X 是 1 来确定 Y 不是 1，因此，X 与 Y 之间具有某些关联。</p><p>还是那句话，独立性意味着我们无法通过 Y 判断 X 的值，无论 X 是 1、2 还是 3，Y 的取值概率都不变。</p><p><strong>举个例子：</strong></p><p>宝箱里面可能陷阱，真正的魔法师能够通过魔法检测宝箱中是否有陷阱，只是准确性不够。而冒牌魔法师根本不会魔法，检测的时候悄悄掷一下骰子来判断是否有陷阱。所以，<code>是否有陷阱</code>与<code>检测结果为存在陷阱</code>之间没有关联，我们可以用条件概率充分说明这一点：</p><p>$$P(发现陷阱 | 有陷阱) &#x3D; P(发现陷阱 | 没有陷阱)$$</p><p>$$or$$</p><p>$$P(有陷阱|发现陷阱)&#x3D; P(有陷阱|没发现陷阱)$$</p><p>独立性一般可以通过这式子去理解，比较直观。事件不独立也称为<code>从属</code>。</p><p><strong>注意：</strong></p><ol><li>我们无需区分谁独立于谁，没有先后关系。</li><li>上面第一条式子中，当 $P(有陷阱) &#x3D; 0 或 1 $ 时，虽然没有意义，但独立性仍然成立。</li><li>$P(发现陷阱|有陷阱)&#x3D;P(没发现陷阱|有陷阱)$ 并不能判断两者是否独立。</li></ol><p><strong>思考：【想当然就容易错】</strong></p><blockquote><p>现有一副不含大王、小王的扑克，共计 52 张。我们在洗牌后随机抽取一张，请问：<br>    （1）「这张牌是黑桃」与「这张牌是人头牌」是否独立？<br>    （2）「这张牌是黑桃」与「这张牌是红桃」是否独立？</p></blockquote><p><strong>事件独立性的等价表述：</strong></p><p>要彻底掌握一种数学概念，我们只能靠在各种不同的语境中了解该概念，充分思考大量的具体实例，并至少找出两三种能够加强结论直观性的隐喻。  —— 格雷格·伊根《大流散》</p><ol><li><p>⭕️ 与 ❌ 独立</p></li><li><p>条件概率与条件无关【直观易懂】</p><p> $P(⭕️|❌) &#x3D; P(⭕️|¬❌)$</p></li><li><p>添加或去除条件不影响概率【直观易懂】</p><p> $P(⭕️|❌) &#x3D; P(⭕️)$</p></li><li><p>联合概率之比相同</p><p> $P(⭕️,❌):P(⭕️,¬❌) &#x3D; P(¬⭕️,❌) &#x3D; P(¬⭕️,¬❌)$</p></li><li><p>联合概率是边缘概率的乘积【适用性最广，便于计算和判断，满足上面条件无意义的情况】</p><p> $P(⭕️,❌)&#x3D;P(⭕️)P(❌)$【可通过<code>贝叶斯公式</code>推导】</p></li></ol><p>注意第二种表述方式是独立性的定义，无需证明。</p><blockquote><p>「定义」与「定理」是完全不同的概念。「定义」是某样事物的固定名称。在数学中，我们无需解释某一定义背后的理由。尽管该定义的产生必然有其原因，但数学并不关心定义者的动机。另一方面，「定理」则是由前提推导出的结论。数学需要严格证明该推导过程的正确性。</p></blockquote><p>对于随机变量来说，无论 a 与 b 为何值，条件「X &#x3D; a」与条件「Y &#x3D; b」始终独立，我们称随机变量 X 与 Y 独立。</p><p><strong>上面第 4 条可以这么理解：【左右 1:3】</strong></p><table><thead><tr><th></th><th>Y &#x3D; ❌</th><th>Y &#x3D; ¬❌</th></tr></thead><tbody><tr><td>X &#x3D; ⭕️</td><td>0.10</td><td>0.30</td></tr><tr><td>X &#x3D; ¬⭕️</td><td>0.15</td><td>0.45</td></tr></tbody></table><p><strong>三个或更多随机变量的独立性（注意）：</strong></p><p>各对事件相互独立不代表所有事件都相互独立，要满足所有组合的情况：</p><p>若 n 个事件相互独立，</p><ol><li>$P(A_1, A_2, …, A_n)&#x3D; P(A_1)P(A_2)\cdots P(A_n)$</li><li>任意 n - 1 个事件都相互独立</li></ol><p>如 n &#x3D; 3：</p><p>$$<br>\begin{aligned}<br>P(A,B,C)&amp;&#x3D;P(A)P(B)P(C)\<br>P(A,B)&amp;&#x3D;P(A)P(B)\<br>P(A,C)&amp;&#x3D;P(A)P(C)\<br>P(B,C)&amp;&#x3D;P(B)P(C)<br>\end{aligned}<br>$$</p><p>所以，仅凭 $P(A,B,C)&#x3D;P(A)P(B)P(C)$ 不能断言 A、B、C 独立。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率 </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中值得注意的几个问题</title>
      <link href="/2018/03/12/020_Python%E4%B8%AD%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/12/020_Python%E4%B8%AD%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="可变和不可变对象"><a href="#可变和不可变对象" class="headerlink" title="可变和不可变对象"></a>可变和不可变对象</h2><p>参考文章: <a href="https://www.jianshu.com/p/c5582e23b26c">这里</a></p><p>可变：list, dict, set<br>不可变：int, str, float, tuple</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">int_test</span>():  <span class="comment"># 不可变，会复制一份 </span></span><br><span class="line">    i = <span class="number">77</span></span><br><span class="line">    j = <span class="number">77</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(<span class="number">77</span>))                  <span class="comment">#140396579590760</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i id:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>(i)))      <span class="comment">#i id:140396579590760</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;j id:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>(j)))      <span class="comment">#j id:140396579590760</span></span><br><span class="line">    <span class="built_in">print</span> i <span class="keyword">is</span> j                    <span class="comment">#True</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;new i id:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>(i)))  <span class="comment">#new i id:140396579590760</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;new j id:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>(j)))  <span class="comment">#new j id:140396579590736</span></span><br><span class="line">    <span class="built_in">print</span> i <span class="keyword">is</span> j                    <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dict_test</span>():  <span class="comment"># 可变，不会复制一份</span></span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    b = a   <span class="comment"># 浅复制</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))          <span class="comment"># 140367329543360</span></span><br><span class="line">    a[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;hhhh&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;id a:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>(a)))   <span class="comment"># id a:140367329543360</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a:&#x27;</span> + <span class="built_in">str</span>(a))</span><br><span class="line">    b[<span class="string">&#x27;hah&#x27;</span>] = <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;id b:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>(b)))   <span class="comment"># id b:140367329543360</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b:&#x27;</span> + <span class="built_in">str</span>(b))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a:&#x27;</span> + <span class="built_in">str</span>(a))       <span class="comment"># 这里a也跟着变了！</span></span><br></pre></td></tr></table></figure><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>由于 Python 规定参数传递都是传递引用，也就是传递给函数的是原变量实际所指向的内存空间，修改的时候就会根据该引用的指向去修改该内存中的内容，所以按道理说我们在函数内改变了传递过来的参数的值的话，原来外部的变量也应该受到影响。但是上面我们说到了 Python 中有可变类型和不可变类型，这样的话，当传过来的是可变类型<code>list、dict</code>时，我们在函数内部修改就会影响函数外部的变量。而传入的是不可变类型时在函数内部修改变量并不会影响函数外部的变量，因为修改的时候会先复制一份。</p><p>在很多的其他语言中在传递参数的时候允许程序员选择值传递还是引用传递（比如 C 语言加上<code>*</code>号传递指针就是引用传递，而直接传递变量名就是值传递），而 Python 只允许使用引用传递，但是它加上了可变类型和不可变类型，让我们感觉有点混乱了。听说 Python 只允许引用传递是为方便内存管理，因为 Python 使用的内存回收机制是计数器回收，就是每块内存上有一个计数器，表示当前有多少个对象指向该内存。每当一个变量不再使用时，就让该计数器<code>-1</code>，有新对象指向该内存时就让计数器<code>+1</code>，当计时器为<code>0</code>时，就可以收回这块内存了。</p><h2 id="Copy-Deepcopy"><a href="#Copy-Deepcopy" class="headerlink" title="Copy &amp; Deepcopy"></a>Copy &amp; Deepcopy</h2><p>Python 中的对象之间赋值时是按引用传递的，如果需要拷贝对象，需要使用标准库中的 copy 模块。</p><ol><li>copy.copy（浅拷贝）：只拷贝父对象，不会拷贝对象的内部的子对象。</li><li>copy.deepcopy（深拷贝）：拷贝对象及其子对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;a=&#x27;</span>,a   <span class="comment"># id: 4529531272</span></span><br><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;b=&#x27;</span>,b   <span class="comment"># id: 4529531272</span></span><br><span class="line">b= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;c=&#x27;</span>,c   <span class="comment"># id: 4529487240</span></span><br><span class="line">c= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]    <span class="comment"># 为什么还是这样abc呢？因为子对象没有被复制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;d=&#x27;</span>,d   <span class="comment"># id: 4529611080</span></span><br><span class="line">d= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br></pre></td></tr></table></figure><h2 id="is-和-的区别"><a href="#is-和-的区别" class="headerlink" title="is 和 &#x3D;&#x3D; 的区别"></a>is 和 &#x3D;&#x3D; 的区别</h2><p><code>is</code>比较的是 id 是不是一样，<code>==</code>比较的是值是不是一样。在 Python 中，<strong>万物皆对象！万物皆对象！万物皆对象！</strong>（很重要，重复 3 遍）</p><p>每个对象包含 3 个属性：id，type，value。id 就是对象地址，可以通过内置函数<code>id()</code>查看对象引用的地址；type 就是对象类型，可以通过内置函数<code>type()</code>查看对象的类型；value 就是对象的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a       <span class="comment"># 如果a是-10，a is b 为 False</span></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">d = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span>(a)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(b)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(c)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(d)   <span class="comment"># 21253459L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># id(a) == id(b)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> d</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == d</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>所以大多数情况下当用<code>is</code>和<code>==</code>的结果是一样时，用<code>is</code>的效率是会高于<code>==</code>的效率。<code>==</code>是通过对象的一个<code>__eq__()</code>方法实现的。</p><h3 id="By-The-Way"><a href="#By-The-Way" class="headerlink" title="By The Way"></a>By The Way</h3><p>Python为了实现对内存的有效利用，对小整数<code>[-5,256]</code>内的整数会进行缓存，不在该范围内的则不会缓存，具体如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="为什么-Python-不支持函数重载？"><a href="#为什么-Python-不支持函数重载？" class="headerlink" title="为什么 Python 不支持函数重载？"></a>为什么 Python 不支持函数重载？</h2><p>这个问题，最近在 cpyug 上面讨论得很火热。为了考虑为什么 Python 不提供函数重载，首先我们要研究为什么需要提供函数重载。函数重载主要是为了解决两个问题：</p><ul><li>可变参数类型</li><li>可变参数个数</li></ul><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p><p>好吧，那么对于情况 1，函数功能相同，但是参数类型不同，Python 如何处理？答案是根本不需要处理，因为 Python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 Python 中很可能是相同的代码，没有必要做成两个不同函数。</p><p>那么对于情况 2，函数功能相同，但参数个数不同，Python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p><p>好了，鉴于情况 1 跟情况 2 都有了解决方案，Python 自然就不需要函数重载了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陷入多元微积「危机」分时写的笔记</title>
      <link href="/2018/01/27/022_%E9%99%B7%E5%85%A5%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/01/27/022_%E9%99%B7%E5%85%A5%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="多元函数"><a href="#多元函数" class="headerlink" title="多元函数"></a>多元函数</h2><p>多元函数：输入由<code>多个变量</code>构成的函数，是一个空间的点到另一个空间的点的<code>映射</code>。虽然输出由多个变量构成的函数也可被称为<code>多元函数</code>，但是它们通常被称为<code>向量值函数</code>。</p><blockquote><p><strong>导数（Derivatives）:</strong> the rate of change of a function as you <code>slightly tweak its input</code>.<br><strong>积分（Integrals）:</strong> how to <code>add together infinitely infinitesimal</code> quantities that make up a function’s output.</p></blockquote><p>研究多元函数可以告诉我们<code>在不同方向上</code>函数值的变化情况，以及这些<code>变化间的关系</code>。</p><span id="more"></span><h3 id="向量值函数（Vector-valued-Functions-or-Vector-Functions）"><a href="#向量值函数（Vector-valued-Functions-or-Vector-Functions）" class="headerlink" title="向量值函数（Vector-valued Functions or Vector Functions）"></a>向量值函数（Vector-valued Functions or Vector Functions）</h3><p>定义域：标量 or 矢量<br>值域：矢量</p><p>可用向量场（Vector Field）表示该函数：$f(x,y)&#x3D;\left[\begin{aligned}F(x,y)\ G(x,y)\end{aligned}\right]$</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/29rpr.jpg" title="颜色表示向量的长度"></p><h3 id="可视化（Visualization）"><a href="#可视化（Visualization）" class="headerlink" title="可视化（Visualization）"></a>可视化（Visualization）</h3><p>在多元函数中，我们并不总是对函数进行可视化，而且并不总是将导数看作是<code>斜率（Slope）</code>。但是，我们仍然可以通过以下几种方式进行可视化：</p><ol><li><p><strong>图形</strong>：通常只适用于<code>二对一</code>的函数，如 $f(x,y)&#x3D;e^{-(x^2+y^2)}$、$f(x,y)&#x3D;\cos(x)\sin(y)$。</p><p> 在实际中，对于维度较高的函数如 $f(x,y,z)&#x3D;x^2+y^2+z^2$，人们通常先研究 $f(x,y)&#x3D;x^2+y^2$ 的性质（概念原型），并将发现的一些性质推广到原始的高维函数中。</p><p> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/oz5zc.jpg" title="The Bell Curve &amp; Wave"></p></li><li><p><strong>等高线图</strong>：该图只显示输入空间，适用于<code>二对一</code>的函数。</p><p> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1fntb.jpg" title="平面的等高线图"></p></li><li><p><strong>参数曲线&#x2F;平面</strong>：适用于输出空间维度<code>大于</code>输入空间的情况，如 $f(t)&#x3D;\left[\begin{aligned}2t\ 3t \end{aligned}\right]$、$f(t)&#x3D;\left[\begin{aligned}\sin(t)\  \cos(3t) \ 3t \end{aligned}\right]$。</p><ul><li><p>一个输入：$f(t)&#x3D;\left[\begin{aligned}t\cos(2\pi t)\ t\sin(2\pi t)\end{aligned}\right]$</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/q7msq.jpg"></p></li><li><p>两个输入：$f(s,t)&#x3D;\left[\begin{aligned}t^3-st\ s-t\ s+t\end{aligned}\right]$</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/qu6f7.jpg" title="二维空间到三维空间的映射（和 3x2 矩阵一个道理）"></p></li></ul></li><li><p><strong>向量场</strong>：适用于输入空间维度与输出空间维度<code>相等</code>的函数，如 $f(x,y)&#x3D;\left[\begin{aligned}1\ y^2-y\end{aligned}\right]$。</p><p> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/s5uyo.jpg"></p></li><li><p><strong>变换</strong>：可以用于任何函数，通过这种方法可以对函数有更直观的理解（非线性变换）。</p><p> <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vacjx.jpg"></p></li></ol><h2 id="多元函数的导数"><a href="#多元函数的导数" class="headerlink" title="多元函数的导数"></a>多元函数的导数</h2><h3 id="偏导数（Partial-Derivatives）"><a href="#偏导数（Partial-Derivatives）" class="headerlink" title="偏导数（Partial Derivatives）"></a>偏导数（Partial Derivatives）</h3><blockquote><p>In fact, this intuitive feel for the symbol is one of the most useful takeaways from single-variable calculus, and when you really start feeling it in your bones, most of the concepts around derivatives start to click. <strong>直观的理解很重要！</strong></p></blockquote><p>$\frac{\partial f}{\partial x}$（”$\partial$” 读作：&#x2F;del&#x2F; or partial）：tiny change of $f$ with respect to tiny change of $x$</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/tzwyf.jpg" title="直观的理解之「每个方向对函数值的贡献」"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7qhsu.jpg" title="直观的理解之「在某个方向上的变化率」"></p><h3 id="梯度和方向导数（Gradient-Directional-Derivatives）"><a href="#梯度和方向导数（Gradient-Directional-Derivatives）" class="headerlink" title="梯度和方向导数（Gradient &amp; Directional Derivatives）"></a>梯度和方向导数（Gradient &amp; Directional Derivatives）</h3><p><strong>方向导数：</strong>是某个方向（任意方向）上的<code>导数</code>，是一个数！$\nabla_{\vec{v}\ }f(x_0,y_0)&#x3D; \nabla f(x_0,y_0)\cdot \vec{v}$（点积）表示为在 $(x_0,y_0)$ 上沿 $\vec{v}$（不一定是单位向量）方向的变化率。</p><p>可以仔细观察一下<code>偏导</code>和<code>方向导数</code>的定义式：</p><p>$$\frac{\partial f}{\partial x}(\vec{a})&#x3D;\lim\limits_{h\rightarrow0}\frac{f(\vec{a}+h\hat{i})-f(\vec{a})}{h}$$</p><p>$$\nabla_{\vec{v}\ }f(\vec{a})&#x3D;\lim\limits_{h\rightarrow0}\frac{f(\vec{a}+h\vec{v})-f(\vec{a})}{h}$$</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/zagcq.jpg" title="方向导数的几何意义"></p><p><strong>梯度：</strong>是一个矢量（向量），它所在方向（最陡峭的方向）的<code>方向导数</code>最大，表示为 $\nabla f &#x3D; \left[\begin{aligned}\frac{\partial}{\partial x}\\frac{\partial}{\partial y}\end{aligned}\right]$（可以读：nabla, del, grad）。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/jtf5z.jpg" title="注意梯度的方向在底部平面上，即用 xy 平面上的一个向量表示方向"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ufetu.jpg" title="每个方向都有方向导数"></p><p>$\nabla$ 可以看作是一个操作算子（Operator），其输入和输出均是函数 $f$，与 $\frac{d}{dx}$、$\frac{\partial}{\partial x}$ 类似。</p><p><strong>其他问题：</strong></p><ul><li>计算方向导数时要不要将向量归一化？</li></ul><blockquote><p>If the directional derivative is used to compute slope, either $\vec{v}$ must be a unit vector or you must remember to divide by $||\vec{v}||$ at the end. Then you will get $\nabla_{\vec{v}\ }f(\vec{x})&#x3D;\lim\limits_{h\rightarrow0}\frac{f(\vec{x}+h\vec{v})-f(\vec{x})}{h||\vec{v}||}$.<br>However, this definition puts too much emphasis on the particular use case of finding slope, so I (not me…) prefer to use the original definition and normalize $\vec{v}$ when necessary.</p></blockquote><ul><li>为什么只有一个最大值（方向导数）？</li></ul><p>梯度定义中有「一阶连续偏导」的条件，其意味着可微，也就意味着 $f(x,y)$ 在各个方向的切线都在同一个平面上，即切平面。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vhni5.jpg"></p><p>梯度与方向导数有这样的关系：</p><p>$$\nabla_{\vec{v}\ }f(a,b)&#x3D;\nabla f(a,b)\cdot \vec{v}$$</p><p>其中 $\nabla f(a,b)$ 是梯度。如 $\vec{v}$ 是与梯度同方向的单位向量，则方向导数取值最大，用公式可以表示为：</p><p>$$\max_{||\vec{v}||&#x3D;1}\nabla f(a,b)\cdot \vec{v}$$</p><p>根据点积的几何意义（投影）可知最大值只有一个，即在两个向量的方向相同的时。</p><h3 id="对参数曲线微分❓（Differentiating-Parametric-Curves）"><a href="#对参数曲线微分❓（Differentiating-Parametric-Curves）" class="headerlink" title="对参数曲线微分❓（Differentiating Parametric Curves）"></a>对参数曲线微分❓（Differentiating Parametric Curves）</h3><p>直接上图看几何意义：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/9e1a4.jpg"></p><h3 id="多元链式法则（Multivariable-Chain-Rule）"><a href="#多元链式法则（Multivariable-Chain-Rule）" class="headerlink" title="多元链式法则（Multivariable Chain Rule）"></a>多元链式法则（Multivariable Chain Rule）</h3><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8t1uz.jpg" title="求导步骤示意图"></p><p><strong>已知：</strong></p><p>$$\vec{v}(t)&#x3D;\left[\begin{aligned}x(t)\y(t)\end{aligned}\right]、\vec{v}’(t)&#x3D;\frac{d\vec{v}}{dt}&#x3D;\left[\begin{aligned}\frac{dx}{dt}\\frac{dy}{dt}\end{aligned}\right]$$</p><p>$$f &#x3D; f(\vec{v}(t))&#x3D;f(x(t),y(t))、\frac{df}{d\vec{v}}&#x3D;\nabla{f}&#x3D;\left[\begin{aligned}\frac{\partial{f}}{\partial{x}}\\frac{\partial{f}}{\partial{y}}\end{aligned}\right]$$</p><p><strong>则有：</strong></p><p>$$\begin{aligned}\frac{df}{dt}&amp;&#x3D;\frac{d}{dt}f(x(t),y(t))&#x3D;\nabla{f}\cdot\vec{v}’(t)&#x3D;\left[\begin{aligned}\frac{\partial{f}}{\partial{x}}\\frac{\partial{f}}{\partial{y}}\end{aligned}\right]\cdot\left[\begin{aligned}\frac{dx}{dt}\\frac{dy}{dt}\end{aligned}\right]\&amp;&#x3D;\frac{\partial{f}}{\partial{x}}\cdot\frac{dx}{dt}+\frac{\partial{f}}{\partial{y}}\cdot\frac{dy}{dt}\end{aligned}$$</p><p><strong>几何意义：</strong>上面的 $\nabla{f}\cdot\vec{v}’(t)$ 可以写成 $\nabla_{\vec{v}’(t)\ }f(\vec{v})$，即 $f$ 在 $\vec{v}’(t)$ 方向上的方向导数。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/rui1m.jpg" title="多元链式法则的几何意义"></p><p><strong>正规的定义式：</strong>（对比<code>方向导数</code>的定义式）</p><p>$$\begin{aligned}\lim\limits_{h\rightarrow0}\frac{f(\vec{v}(t+h)-f(\vec{v}(t))}{h}&amp;&#x3D;\lim\limits_{h\rightarrow0}\frac{f(\vec{v}(t)+\frac{d\vec{v}(t)}{dt}h + o(h))-f(\vec{v}(t))}{h}\&amp;&#x3D;\nabla_{\vec{v}’(t)\ }f(\vec{v})\end{aligned}$$</p><h2 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念"></a>其它概念</h2><h3 id="曲率（Curvature）"><a href="#曲率（Curvature）" class="headerlink" title="曲率（Curvature）"></a>曲率（Curvature）</h3><blockquote><p>how to describe how much you turn?</p></blockquote><p><strong>什么是<code>曲率</code>：</strong>用来描述曲线（在平面、空间上）弯曲程度的量。曲率越大，表示曲线的弯曲程度越大。表示为：$\kappa&#x3D;||\frac{dT}{d\vec{s}}||$，其中 $T$ 为改变的弧度、$\vec{s}$ 为改变的弧长。</p><p><strong>几何意义：</strong>马住，有点难！</p><p><strong>一般式：</strong>$\kappa &#x3D; \frac{|x’(t)y’’(t)-y’(t)x’’(t)|}{[x’(t)^2+y’(t^2)]^{\frac{3}{2}}}$。对于圆有：$\kappa &#x3D; \frac{1}{R}$。</p><p><strong>螺旋线（Helix）：</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/lpw1h.jpg"></p><p>对应的函数为：$\vec{s}(t)&#x3D;\left[\begin{aligned}\cos&amp;(t)\\sin&amp;(t)\\frac{t}{5}\end{aligned}\right]$；求导得：$\frac{d\vec{s}(t)}{dt}&#x3D;\left[\begin{aligned}-\sin&amp;(t)\\cos&amp;(t)\\frac{t}{5}\end{aligned}\right]$</p><p>单位切线向量（Unit tangent vector）：$T(t)&#x3D;\frac{\vec{s}’(t)}{||\vec{s}’(t)||} &#x3D; \left[\begin{aligned}\frac{-\sin(t)}{\sqrt{26}&#x2F;5}\\frac{\cos(t)}{\sqrt{26}&#x2F;5}\\frac{t&#x2F;5}{\sqrt{26}&#x2F;5}\end{aligned}\right]$；求导得：$\frac{dT(t)}{dt}$</p><p>最后求得：$\kappa&#x3D;||\frac{dT}{d\vec{s}}||&#x3D;||\frac{dT&#x2F;dt}{d\vec{s}&#x2F;dt}||$，代入即可。</p><h3 id="散度（Divergence）"><a href="#散度（Divergence）" class="headerlink" title="散度（Divergence）"></a>散度（Divergence）</h3><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/5sbf0.jpg" title="粒子在流动"></p><p>适用函数：2D → 2D、3D → 3D。</p><p><strong>定义</strong>：是向量分析中的一个<code>向量算子</code>，将向量空间上的一个<code>向量场</code>对应到一个<code>标量场</code>上。对于函数 $\vec{v}(x,y)&#x3D;\left[\begin{aligned}P(x,y)\ Q(x,y)\end{aligned}\right]$，其<code>散度</code>为 $\rm{div}\ \vec{v}&#x3D;\frac{\partial{P}}{\partial{x}}+\frac{\partial{Q}}{\partial{y}}$。</p><p><strong>写法上的<code>Trick</code>：</strong> $\nabla\cdot\vec{v}&#x3D;\left[\begin{aligned}\frac{\partial}{\partial{x}}\ \frac{\partial}{\partial{y}}\ \frac{\partial}{\partial{z}}\end{aligned}\right]\cdot\left[\begin{aligned}P\ Q\ R\end{aligned}\right]$</p><p><strong>几何上的意义：</strong>如<code>First Component</code>「即 $P(x,y)$」小于 $0$，则从左到右来看向量所指的方向往左边去一点：）</p><h3 id="旋度（Curl）"><a href="#旋度（Curl）" class="headerlink" title="旋度（Curl）"></a>旋度（Curl）</h3><blockquote><p>Curl measures the rotation in a fluid flowing along a vector field. Formally, curl only applies to 3D, but here we cover the concept in 2D to warmup.</p></blockquote><p><strong>2D 下<code>不正式</code>的旋度计算：</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ervs7.jpg"></p><p><strong>3D 下的定义：</strong>可以表示<code>三维向量场</code>对某一点附近的微元造成的<code>旋转程度</code>。向量场每一点的旋度是一个向量，称为<code>旋度向量</code>，可表示为（运用了<code>Notational Trick</code>）：</p><p>$$\begin{aligned}\rm{curl}\ \vec{v} &amp;&#x3D; \nabla\times\vec{v}&#x3D;\left[\begin{aligned}\frac{\partial}{\partial{x}}\ \frac{\partial}{\partial{y}}\ \frac{\partial}{\partial{z}}\end{aligned}\right]\times\left[\begin{aligned}P\ Q\ R\end{aligned}\right]&#x3D;det\left(\begin{array}\<br>\hat{i} &amp; \hat{j} &amp; \hat{k} \<br>\frac{\partial}{\partial{x}} &amp; \frac{\partial}{\partial{y}} &amp;  \frac{\partial}{\partial{z}} \<br>P &amp; Q &amp; R<br>\end{array}\right)\<br>&amp;&#x3D; (\frac{\partial{R}}{\partial{y}}-\frac{\partial{Q}}{\partial{z}})\hat{i} + (\frac{\partial{P}}{\partial{z}}-\frac{\partial{R}}{\partial{x}})\hat{j} + (\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})\hat{k}<br>\end{aligned}$$</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gdzqk.jpg" title="还需要沿着 z 轴复制多份"></p><p><strong>Interesting：</strong>旋度向量的大小等于改点上<code>角速度</code>的两倍。</p><h3 id="拉普拉斯算子（Laplacian）"><a href="#拉普拉斯算子（Laplacian）" class="headerlink" title="拉普拉斯算子（Laplacian）"></a>拉普拉斯算子（Laplacian）</h3><p><strong>定义：</strong>是由<code>欧几里得空间</code>中的一个函数的<code>梯度的散度</code>给出的微分算子。</p><p><strong>先看看 2D 下二阶导的情况：</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/9erxj.jpg"></p><p><strong>公式和几何意义：</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bo023.jpg"></p><p><strong>调和函数：</strong>一个二阶可导的函数，其满足拉普拉斯方程，即满足：$$\frac{\partial^2{f}}{\partial{x_1^2}}+\frac{\partial^2{f}}{\partial{x_2^2}}+\cdots+\frac{\partial^2{f}}{\partial{x_n^2}}&#x3D;0$$</p><p>上式也经常写作：$\nabla^2f &#x3D;0$ 或 $\Delta{f}&#x3D;0$。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/v5xph.jpg"></p><p><strong>所以</strong>，当 $f’’ &#x3D; 0$ 时，该点的值与其附近的点的平均值相等；当 $f’’ &gt; 0$ 时，附近的点的平均值大于该点的值；当 $f’’ &lt; 0$ 时，附件的点的平均值小于该点的值。</p><h3 id="雅克比矩阵（Jacobian-Matrix）"><a href="#雅克比矩阵（Jacobian-Matrix）" class="headerlink" title="雅克比矩阵（Jacobian Matrix）"></a>雅克比矩阵（Jacobian Matrix）</h3><blockquote><p>雅可比矩阵的重要性在于它体系那了一个可微方程与给出点的最优线性逼近，因此，雅可比矩阵类似于多元函数的导数。</p></blockquote><p>给出 $f(\left[\begin{aligned}x\ y\end{aligned}\right])&#x3D;\left[\begin{aligned}f_1(x,y)\ f_2(x,y)\end{aligned}\right]&#x3D;\left[\begin{aligned}x + \sin(y)\ y+\sin(x)\end{aligned}\right]$，其对应的<code>非线性变化</code>如下图所示。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xzclb.jpg"></p><p>在以红点为原点的切空间中，该区域可以看成是<code>局部线性的</code>（Locally Linear）。该空间内的变换可以看成是<code>线性变换</code>，其<code>变换矩阵</code>如下：</p><p>$$\left[<br>\begin{array}\<br>\frac{\partial{f_1}}{\partial{x}} &amp; \frac{\partial{f_1}}{\partial{y}}\<br>\frac{\partial{f_2}}{\partial{x}} &amp; \frac{\partial{f_2}}{\partial{y}}<br>\end{array}<br>\right]$$</p><p>其中：第一列对应了<code>x nudge</code>的变化、第二列对应了<code>y nudge</code>的变化、$f_1$ 对应了水平方向上的移动、$f_2$ 对应了垂直方向上的移动。</p><h2 id="多元导数的应用"><a href="#多元导数的应用" class="headerlink" title="多元导数的应用"></a>多元导数的应用</h2><h3 id="局部线性化逼近（Local-Linearization）"><a href="#局部线性化逼近（Local-Linearization）" class="headerlink" title="局部线性化逼近（Local Linearization）"></a>局部线性化逼近（Local Linearization）</h3><blockquote><p>The idea is to approximate a function near one of its inputs with a <code>simpler function</code> that has the same value at that input.</p></blockquote><p><strong>2D 下的几何意义：</strong>如何控制这个切平面，如图所示。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/9p3dj.jpg"></p><p>令 $\vec{v} &#x3D; \left[\begin{aligned}x\ y\end{aligned}\right]$、$\vec{v}_0 &#x3D; \left[\begin{aligned}x_0\ y_0\end{aligned}\right]$，该切平面可以表示为（可以扩展至更高维）：</p><p>$$\begin{aligned}L_f(x,y)&amp;&#x3D;f_x(x_0,y_0)(x-x_0)+f_y(x_0,y_0)(y-y_0)+f(x_0,y_0)\<br>&amp;&#x3D; \nabla{f(\vec{v}_0)}\cdot(\vec{v}-\vec{v}_0) + f(\vec{v}_0)<br>\end{aligned}$$</p><h3 id="局部二次非线性逼近（Quadratic-Approximations）"><a href="#局部二次非线性逼近（Quadratic-Approximations）" class="headerlink" title="局部二次非线性逼近（Quadratic Approximations）"></a>局部二次非线性逼近（Quadratic Approximations）</h3><blockquote><p>“Quadratic” means product of two variables. $x_0$ is read “x naught”.</p></blockquote><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/u47h3.jpg"></p><p>可以根据形如 $Q(x,y)&#x3D;a+bx+cy+dx^2+exy+fy^2$ 去推导，要近似点要满足如下条件：</p><ul><li><p>函数值相等，$f(x,y)&#x3D;Q(x,y)$</p></li><li><p>一阶偏导都相等，$f_x&#x3D;Q_x$、$f_y&#x3D;Q_y$</p></li><li><p>二阶偏导都相等，$f_{xx}&#x3D;Q_{xx}$、$f_{yy}&#x3D;Q_{yy}$、$f_{xy}&#x3D;Q_{yx}$</p></li></ul><p>我就直接丢公式了（相当于线性逼近的扩展）：</p><p>$$\begin{aligned}Q(x,y)&amp;&#x3D;f(x_0,y_0) + f_x(x_0,y_0)(x-x_0)+f_y(x_0,y_0)(y-y_0)\<br>&amp;+\frac{1}{2}f_{xx}(x_0,y_0)(x-x_0)^2+f_{xy}(x_0,y_0)(x-x_0)(y-y_0)\<br>&amp;+\frac{1}{2}f_{yy}(x_0,y_0)(y-y_0)^2\end{aligned}$$</p><p><strong>海森矩阵（Hessian Matrix）：</strong></p><p>$$H_f &#x3D; \left[\begin{array}\<br>\frac{\partial^2{f}}{\partial{x^2}} &amp; \frac{\partial^2{f}}{\partial{x}\partial{y}}\<br>\frac{\partial^2{f}}{\partial{y}\partial{x}} &amp; \frac{\partial^2{f}}{\partial{y^2}}<br>\end{array}\right]$$</p><p>包装了关于函数 $f$ 的<code>所有二阶偏导</code>，还可以扩展到更高维。</p><p><strong>用途：</strong>局部二次非线性逼近（方便<code>向量化</code>）、其行列式用于二次偏导检测</p><p><strong>向量化：</strong></p><p>我们用 $\vec{v}$ 表示 $[x, y]$，$\vec{v}_0$ 表示 $[x_0, y_0]$，则有</p><p>$$\begin{aligned}\<br>Q(\vec{v})&amp;&#x3D;f(x_0,y_0) + \left[\begin{array}\ f_x(x_0)\ f_y(y_0)\end{array}\right]\cdot\left[\begin{array}\x-x_0\y-y_0\end{array}\right] + [x-x_0\ y-y_0]\left[\begin{array}\ \frac{1}{2}f_{xx} &amp; \frac{1}{2}f_{xy}\ \frac{1}{2}f_{yx} &amp; \frac{1}{2}f_{yy}\end{array}\right]\left[\begin{array}\ x-x_0\ y-y_0\end{array}\right]\<br>&amp;&#x3D;f(\vec{v}_0) + \nabla{f(\vec{v}_0)}\cdot(\vec{v}-\vec{v}_0) + \frac{1}{2}(\vec{v}-\vec{v}_0)^{T}H_f(\vec{v}-\vec{v}_0)<br>\end{aligned}$$</p><p>总结的一些<code>对应关系</code>：</p><ul><li><p>一元：$\frac{df}{dx}$、$\frac{d^2f}{dx^2}$、$\frac{d^3f}{dx^3}$、…</p></li><li><p>多元：$\nabla{f}$、$H_f$、$\cal{Multilinear\ Algebra}$❓</p></li></ul><h3 id="多元函数的最优化（Optimizing-Multivariable-Functions）"><a href="#多元函数的最优化（Optimizing-Multivariable-Functions）" class="headerlink" title="多元函数的最优化（Optimizing Multivariable Functions）"></a>多元函数的最优化（Optimizing Multivariable Functions）</h3><p><strong>鞍点（Saddle Points）：</strong>在微分方程中，沿着某一方向是稳定的，另一方向是不稳定的奇点，或者不是局部极值点的<code>驻点</code>「neither maxima nor minima」。从不用角度看该点，可以同时具有局部极大值和局部极小值。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/nopv0.jpg"></p><p><strong>二阶偏导测试（Second Partial Derivative Test）：</strong></p><p>我们可以用<code>二级导数</code>来判定某个点是否为<code>鞍点</code>。从上图看二阶导数一正一负，不能判断为局部极值点。当出现 $\nabla{f}(x_0,y_0)&#x3D;0$ 时（Critical Point），我们用以下式子判断是否出现鞍点：</p><p>$$\cal{H}&#x3D;f_{xx}(x_0,y_0)\ f_{yy}(x_0,y_0)-f_{xy}(x_0,y_0)^2$$</p><p>若 $\cal{H}&gt;0$，则该点是局部极值点；若 $\cal{H}&lt;0$，则该点是鞍点；若 $\cal{H}&#x3D;0$，无法判断。</p><p>其中，$\cal{H}&#x3D;0$ 的情况与下图的情况类似：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/zckmv.jpg"></p><p><strong>进一步思考：</strong></p><p>$$f(x)\approx f(a)+f’(a)(x-a)+\frac{1}{2}f’’(a)(x-a)^2$$</p><ul><li><p>当 $f’(a)&#x3D;0$ 时，$f(x)\approx f(a)+\frac{1}{2}f’’(a)(x-a)^2$，因为 $(x-a)^2\geq 0$，所以 $f’’(a)$ 可以决定局部极小值和局部极大值。</p></li><li><p>当 $f’(a)&#x3D;0$、$f’’(a)&#x3D;0$ 时，$f(x)\approx f(a)$ 得到的是一个<code>常量</code>，无法决定是局部极大值还是局部极小值。</p></li></ul><h3 id="拉格朗日乘子法和约束优化（Lagrange-Multipliers-lambda-and-Constrained-Optimization）"><a href="#拉格朗日乘子法和约束优化（Lagrange-Multipliers-lambda-and-Constrained-Optimization）" class="headerlink" title="拉格朗日乘子法和约束优化（Lagrange Multipliers $\lambda$ and Constrained Optimization）"></a>拉格朗日乘子法和约束优化（Lagrange Multipliers $\lambda$ and Constrained Optimization）</h3><p>举个例子：</p><ul><li><p>收入（Revenue）：$R(x,y)&#x3D;x^2e^yy$</p></li><li><p>预算&#x2F;成本（Budget）：$B(x,y)&#x3D;x^2+y^2$</p></li></ul><p>约束问题可以表述：</p><p>$$\max{R(x,y)&#x3D;x^2e^yy},\<br>\rm{s.t.\ }\mit{B}(x,y)&#x3D;x^2+y^2&#x3D;b$$</p><p>解决该问题的本质是找到 $R(x,y)$ 与 $B(x,y)$ 的等高线相切的点，如下图所示。当 $B(x,y)&#x3D;b$ 时，红色圆是固定不变，可以调整 $R(x,y)$ 的大小以获得能够满足相切情况的等高线。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/jtho0.jpg" title="红线为 B"></p><p>相切的情况意味着<code>梯度方向相同或者相反</code>：$\nabla{R}&#x3D;\lambda\nabla{B}$，结合以上三个式子就可以求出最优解。</p><p>为了方便计算机计算，我们可以用<code>一个式子</code>表达上述的约束问题：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/tb1o1.jpg" title="Constrained Problem → Unconstrained Problem（计算机擅长这个）"></p><p><strong>$\lambda$ 有什么含义：</strong></p><p>将 $M^*$ 看成是 $b$ 的函数有 $M^*(b)&#x3D;R(x^*(b),y^*(b))$，此时 $x^*(b)$ 和 $x^*(b)$ 是隐式函数。此时，我们可以得出 $\lambda^*&#x3D;\frac{dM^*}{db}$，即 $M^*(b)$ 对于微小变化 $b$ 的变化率为 $\lambda^*$。</p><p><strong>这说明：</strong>如果 $\lambda^* &gt; 0$，说明我们可以使 $b$ 变大，从而使得 $M^*$ 变大，具有应用价值（或者提高一点点 $b$，可以得到<code>大概的变化量</code>！）。</p><p><strong>证明（Proof）：</strong></p><p>$\cal{L}^*$ 和 $\cal{L}$ 不同，前者是四元函数（包含 $b$），后者是三元函数。</p><p>$$\cal{L}^*(x^*(b),y^*(b),\lambda^*(b),b)&#x3D;R(x^*(b),y^*(b))-\lambda^*(B(x^*(b),y^*(b))-b)$$</p><p>$$\frac{d\cal{L}^*}{db}&#x3D;\frac{\partial{\cal{L}^*}}{\partial{x}}\cdot \frac{dx^*}{db} + \frac{\partial{\cal{L}^*}}{\partial{y}}\cdot \frac{dy^*}{db} + \frac{\partial{\cal{L}^*}}{\partial{\lambda}}\cdot \frac{d\lambda^*}{db} + \frac{\partial{\cal{L}^*}}{\partial{b}}\cdot \frac{db}{db}$$</p><p>其中：$\frac{\partial{\cal{L}^*}}{\partial{x}}$、$\frac{\partial{\cal{L}^*}}{\partial{y}}$、$\frac{\partial{\cal{L}^*}}{\partial{\lambda}}$ 均为 $0$（原因：看看上面图左边的公式），所以原式如下</p><p>$$\frac{d\cal{L}^*}{db}&#x3D;\frac{\partial{\cal{L}^*}}{\partial{b}}&#x3D;\lambda^*(b)$$</p><p><strong>多个条件：</strong>马住❗️</p><p><strong>条件为不等式：</strong>马住❗️</p><p><strong>KKT 条件：</strong>马住❗️</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元微积分 </tag>
            
            <tag> Multivarible Calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看不懂的微积分笔记</title>
      <link href="/2018/01/04/019_Calculus/"/>
      <url>/2018/01/04/019_Calculus/</url>
      
        <content type="html"><![CDATA[<ul><li><p>微积分探讨的三大思想：</p><ol><li><p>Integrals 积分 $\int^R_0$</p></li><li><p>Derivatives 求导 $\frac{d}{dx}$</p></li><li><p>Fact that they are opposite 它们的关系</p></li></ol></li><li><p>当你使用 $dt$ 时，你只是想表示 $dt\rightarrow 0$，它既不是「不穷小」，也不是 $0$。</p></li></ul><span id="more"></span><ul><li><p>$a^t$ 可以表示为 $e^{ct}$，其中$c&#x3D;\ln a$。为什么选用 $e$ 而不是其他底？</p><ul><li><p>$a^{kt} &#x3D; k \times \ln a\times a^{kt}$ （多了 $\ln a$）</p></li><li><p>$e^{kt} &#x3D; k \times e^{kt}$ （$k$ 即为变化率）</p></li></ul><p>  符合自然中的许多现象，变化率总是和变化量成正比：</p><ul><li><p>人口增长</p></li><li><p>温度变化</p></li><li><p>金钱投资</p></li></ul></li><li><p>位移 $s(t)$ 的导数：</p><ul><li><p>$\frac{ds}{dt}$ Velocity</p></li><li><p>$\frac{d^2s}{dt^2}$ Acceleration</p></li><li><p>$\frac{d^3s}{dt^3}$ Jerk（急动度）</p></li></ul></li><li><p>Chain Rule 的直观理解：</p></li></ul><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/d9rzl.jpg"></p><ul><li>泰勒展开式每一项的系数可以看作是一种<code>控制</code>：</li></ul><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/m0z0n.jpg"></p><ul><li>夹逼定理（Squeeze Theorem）</li></ul><p>$$g(x) \leq f(x) \leq h(x)$$</p><p>$$\left{<br>\begin{aligned}<br>\lim\limits_{x\rightarrow a} g(x)&#x3D;L \<br>\lim\limits_{x\rightarrow a} h(x)&#x3D;L<br>\end{aligned}<br>\rightarrow \lim\limits_{x\rightarrow a} f(x)&#x3D;L<br>\right.$$</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/63r31.jpg"></p><ul><li><p>连续性</p><ul><li><p>定义：设函数 $y&#x3D;f(x)$ 在点 $x_0$ 的某一领域内有定义，如果$$\lim\limits_{\Delta x \rightarrow 0}\Delta y &#x3D; \lim\limits_{\Delta x \rightarrow 0}[f(x_0 + \Delta x) - f(x_0)]&#x3D;0，$$</p><p>  那么称 $y&#x3D;f(x)$ 在点 $x_0$ 上连续。</p></li></ul></li><li><p>函数极限的性质</p><ul><li><p>唯一性</p></li><li><p>有界性：如果 $\lim\limits_{x \rightarrow x_0}f(x)&#x3D;A$，则存在常数 $M &gt; 0$ 和 $\delta &gt; 0$，使得当 $0 &lt; |x - x_0| &lt; \delta$ 时，有 $|f(x)|\leq M$</p></li><li><p>局部保号性</p></li></ul></li><li><p>无穷小（Infinitesimal or Infinitely Small）</p><ul><li><p>定义：如果 $f(x)$ 当 $x\rightarrow x_0$（或 $x\rightarrow \infty$）时的极限为 $0$，那么称 $f(x)$ 为当 $x\rightarrow x_0$（或 $x\rightarrow \infty$）时的无穷小。<strong>不要把它和很小的数混为一谈！</strong></p></li><li><p>无穷大（也不是数，只是极限趋于无穷大）</p></li><li><p>无穷小的比较 → 反映了不同的无穷小<code>趋近的快慢</code>：</p><ul><li><p>$\lim \frac{\beta}{\alpha} &#x3D; 0$，$\beta$ 比 $\alpha$ 高阶的无穷小，记为 $\beta&#x3D;o(\alpha)$</p></li><li><p>$\lim \frac{\beta}{\alpha} &#x3D; \infty$，$\beta$ 比 $\alpha$ 低阶的无穷小</p></li><li><p>$\lim \frac{\beta}{\alpha} &#x3D; c \neq 0$，同阶无穷小</p></li><li><p>$\lim \frac{\beta}{\alpha^k} &#x3D; c \neq 0$，$\beta$ 是 $\alpha$ 的 $k$ 阶无穷小</p></li><li><p>$\lim \frac{\beta}{\alpha}&#x3D;1$，等价无穷小，记为 $\alpha \sim \beta$</p></li></ul></li><li><p>定理 1：$\beta$ 与 $\alpha$ 是等价无穷小的充要条件为 $\beta&#x3D;\alpha+o(\alpha)$。</p><p>  当 $x \rightarrow 0$ 时，$\sin(x) \sim x、\tan(x)\sim x、\arcsin(x)\sim x、1-\cos(x)\sim\frac{1}{2}x^2$</p></li><li><p>定理 2：设 $\alpha \sim \alpha’，\beta \sim \beta’$，且 $\frac{\lim \beta’}{\lim \alpha’}$ 存在，则 $\lim \frac{\beta}{\alpha} &#x3D; \lim \frac{\beta’}{\alpha’}$。</p></li></ul></li><li><p>不连续点或间断点</p><ul><li><p>满足三种情况之一：</p><ul><li><p>在 $x&#x3D;x_0$ 没有定义</p></li><li><p>在 $x&#x3D;x_0$ 有定义，但在 $\lim\limits_{x\rightarrow x_0}f(x)$ 不存在</p></li><li><p>在 $x&#x3D;x_0$ 有定义，但 $\lim\limits_{x\rightarrow x_0}f(x) \neq f(x_0)$</p></li></ul></li><li><p>一类间断点（左右极限存在）</p><ul><li><p>可去间断点（极限相等）</p></li><li><p>跳跃间断点（极限不相等）</p></li></ul></li><li><p>二类间断点（左右极限不存在）</p><ul><li><p>无穷间断点</p></li><li><p>振荡间断点</p></li></ul></li></ul></li><li><p>区分「微分 Differential」和「导数 Derivative」</p><ul><li><p><code>微分</code>的定义：设 $y&#x3D;f(x)$ 在某区间内有定义，增量 $\Delta y &#x3D; f(x_0 + \Delta x)-f(x_0)$ 可以表示为 $\Delta y &#x3D; A\Delta x + o(\Delta x)$，其中 $A$ 是不依赖于 $\Delta x$ 的常数「$A&#x3D;f’(x)$」，那么称 $f(x)$ 在 $x &#x3D;x_0$ 上是可微的，则 $A\Delta x$ 也叫作改点上的微分，记作 $dy$，即 $dy &#x3D; A\Delta x$。</p></li><li><p>几何意义：切线的一元线性方程。局部切线段近似代替曲线段，即非线性函数的局部化。</p></li></ul><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/kcolo.jpg"></p><ul><li><code>导数</code>是函数到函数的映射，而<code>微分</code>是求另一个与导函数有关的函数。对于一元函数可能看不出什么区别，但对于二元函数，没法同时对 $x$ 和 $y$ 求导，但可以同时对它们求微分。比如在工程中常用：</li></ul></li></ul><p>$$\Delta y &#x3D; f(x_0 + \Delta x) - f(x_0) \approx f’(x_0)\Delta x$$<br>    如 $\sqrt[n]{1+x}\approx 1+\frac{1}{n}x$、$e^x \approx x$。</p><pre><code>- 全微分：$\Delta z =f(x+\Delta x, y+\Delta y) - f(x,y) = \frac&#123;\partial z&#125;&#123;\partial x&#125;\Delta x + \frac&#123;\partial z&#125;&#123;\partial y&#125;\Delta y + o(\sqrt&#123;(\Delta x)^2+(\Delta y)^2&#125;)$</code></pre><ul><li><p>微分中值定理</p><ul><li>条件：<ul><li>在 $[a, b]$ 上连续</li><li>在 $(a, b)$ 上可导</li><li>不同❓</li></ul></li></ul><ol><li><p>罗尔定理：至少有一点 $f’(\xi)&#x3D;0$</p></li><li><p>拉格朗日中值定理：$\frac{f(b)-f(a)}{b-a}&#x3D;f’(\xi)$</p></li><li><p>柯西中值定理：$\frac{f(b)-f(a)}{F(b)-F(a)}&#x3D;\frac{f’(\xi)}{F’(\xi)}$，当 $\left{\begin{aligned} X&#x3D;F(x)\Y&#x3D;f(x)  \end{aligned} \right.(a \leq x \leq b)$</p></li></ol></li><li><p>泰勒中值定理</p><ul><li>如果函数 $f(x)$ 在含有 $x_0$ 的某个区间 $(a,b)$ 内具有直到 $(n+1)$ 阶的导数，则对任一 $x\in(a,b)$ 有：</li></ul></li></ul><p>$$f(x)&#x3D;f(x_0)+f’(x_0)(x-x_0)+\frac{f’’(x_0)}{2!}(x-x_0)^2 + \dots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)$$</p><pre><code>    其中 $R_n(x) = \frac&#123;f^&#123;(n+1)&#125;(x_0)&#125;&#123;(n+1)!&#125;(x-x_0)^&#123;n+1&#125;，(x_0 \leq \xi \leq x)$，为拉格朗日型余项；而 $R_n(x) = o[(x-x_0)^n]$ 为佩亚诺型余项。    </code></pre><ul><li><p>函数凹 &#x2F; 凸</p><ul><li><p>$f(\frac{x_1+x_2}{2}) &lt; \frac{f(x_1)+f(x_2)}{2} \Leftrightarrow f’’(x) &gt; 0$ （凹，极小值）</p></li><li><p>$f(\frac{x_1+x_2}{2}) &gt; \frac{f(x_1)+f(x_2)}{2} \Leftrightarrow f’’(x) &lt; 0$ （凸，极大值）</p></li><li><p>$f’’(x) &#x3D; 0$ 对应的点称为拐点（Inflection Point），凹凸都有可能。</p></li></ul><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/zzctz.jpg"></p></li><li><p>换元积分法</p><ul><li><p>第一类：设 $f(u)$ 具有原函数，$u&#x3D;\varphi(x)$ 可导，则有换元公式$$\int f[\varphi(x)]\varphi’(x)dx &#x3D; [\int f(u)du]_{u&#x3D;\varphi(x)}$$</p></li><li><p>第二类：$$\int f(x)dx &#x3D; \int f[\psi(t)]\psi’(t)dt$$</p></li></ul></li><li><p>定积分中值定理</p><ul><li><p>如果函数 $f(x)$ 在积分区间 $[a,b]$ 上连续，则在 $[a,b]$ 上至少存在一个点 $\xi$，使下式成立：$$\int^b_a f(x)dx&#x3D;f(\xi)(b-a)，(a \leq \xi \leq b)$$</p><p>  $f(\xi)$ 是平均值。</p></li></ul></li><li><p>微分方程</p><ul><li><p>定义：表示未知函数（$y$）、未知函数的导数（$\frac{dy}{dx}$）与自变量（$x$）之间的关系的方程，如 $\frac{dy}{dx}&#x3D;2xy$、$x^3y’’’&#x3D;3x^2$。</p></li><li><p>求解：如上面方程通过变量分离后得 $\frac{dy}{y}&#x3D;2xdx$，再对两端积分得 $y&#x3D;\pm e^{x^2+C_1}$。</p></li></ul></li><li><p>平面及其方程</p><ul><li><p>三元方程：$F(x,y,z)&#x3D;0$</p></li><li><p>平面点法式方程：$\vec{n}\cdot\overrightarrow{M_0 M} &#x3D; 0 \Leftrightarrow A(x-x_0)+B(y-y_0)+C(z-z_0)&#x3D;0$</p></li></ul><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/4x7hf.jpg"></p><ul><li><p>一般方程：$Ax+By+Cz+D&#x3D;0，\vec{n}&#x3D;(A,B,C)$</p></li><li><p>截距式方程：$\frac{x}{a}+\frac{y}{b}+\frac{z}{c}&#x3D;1$</p></li></ul></li><li><p>空间直线及其方程</p><p>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/j8gbg.jpg"></p><ul><li><p>一般方程：$\left{\begin{aligned}A_1x+B_1y+C_1z+D_1&#x3D;0\A_2x+B_2y+C_2z+D_2&#x3D;0\end{aligned}\right.$</p></li><li><p>对称式方程（点向式方程）：$\frac{x-x_0}{m}&#x3D;\frac{y-y_0}{n}&#x3D;\frac{z-z_0}{p}$</p></li><li><p>参数方程：$\left{\begin{aligned}x&amp;&#x3D;x_0+mt\y&amp;&#x3D;y_0+nt\z&amp;&#x3D;z_0+pt\end{aligned}\right.$</p></li></ul></li><li><p>空间曲线及其方程</p><ul><li><p>一般方程：$\left{\begin{aligned}F(x,y,z)&#x3D;0\G(x,y,z)&#x3D;0\end{aligned}\right.$</p></li><li><p>参数方程：$\left{\begin{aligned}x&#x3D;x(t)\y&#x3D;y(t)\z&#x3D;z(t)\end{aligned}\right.$</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微积分 </tag>
            
            <tag> Calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes of Classical Logic | What is An Argument?</title>
      <link href="/2017/09/07/018_Logic/"/>
      <url>/2017/09/07/018_Logic/</url>
      
        <content type="html"><![CDATA[<h2 id="Pre-knowledge"><a href="#Pre-knowledge" class="headerlink" title="Pre-knowledge"></a>Pre-knowledge</h2><p><strong>Critical Thinking:</strong> the careful application of reason in the determination of <code>whether a claim is true</code>.</p><p><strong>Premise (on Wiki):</strong> a premise is an <code>assumption</code> that something is true. (note that we can assume sth. to be false too)</p><p>$$Premise \subset Assumption$$</p><p><strong>Assumption:</strong> presupposition, axioms, taking for granted.</p><span id="more"></span><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7a2dj.jpg"></p><p><strong>Difference between hypothesis and assumption:</strong></p><ul><li>A hypothesis is a <code>theory</code> that seeks to explain a phenomenon or a set of phenomena. Scientists or researchers make up hypothesis to see if they hold true. They conduct a number of <code>experiments</code> and test this hypothesis, and if the hypothesis indeed <code>proves correct</code>, it is deemed to have become a theory.</li><li>A hypothesis is an <code>assumption</code> that has been made working. It is a theory in waiting as it can be called theory only after <code>verification</code>.</li><li>An assumption is any statement that is believed to be true. <code>Thinking about the feelings of others is merely assumption</code> as there is no way to tell what a person is thinking or feeling. (It does not have the purpose as a hypothesis does)</li><li>Anything taken for granted is an assumption, and a hypothesis is at best a <code>working assumption</code>. (能不能理解为, hypothesis的可信度更高)</li></ul><h2 id="Argument"><a href="#Argument" class="headerlink" title="Argument"></a>Argument</h2><p><strong>An argument is:</strong></p><ol><li>a set of <code>claims</code>, or <code>statements</code>, or <code>propositions</code><ul><li>a claim is whether true or false, <strong>not both</strong></li></ul></li><li>one of the claims is called the <code>conclusion</code>, the remaining are called the <code>premises</code></li><li>the premises are intended as <code>offering reasons</code> to believe or accept the conclusion</li></ol><p><strong>A simple argument:</strong> (in standard form)</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xplkj.jpg"></p><p><strong>Why a claim should either be true or false is important?</strong></p><ol><li>Not all sentences can function as claims for <code>argumentative purposes</code>.<ul><li>Questions don’t count as claims</li><li>Commands are not claims</li><li>Premises can be beliefs, support, other conclusions, data, ideas, studies, statistics, opinions</li></ul></li><li>In saying that a sentence can function is a claim, we’re saying that all parties have a <code>shared understanding</code> of the meaning of the sentence. ❓</li></ol><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/udza1.jpg"></p><p><strong>Three hidden pieces to arguments:</strong></p><ol><li>Implied Conclusions</li><li>Unstated Premises</li><li>Missing Connections</li></ol><p><code>An unstated premise</code> is going to provide some kind of link between the stated premises and the conclusion, and there could be more than one unstated premise.</p><p><strong>Tryout:</strong></p><blockquote><p>A CEO of a major company noted a serious decline in worker productivity during the previous five years. According to a report done by an outside consultant, productivity dropped by 35% by the end of that period. The CEO has therefore initiated a plan to boost productivity by giving employees shares of the company as part of their pay package.</p></blockquote><p><strong>Premise:</strong> “A CEO of a major company noted a serious decline in worker productivity during the previous five years.”</p><ul><li>Premises are the facts or evidence that support or lead to the conclusion. Unlike assumptions, they are explicit in the text.</li></ul><p><strong>Assumption:</strong> “Owning something or part of something obliges you work harder to make it succeed.”</p><ul><li>Assumptions are the facts that support the conclusion, like the premises does, but unlike the conclusion and premises they are not stated in the text: they are implicit.</li></ul><p><strong>Supporting Information:</strong> “According to a report done by an outside consultant, productivity dropped by 35% by the end of that period.”</p><ul><li>Supporting information does not support the conclusion or main idea, rather, it supports information that is already in the text. Like a premise, this is stated and explicit information embedded in the text, but unlike a premise, it does not support the conclusion.</li></ul><p><strong>This sentence supports the first sentence, the premise that notes that productivity has dropped.</strong></p><h2 id="Identification"><a href="#Identification" class="headerlink" title="Identification"></a>Identification</h2><p>Identifying premises and conclusions is a very important <code>critical thinking skill</code> in general, also required for LSAT (a law exam).</p><p><strong>For example:</strong> (「because」is an 「indicator word」)</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xi9qn.jpg"></p><p><strong>Why is it easy to know?</strong></p><p>Because we <code>read for the argument</code>: what claims are we being asked to believe or accept, what other claims are being offered as reasons to accept that claim.</p><p><strong>Keywords that indicate a <code>conclusion</code>:</strong></p><ul><li>therefore</li><li>so</li><li>hence</li><li>thus</li><li>it follows that &#x3D; 由此得出结论</li><li>as a result</li><li>consequently</li><li>clearly</li></ul><p><strong>Keywords that indicate a <code>premise</code>:</strong></p><ul><li>since</li><li>if</li><li>because</li><li>from which it follows</li><li>for these reasons</li></ul><p><strong>However</strong>, sometimes there is no indicator:</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/zofep.jpg"></p><p><strong>Way to identify:</strong> <code>ask yourself</code>, is the main point that the arguer is trying to convey, or is it to put forward to believe another claim?</p><h2 id="A-Good-Argument"><a href="#A-Good-Argument" class="headerlink" title="A Good Argument"></a>A Good Argument</h2><p>An argument that gives us good reasons to believe the conclusion.</p><p><strong>Two types of bad arguments:</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/p364r.jpg" title="False Premise, Good Logic"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wnd50.jpg" title="True Premises, Bad Logic"></p><p><strong>Necessary conditions for an argument to be good:</strong></p><ol><li>All the premises must be true.  (Truth Condition)</li><li>The conclusion must follow from the premises.  (Logic Condition)</li></ol><p><strong>Notice that</strong> they are not <code>sufficient conditions</code>. Arguments may fail to be good still.</p><h3 id="The-Truth-Plausibility-Condition"><a href="#The-Truth-Plausibility-Condition" class="headerlink" title="The Truth (Plausibility) Condition"></a>The Truth (Plausibility) Condition</h3><blockquote><p>All premises must be true.</p></blockquote><p>The statement may be <strong>problematic</strong>, instead we should use <code>plausible</code> rather than <code>true</code>.</p><p><strong>Eg:</strong> “The Earth rotates on its axis once every 24 hours.”</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ghtui.jpg"></p><p>It does not allow us to acknowledge that the medievals had good arguments.</p><p>All premises must be plausible. ⇔ X is regarded by <code>a given audience</code> as true (They have good reasons to think it true).</p><p>Therefore, an arguer is trying to make premises plausible to the intended audience. It’s them who decide whether those premises are true.</p><p><strong>Objection:</strong> subjectivism vs. relativism</p><p>We can still use 「true」 or 「false」, but they don’t play a role in a real world argument.</p><h3 id="The-Logic-Condition"><a href="#The-Logic-Condition" class="headerlink" title="The Logic Condition"></a>The Logic Condition</h3><p>The conclusion follows from the premises. ⇔ The premises support the conclusion.</p><p><strong>Notice:</strong> Two conditions are focusing <code>two different properties</code> of an argument. When evaluating the logic of an argument, we’re not interested in whether the premises are actually true or false. We have a <code>hypothetical</code>. 👉 “if premises are assumedly true”</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/w7stp.jpg"></p><p><strong>Two forms that satisfy the Logic Condition:</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/g25wd.jpg"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ei11p.jpg"></p><p><strong>Argument analysis</strong> is a <code>two-stage</code> process. The actual truth or falsity of the premises is irrelevant to the logic of the argument. They are <code>independently</code> considered.</p><h2 id="Validity-Strength"><a href="#Validity-Strength" class="headerlink" title="Validity &amp; Strength"></a>Validity &amp; Strength</h2><p><strong>Two different ways an argument can satisfy the logic condition:</strong></p><ul><li>Valid (Validity)</li><li>Strong (Strength)</li></ul><h3 id="Validity"><a href="#Validity" class="headerlink" title="Validity"></a>Validity</h3><p><strong>An argument is valid if it has the following property:</strong></p><ul><li>If all the premises are true, the conclusion <code>cannot be false</code>.</li><li>It is <code>logically impossible</code> for the premises to be true and the conclusion false.</li><li>The truth of the premises <code>guarantees</code> the truth of the conclusion.</li></ul><p><strong>An argument is invalid if it has the following property:</strong></p><ul><li>If all the premises are true, the conclusion <code>can be false</code>.</li><li>It is <code>logically possible</code> for the premises to be true and the conclusion false.</li><li>The truth of the premises does <code>not guarantees</code> the truth of the conclusion.</li></ul><p>But, an invalid argument doesn’t imply that the argument is bad. <code>Invalid arguments can still be good arguments</code>, because they can still give us good reasons to believe the conclusion. (Still satisfy the Logic Condition)</p><p><strong>An important point to remember about the terminology:</strong></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/372kl.jpg"></p><p>Eg, The premise is invalid.</p><h3 id="Strength"><a href="#Strength" class="headerlink" title="Strength"></a>Strength</h3><p>Premises make it <code>very likely</code> that satisfy the Logic Condition: (Strong)</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0cnbn.jpg" title="A Strong Argument"></p><p><strong>Remember that</strong> <code>Satisfy the Logic Condition</code> is <code>Premises offer good (not perfect) reasons</code>.</p><p>Not satisfy the Logic Condition: (Weak)</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/a7tef.jpg" title="A Weak Argument"></p><p><strong>Note that</strong>, Valid vs. Invalid is <code>a sharp one</code>. Strong vs. Weak has <code>no cut-off</code>.</p><blockquote><p>Validity is like pregnancy 「cool」</p></blockquote><p>The <code>threshold</code> is determined by conventional choice, not by logic.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0926m.jpg" title="Common Forms"></p><p><strong>So, what is a Good Argument?</strong></p><p><strong>First Pass.</strong> If an argument is good then:</p><ol><li>it has all true premises</li><li>the conclusion follows from the premises (satisfy the Logic Condition)</li></ol><p><strong>Second Pass.</strong> if an argument is good then:</p><ol><li>it has all plausible premises</li><li>it is either valid or strong</li></ol><h2 id="Deductive-Inductive"><a href="#Deductive-Inductive" class="headerlink" title="Deductive &amp; Inductive"></a>Deductive &amp; Inductive</h2><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/75p83.jpg" title="Deductive Argument"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/6mu2o.jpg" title="Inductive Argument"></p><p>Reference: <a href="https://www.youtube.com/watch?v=Nq8-w2BAJkU&index=1&list=PLB8A5292FC68E2D77">What is an argument?</a></p><blockquote><p>If there is any infringement on your rights, please don’t hesitate to inform for deletion.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
            <tag> 英语 </tag>
            
            <tag> 逻辑 </tag>
            
            <tag> Argument </tag>
            
            <tag> Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大学之路》读书笔记</title>
      <link href="/2016/08/01/011_%E3%80%8A%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/08/01/011_%E3%80%8A%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一所好的大学，应该扮演四个角色。首先，它是培养人才的地方，将那些有潜力有志向的年轻人培养成对未来社会有所贡献的人；第二，它是一个研究的中心，引领世界科技的发展，并且会对一个国家、一个地区产生积极正面的影响；第三，它是一个新思想、新文化的发源地，能推动社会的进步；第四，它是年轻人的家，是他们度过人生最好时光的地方。</p></blockquote><span id="more"></span><h2 id="序一-我们需要什么样的大学-俞敏洪"><a href="#序一-我们需要什么样的大学-俞敏洪" class="headerlink" title="序一 | 我们需要什么样的大学 俞敏洪"></a>序一 | 我们需要什么样的大学 俞敏洪</h2><ul><li><p>真正的人，就是八个字，第一真实，第二善良，第三健康，第四快乐。</p></li><li><p>一个只懂得向学生灌输课程的大学充其量算得上三流，而那些能够点燃青年学生内心火焰的大学才真正称得上一流。</p></li><li><p>实践证明，没有好的通识教育，一个人的事业发展就不会有后劲。</p></li><li><p>大学不仅要有大师，还要有大楼（好的硬件条件），否则大师的教育理念就无法落地生根。</p></li><li><p>为什么我们不仅要上大学，还要努力上名校不可？原因很简单，要与优秀的人同行。</p></li></ul><h2 id="序二-培养终身学习的能力-Robert-J-Spiller"><a href="#序二-培养终身学习的能力-Robert-J-Spiller" class="headerlink" title="序二 | 培养终身学习的能力 Robert J. Spiller"></a>序二 | 培养终身学习的能力 Robert J. Spiller</h2><ul><li>To educate its students and cultivate their capacity for lifelong learning, to foster independent and original research, and to bring the benefits of discovery to the world.</li></ul><h2 id="前言-教育是一辈子的事情"><a href="#前言-教育是一辈子的事情" class="headerlink" title="前言 | 教育是一辈子的事情"></a>前言 | 教育是一辈子的事情</h2><ul><li><p>美国人和亚洲人有着不尽相同的教育理念，一种是出于兴趣而学习，另一种则是为了很现实的利益而学习。</p></li><li><p>遗憾的是，人生是场马拉松，拿到一所名牌大学的烫金毕业证书，不过是在马拉松赛跑种取得了一个还不错的站位而已，人生——这所真正的大学——路途才刚刚开始。</p></li><li><p>但其实，成功的道路并不像想象得那么拥挤，在人生的马拉松长路上，绝大部分人跑不到一半就主动退下来了。</p></li><li><p>教育是一辈子的事情，笑到最后的人是一辈子接受教育的人。</p></li><li><p>我在本科学习的课程大部分不仅对工作没有用，而且对后来学习专业课也没有用。</p></li><li><p>当你们大学毕业后，你们的同伴大部分不会再坚持学习了，只要那时候你们还在不断地完善自己，你们就能赶上并超过别人。</p></li><li><p>为了保证通才教育，大学不应该限制学生的专业，至少要允许学生换专业。</p></li><li><p>今天，中国的学生一进入高中就开始专攻那些高考必考的课程，而一进入大学，他们就被限制在不允许修改的专业中，这不仅失去了得到通才教育的机会，甚至被剥夺了培养自己学习兴趣的可能。我真的为他们感到悲哀。</p></li><li><p>有了好的通才教育基础和专业知识技能，一个人能走多远，取决于两点，即他服务于社会的意愿以及对所从事事业的喜爱程度。</p></li></ul><h2 id="第一章-大学的概念"><a href="#第一章-大学的概念" class="headerlink" title="第一章 | 大学的概念"></a>第一章 | 大学的概念</h2><ul><li><p>美国的大学一般没有因为成绩不好而主动开除学生的，大部分拿不到文凭的人时自己主动退学的。</p></li><li><p>1170年，一所重要的大学在巴黎成立，这就是巴黎大学。这所大学不仅成为了欧洲最著名的大学之一，还成为了欧洲两所最著名的有“大学之母”美称的大学。</p></li><li><p>中国的大学在起步的时候，官办的味道就已经很浓，并不具备上述特点。</p></li><li><p>一个工科大学发展的好坏，常常取决于它们有多么务实。</p></li><li><p>今天大学在学生教育上的水平，需要20年后来考察。我们常讲十年树木，百年树人，而一个学校通过树人来获得名声，则需要更长的时间。</p></li><li><p>一所大学能否让学生生活得开心，并且因此而激发出学生一辈子学习的热情，是衡量一所大学好坏的重要标准。</p></li><li><p>成功的大学经历应该是这样的：当一个学生从某一所知名大学毕业后，他不需要再把母校的名字天天挂在嘴边；当一个学生从一所二三流大学毕业后，那所学校今后会因为曾经出了这样一个学生而自豪。</p></li></ul><h2 id="第二章-两类大学，两种高等教育"><a href="#第二章-两类大学，两种高等教育" class="headerlink" title="第二章 | 两类大学，两种高等教育"></a>第二章 | 两类大学，两种高等教育</h2><ul><li><p>纽曼式的大学（Newman）和洪堡体系（Humboldt）  </p></li><li><p>兼顾两种教育理念的第三个难点在于社会上很多人不觉得有这个必要性。</p></li><li><p>很多从中国来的小留学生，靠家里有点钱，为了出国而出国，在美国找个三流大学读完了本科，毕业后不仅在美国找不到工作，而且回到中国也找不到理想的职位，其中一个重要的原因就是在美国读本科时受的专业训练非常少。</p></li><li><p>在美国，取得硕士和博士学位的难度有天囊之别，不到美国大学里走一遭是无法理解这一点的。</p></li><li><p>硕士要学会使用知识，博士要能创造知识。</p></li><li><p>各个大学对硕士申请者的态度是，只要你达到录取的基本要求，就一定录取，而对大部分专业的博士申请者来讲，则是要看科研经费能养得起多少人。</p></li></ul><h2 id="第三章-我的大学经历（这章必须看啊！）"><a href="#第三章-我的大学经历（这章必须看啊！）" class="headerlink" title="第三章 | 我的大学经历（这章必须看啊！）"></a>第三章 | 我的大学经历（这章必须看啊！）</h2><ul><li><p>我观察了班上几个成绩比较好的同学的做法,发现他们比我用功得多,于是我开始抓紧时间,主要是抓紧一般人不太在意的五分钟、十分钟时间。这样，一天下来，可以挤出半小时左右的时间，一周下来，学习的时间就多了不少。</p></li><li><p>年轻人在读书之余，似乎也应该尽情地玩耍。</p></li><li><p>我很少获得什么荣誉，但是，这是我喜欢的方式。</p></li><li><p>年轻人有一种模仿和学习他人的本能，若能对此善加引导，那么他们就能很好地成长。</p></li><li><p>在做研究的阶段，好的导师比好的学校更重要。</p></li><li><p>人在成功时，并不会因为这件事的发生而一夜之间变成了一个更好的人，在遇到挫折时，也不会因此而一夜之间就变得一无是处。</p></li><li><p>本科生应该去那些经得住时间检验的著名学校。而对于硕士生来讲，则要找一个好的城市，因为那里的机会要比偏远落后地区多得多。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>究竟用 LinkedList L 还是 LinkedList *L？</title>
      <link href="/2016/07/31/008_%E7%A9%B6%E7%AB%9F%E7%94%A8LinkedList%20L%E8%BF%98%E6%98%AFLinkedList%20*L%EF%BC%9F/"/>
      <url>/2016/07/31/008_%E7%A9%B6%E7%AB%9F%E7%94%A8LinkedList%20L%E8%BF%98%E6%98%AFLinkedList%20*L%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>C 语言的学习总是遇到各种问题，而且很多问题几乎离不开指针这鬼玩意。在学习数据结构与算法之蜜汁 C 语言版的时候，我也是被 LinkedList 这个东西弄得心累啊！</p><p>毕竟后面发现严蔚敏版的教材的代码应该是遵循 C++ 风格（我还没学过），里面充斥着<code>LinkedList &amp;L</code>这种写法。然后，每次将代码 copy 到编辑器后，一编译就泪流满面。事实上，<code>LinkedList &amp;L</code>是 C++ 的一种引用语法。</p><p>其实在参数中究竟用哪一种不重要，关键是知道<strong>自己在做什么（换句话说就是为什么要用它）？</strong></p><span id="more"></span><p>接下来有必要先说一下链表的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *LinkedList;</span><br></pre></td></tr></table></figure><p>如上，需要注意的地方是 LinkedList 的身份是什么。在这里，<code>*LinkedList</code>等同于<code>struct Node</code>，换句话说，<code>LinkedList</code>等同于<code>struct Node *</code>，它是一个指向结构体<code>Node</code>的指针！接着，我们要清楚，<code>LinkedList *L</code>就是指向结构体<code>Node</code>的指针的指针了！</p><ul><li><p>对于<code>LinkedList L</code>: L 是指向定义的 Node 结构体的指针，可以用<code>-&gt;</code>运算符来访问结构体成员，即<code>L-&gt;data</code>，而<code>*L</code>就是个 Node 型的结构体了，可以用点运算符访问该结构体成员，即<code>(*L).data</code>。</p></li><li><p>对于<code>LinkedList *L</code>: L 是指向定义的 Node 结构体指针的指针，所以<code>*L</code>是指向 Node 结构体的指针，可以用<code>-&gt;</code>运算符来访问结构体成员，即<code>(*L)-&gt;data</code>，当然，<code>**L</code>就是 Node 型结构体了，所以可以用点运算符来访问结构体成员，即<code>(**L).data</code>。</p></li></ul><p>在链表操作中，我们常常要用链表变量作为函数的参数。这时，用<code>LinkedList L</code>还是<code>LinkedList *L</code>就很值得考虑深究了，一个用不好，函数就会出现逻辑错误。</p><p><strong>其准则是：</strong>如果函数会改变指针 L 的值，而你希望函数结束调用后保存 L 的值，那你就要用<code>LinkedList *L</code>。这样，向函数传递的就是指针的地址，结束调用后，自然就可以去改变指针的值；而如果函数只会修改指针所指向的内容，而不会更改指针的值，那么用<code>LinkedList L</code>就行了。</p><p>这里大家可能有点懵，我觉得关键在于<strong>理解C语言函数参数传递的原理！本质是值传递</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getReturn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数外部是得不到 a 变化为 10 的结果的，<strong>因为 a 在传进函数的时候被复制了一次，虽然两个 a 的内容相同，但是它们已经是两个不同的变量了！</strong>为了得到这个结果你需要使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getReturn</span><span class="params">(<span class="type">int</span> *a)</span> &#123;</span><br><span class="line">  *a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getReturn(&amp;a);</span></span><br></pre></td></tr></table></figure><p>最后，结合具体实例来进一步理解下如上所有内容：</p><p><strong>重点：</strong>当传进的变量的<code>值</code>被改变时需要用指针。</p><ol><li><p>初始化链表 InitList</p><p> <code>malloc</code>返回一个地址。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想想如果用 InitList(LinkedList L) 会怎么样？</span></span><br><span class="line"><span class="comment">// void InitList(LinkedList L) &#123;</span></span><br><span class="line"><span class="comment">//   L = (LinkedList) malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">//   L-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// L 在传进去的时候已经被复制了一遍，已不是函数外面那个指针变量。</span></span><br><span class="line"><span class="comment">// 所以改变它的值不会改变外面那个指针变量的指</span></span><br><span class="line"><span class="comment">// 这种情况只适用于结构体已经在外面被初始化，并且通过 InitList 改变它的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkedList *L)</span> &#123;</span><br><span class="line">  *L = (LinkedList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 函数调用完毕后，L 会指向一个空的链表，即会改变指针的值，所以要用<code>LinkedList *L</code>。</p></li><li><p>清空链表 ClearList</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传进去的是头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(LinkedList L)</span> &#123;</span><br><span class="line">  LinkedList p;</span><br><span class="line">  <span class="keyword">while</span>(p = L-&gt;next)</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 函数调用完后不会改变指针 L 的值，只会改变指针 L 所指向的内容（即<code>L-&gt;next</code>的值），所以可以用<code>LinkedList L</code>。</p></li><li><p>销毁链表 DestroyList</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点也需要被回收</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkedList *L)</span> &#123;</span><br><span class="line">  LinkedList p;</span><br><span class="line">  <span class="keyword">while</span>(p = (*L)-&gt;next)</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">free</span>(*L);</span><br><span class="line">  *L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 释放链表 L 申请的内存，使 L 的值重新变为 NULL，所以会改变 L 的值，得用<code>LinkedList *L</code>。</p></li></ol><p>最后，大家可能会遇到这个问题，what about <code>Insert</code>？这个是一个值得深思的问题呵呵！目前，我觉得在带有头结点上使用<code>LinkedList L</code>也是可以的。在没有头结点的时候，如果还是使用<code>LinkedList L</code>就可能有问题，因为我们可能会在第一个结点前插入新结点呢！所以，我也是一脸懵逼啊，可能大伙们都在遵循<strong>潜在规则</strong>吗？</p><p><strong>潜在规则：</strong>访问用<code>LinkedList L</code>，修改用<code>LinkedList *L</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次接触到神奇的人工神经网络</title>
      <link href="/2016/07/14/016_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8E%A5%E8%A7%A6%E5%88%B0%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2016/07/14/016_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8E%A5%E8%A7%A6%E5%88%B0%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>一开始听到“人工神经网络”这个词的时候就觉得好方，毕竟想到人脑的结构那么复杂，第一反应肯定是人工神经网络肯定非常高深。然后就没有然后了，因为觉得它好难就没有“信仰”去了解它了。之后，在看《数学之美》中，吴军博士在讲解Google大脑时，特地讲解了一下什么是人工神经网络，同时他还指出了它并没有想象中那么高深。<span id="more"></span>以下是他的原话：</p><blockquote><p>如果有幸遇到一个好心同时又善于表达的科学家或教授，他愿意花一两个小时的时间，深入浅出地为你讲解人工神经网络的底细，你就会发现，“哦，原来是这么回事”。</p></blockquote><p>其实，除了生物学上的一些名词和一些形象的比喻外，<em><strong>人工神经网络就是一种有向图</strong></em>，和人脑没有半点关系。在这种有向图里面，节点被称为<em><strong>神经元</strong></em>，有向弧则被成为连接每各个节点的<em><strong>神经</strong></em>。</p><p>然而，它也不是一般的有向图，因为它具有以下一些特征：</p><ul><li>这种有向图中的所有节点都是<em><strong>分层的</strong></em>，每一层的节点可以通过有向弧指向上一层的节点。注意，同一层的节点之间没有弧互相连接，而且每一个节点不能跨越一层连接到上上层的节点。<em><strong>在实际应用中，人们一般不会设计超过五层的网络，因为其计算会愈加复杂</strong></em>。</li></ul><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/48dlf.jpg" alt="典型的三层人工神经网络"></p><ul><li><p><em><strong>每一条弧上有一个权值</strong></em>。根据这些权值，可以计算某条弧所指向节点的值。</p></li><li><p>有时，最下面那一层节点被称为<em><strong>输入层</strong></em>，最上面的节点被称为<em><strong>输出层</strong></em>。除了输入层的节点外，各节点都是通过这些输入层的节点的输入值直接或者间接得到的。中间层的节点也可以称作<em><strong>隐含层</strong></em>。</p></li></ul><p>在了解如何应用人工神经网络前，我们先看一下<em><strong>模式分类</strong></em>。</p><p>假设在一个二维空间中，我们要区分两个元音<em><strong>a</strong></em>和<em><strong>e</strong></em>，它们的分布如图所示。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/smykv.jpg" alt="a和e的模式分布图"></p><p>模式分类的任务就是要在这个空间中切一刀，将a和e区分开来。之后，每当有新的语音进来，落到左边我们就将它识别成a，落在右边则识别成e。</p><p>现在可以用一个人工神经网络来实现这个简单的分类器（虚线），该结构如下：</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vgp58.jpg" alt="简单的人工神经网络"></p><p>在这个人工神经网络中，我们有<em><strong>两个输入节点X1和X2，一个输出节点Y</strong></em>。根据给定的权重，我们将Y这一点上的数值设定为两个输入节点数值x1和x2的一种线性组合，即<code>y = 3x1 - x2 - 2</code>。<em><strong>w0（即-2）是一个常数项</strong></em>，为了后面可以方便地进行判断。</p><p>现在将平面上的一些点<code>(0.5,1)、(2,2)、(1,-1)、(-1,-1)</code>的坐标输入到第一层的两个节点上，然后通过该网络得出对应的输出值y。</p><ul><li><p><code>(0.5,1)</code> 输出 -1.5</p></li><li><p><code>(2,2)</code> 输出 2</p></li><li><p><code>(1,-1)</code> 输出 2</p></li><li><p><code>(-1,-1)</code> 输出 -4</p></li></ul><p>现在，如果输出值y大于零，那么可以说这个节点属于第一类e，反之则属于第二类a。</p><p>最后，我们也可以把这个神经网络中的Y变成中间节点S，增加一个更明显的输出层，包括节点Y1和Y2。</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gcihr.jpg" alt="改进后的人工神经网络"></p><p>这样我们只需要比较输出节点的值谁大，我们就认为这个点应该属于相应的哪一类。</p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《如何阅读一本书》读书笔记</title>
      <link href="/2016/07/12/013_%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/07/12/013_%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ul><li><p>过去三十年来，有些事情还是没有改变。其中一项是：要达到阅读的所有目的，就必须在阅读不同书籍的时候，运用适当的不同速度。不是所有的书都可以用最快的速度来阅读。法国学者Pascal在三百年前就说过：“读得太快或太慢，都一无所获。”</p><span id="more"></span><p>  <em><strong>像我这种读书这么慢的人简直听到了福音!</strong></em></p></li><li><p>中学毕业的时候，学生都读过不少书了。但如果他要继续念大学，那就得还要念更多的书，不过这个时候他却很可能像是一个可怜而根本不懂阅读的人。</p></li></ul><h2 id="第一章-阅读的活力与艺术"><a href="#第一章-阅读的活力与艺术" class="headerlink" title="第一章 阅读的活力与艺术"></a>第一章 阅读的活力与艺术</h2><ul><li><p>换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。</p><p>  <em><strong>刷微博？</strong></em></p></li><li><p>第一提醒读者，阅读可以是一件多少主动的事。第二要指出的是，阅读越主动，效果越好。</p></li><li><p>你什么都没有，只凭着内心的力量，玩味着眼前的字句，慢慢地提升自己，从只有模糊的概念到更清楚地理解为止。这种的一种提升，是在阅读时的一种脑力活动，也是更高的阅读技巧。这种阅读就是让一本书向你既有的理解力做挑战。</p></li><li><p>总有一些书呆子读得太广，却读不通。希腊人给这种集阅读与愚蠢于一身的人一种特别的称呼，这也可运用在任何年纪、好读书却读不懂的人身上。他们叫“半瓶醋”（Sophomores）。</p></li></ul><h2 id="第二章-阅读的层次"><a href="#第二章-阅读的层次" class="headerlink" title="第二章 阅读的层次"></a>第二章 阅读的层次</h2><ul><li><p>阅读分为四种层次：</p><ul><li><p>基础阅读（Elementary Reading）</p></li><li><p>检视阅读（Inspectional Reading）</p></li><li><p>分析阅读（Analytical Reading）</p></li><li><p>主题阅读（Syntopical Reading），也可叫做比较阅读（Comparative Reading）</p></li></ul></li><li><p>弗兰西斯·培根曾经说过：“有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。”分析阅读就是要咀嚼与消化一本书。</p></li></ul><h2 id="第三章-基础阅读"><a href="#第三章-基础阅读" class="headerlink" title="第三章 基础阅读"></a>第三章 基础阅读</h2><ul><li><p>官方宣称1970年代是“读书的年代”。</p></li><li><p>在美国，批判学校是一种传统。许多世纪依赖，父母、自命专家的人与教育者都在攻击与控诉教育系统。其中阅读教育受到最严厉的批评。</p></li><li><p>传统上，美国的高中教育只为学生提供一点点阅读的指导，至于大学，更是一无所有。</p><p>  <em><strong>大学老师根本就不会教你怎么去阅读</strong></em></p></li><li><p>一个人文素质优良的高中，就算什么也没做，也该培养出能达到分析阅读的读者。一个优秀的大学，就算什么也没贡献，也该培育出能进行主题阅读的读者。</p><p>  <em><strong>所以在大学有很多事可以做，不只是出去浪吧。一个会玩的人应该静得下来读一下书，然后有所体会。</strong></em></p></li><li><p>我们的历史一直强调，无限制的受教育机会是一个社会能提供给人民最有价值的服务。</p><p>  <em><strong>论教育者的良苦用心</strong></em></p></li></ul><h2 id="第四章-检视阅读"><a href="#第四章-检视阅读" class="headerlink" title="第四章 检视阅读"></a>第四章 检视阅读</h2><ul><li><p>目录纲要还是很有价值的，在你开始阅读整本书之前，你应该先仔细阅读目录才对。</p><p>  <em><strong>在这点上觉得自己做的不错的！</strong></em></p></li><li><p>最后一步（即略读），把书打开来，东翻翻西翻翻，念个一两段，有时候连续读几页码，但不要太多。就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。最重要的是，不要忽略最后的两三页。就算最后有后记，一本书最后结尾的两三页也还是不可忽视的。</p></li><li><p>随时保持敏感，就很容易让一切状况清楚。</p></li><li><p>什么叫对的方向？答案是一个很重要又有帮助的阅读规则，但却经常被忽略。这个规则很简单：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索。</p><p>  <em><strong>这个答案蜜汁关键！特别是在阅读英文原版小说的时候。</strong></em></p></li><li><p>我们大多数人所受的教育，都说是要去注意那些我们不懂的地方。我们被教导说，碰到生字，就去查字典。</p></li><li><p>超快的速度法是引人怀疑的一种成就，那只是表现你在阅读一种根本不值得读的读物。更好的秘方是：在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。</p></li></ul><h2 id="第五章-如何做一个自我要求的读者"><a href="#第五章-如何做一个自我要求的读者" class="headerlink" title="第五章 如何做一个自我要求的读者"></a>第五章 如何做一个自我要求的读者</h2><ul><li><p>到底是什么力量，能让那些秉烛夜读的人仍然保持清醒？起码有一点是可以确定的——他们有没有真正在阅读手中的那本书，造成了其间的差异，而且是极大的差异。</p></li><li><p>俗话说：“你必须读出言外之意，才会有更大的收获。”</p></li><li><p>顺便一提，并不是每个人都清楚做一个艺术家是要照规则不断练习的。</p></li><li><p>阅读就像滑雪一样，做得很好的时候，就像一个专家在做的时候，滑雪跟阅读一样都是很优美又和谐的一种活动。</p><p>  <em><strong>说得我很想滑雪…</strong></em></p></li></ul><h2 id="第六章-分析阅读-一本书的分类"><a href="#第六章-分析阅读-一本书的分类" class="headerlink" title="第六章 分析阅读 一本书的分类"></a>第六章 分析阅读 一本书的分类</h2><ul><li><p>在英文里，人们常常弄混《物种起源》（The Origin of Species）和《人种起源》（The Origin of the Species）。因为他们没有真的用心读过书名。</p></li><li><p>一本实用的书会很快就显露它的特质，因为它经常会出现“应该”和“应当”、“好”和“坏”、“结果”和“意义”之类的字眼。</p></li><li><p>哲学比较像科学，不像历史，追求的是一般的真理，而非发生在过去的特定事件，不管那个过去事近代或较远的年代。但是哲学家所提出的问题跟科学家又不一样，解决问题的方法也不相同。</p></li></ul><h2 id="第七章-透视一本书"><a href="#第七章-透视一本书" class="headerlink" title="第七章 透视一本书"></a>第七章 透视一本书</h2><ul><li><p>一本书出现在你面前时，肌肉包着骨头，衣服裹着肌肉，可说是盛装而来。你用不着揭开它的外衣，或是撕去它的肌肉，才能得到在柔软表皮下的那套骨架。但是你一定要用一双X光般的透视眼来看这本书，因为那是你了解一本书，掌握其骨架的基础。</p></li><li><p>最好的书都有最睿智的架构.</p></li><li><p>分析阅读的第一阶段，或，找出一本书在谈些什么的四个规则：</p><ol><li><p>依照书本的种类与主题作分类。</p></li><li><p>用最简短的句子说出整本书在谈些什么。</p></li><li><p>按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。</p></li><li><p>找出作者在问得问题，或作者想要解决的问题。</p></li></ol></li></ul><h2 id="第八章-与作者找出共通的词义"><a href="#第八章-与作者找出共通的词义" class="headerlink" title="第八章 与作者找出共通的词义"></a>第八章 与作者找出共通的词义</h2><ul><li><p>大多数读者的问题，在于他们根本就不太注意文字，找不出他们的困难点。他们区分不出自己很明白的字眼与不太明白的字眼。</p></li><li><p>事实上，一本书之所以能给你带来新的洞察力或启发，就是因为其中有一些你不能一读即懂得字句。</p></li><li><p>只要你肯花一点精神，在读一本书的时候，找出重要的关键字，确认每个字不同意义的转换，并与作者找出共通的词义，你对一本书的理解力就会大大增加了。</p></li></ul><h2 id="第九章-判断作者的主旨"><a href="#第九章-判断作者的主旨" class="headerlink" title="第九章 判断作者的主旨"></a>第九章 判断作者的主旨</h2><ul><li><p>句子与段落是文法的单位、语言的单位。主旨与论述是逻辑的单位，也就是思想与知识的单位。</p></li><li><p>找出关键字，与作者达成共识。</p></li><li><p>将一本书种最重要的句子圈出来，找出其中的主旨。</p></li><li><p>从相关文句的关联中，设法架构出一本书的基本论述。</p></li><li><p>怀疑是智慧的开始，从本书上学习跟从大自然学习是一样的。</p></li><li><p>虽然有过一些失望的经验，我们仍然相信，人类头脑看到论述时之敏感，一如眼睛看到色彩时的反应。但是如果眼睛没有张开，就看不到色彩。头脑如果没有警觉，就无法察觉论述出现在哪里了。</p></li><li><p>“用你自己的话来说”，是测验你懂不懂一个句子的主旨的最佳方法。</p></li><li><p>口语主义（verbalism）的弊端，可以说是一种使用文字，没有体会其中的思想传达，或没有注意到其中意指的经验的坏习惯。那只是在玩弄文字。</p></li><li><p>诠释作品的阅读技巧的最后一部分就是：规则八，找出作者的解答。</p></li></ul><h2 id="第十章-公正地评断一本书"><a href="#第十章-公正地评断一本书" class="headerlink" title="第十章 公正地评断一本书"></a>第十章 公正地评断一本书</h2><ul><li><p>事实上，读者才是最后一个说话的人。</p></li><li><p>读者有义务，也有机会回话。机会很明显。没有任何事能阻碍一个读者发表自己的评论。无论如何，在读者与书本之间的关系的本质种，有更深一层的义务关系。</p></li><li><p>最能学习的读者，也就是最能批评的读者。</p></li><li><p>站在叙述者或作者的角度来看，修辞就是要知道如何去说服对方。</p></li><li><p>你自己就可能记得这样的例子：一个人在台上讲话，台下的人一口气或最多两口气就冒出来：“我不知道你在说说明，但我想你错了。”对于这样的批评，根本不知从何答起。</p></li><li><p>如果你在读一本好书，在你说出“我懂了”之前，最好迟疑以下。在你诚实又自信地说出这句话之前，你有一堆工作要做呢！</p></li><li><p>为了追求真理，要毁掉一些我们内心最亲近的食物，尤其像我们这样的哲学家或热爱智慧的人更是如此。</p></li></ul><h2 id="第十一章-赞同或反对作者"><a href="#第十一章-赞同或反对作者" class="headerlink" title="第十一章 赞同或反对作者"></a>第十一章 赞同或反对作者</h2><ul><li><p>事实上，诠释一本书的过程是透过言语的媒介，达到心灵上的沟通。</p></li><li><p>因为人有理性的一面，又有动物的一面，所以在争辩时就要注意你会带进去的情绪，或是在当场引发的脾气。</p></li><li><p>在争论时应该多一点理性的光，少一点激情的热，每个参与辩论的人至少都该从对方的立场来着想。</p></li><li><p>一个读得很广泛，却读不精的人，与其值得赞美，不如值得同情。就像霍布斯所说：“如果我像一般人一样读那么多书，我就跟他们一样愚蠢了。”</p></li></ul><h2 id="第十二章-辅助阅读"><a href="#第十二章-辅助阅读" class="headerlink" title="第十二章 辅助阅读"></a>第十二章 辅助阅读</h2><ul><li><p>阅读一本书时，另一只手上还拿着一本字典，其实是个坏主意。</p></li><li><p>性爱也不是每个人都有的经验，但是这是个共通的经验，因此我们称这个经验为一般经验。</p></li></ul><h2 id="第十三章-如何阅读实用型的书"><a href="#第十三章-如何阅读实用型的书" class="headerlink" title="第十三章 如何阅读实用型的书"></a>第十三章 如何阅读实用型的书</h2><ul><li>关于实用性的书有一件事要牢记在心：在任何实用性的书都不能解决该书所关心的实际问题。一本理论性的作品可以解决自己提出的问题。</li></ul><h2 id="第十四章-如何阅读想象文学"><a href="#第十四章-如何阅读想象文学" class="headerlink" title="第十四章 如何阅读想象文学"></a>第十四章 如何阅读想象文学</h2><ul><li>诗与政治对正确的标准时不一致的。</li></ul><h2 id="第十五章-阅读故事、戏剧与诗的一些建议"><a href="#第十五章-阅读故事、戏剧与诗的一些建议" class="headerlink" title="第十五章 阅读故事、戏剧与诗的一些建议"></a>第十五章 阅读故事、戏剧与诗的一些建议</h2><ul><li>阅读抒情诗的第二个规则是：重读一遍——大声读出来。</li></ul><h2 id="第十六章-如何阅读历史书"><a href="#第十六章-如何阅读历史书" class="headerlink" title="第十六章 如何阅读历史书"></a>第十六章 如何阅读历史书</h2><ul><li><p>一个好的历史学家是不会编造过去的。</p></li><li><p>就阅读这类书而言，整理一堆“规则”还比不上归纳为一句警告。</p></li></ul><h2 id="第十七章-如何阅读科学与数学"><a href="#第十七章-如何阅读科学与数学" class="headerlink" title="第十七章 如何阅读科学与数学"></a>第十七章 如何阅读科学与数学</h2><ul><li>有能力的人，就去做。没有能力的人，就去教。</li></ul><h2 id="第二十章-阅读的第四个层次：主题阅读"><a href="#第二十章-阅读的第四个层次：主题阅读" class="headerlink" title="第二十章 阅读的第四个层次：主题阅读"></a>第二十章 阅读的第四个层次：主题阅读</h2><ul><li>石头是爱，因为它是地球的中心。火焰会上扬，是因为爱得功能。铁刀会吸引磁铁，被形容为爱的结果。</li></ul><p><a href="https://book.douban.com/subject/1013208/">《如何阅读一本书》豆瓣地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学会这些简单语法来用Markdown做笔记</title>
      <link href="/2016/07/11/012_%E5%AD%A6%E4%BC%9A%E8%BF%99%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E6%9D%A5%E7%94%A8Markdown%E5%81%9A%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/07/11/012_%E5%AD%A6%E4%BC%9A%E8%BF%99%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E6%9D%A5%E7%94%A8Markdown%E5%81%9A%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Markdown？"><a href="#什么是Markdown？" class="headerlink" title="什么是Markdown？"></a>什么是Markdown？</h2><p>Markdown是一种<em><strong>轻量级标记语言</strong></em>，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。它允许人们“使用<em><strong>易读易写</strong></em>的纯文本格式编写文档，然后转换成有效的HTML(或者XHTML)文档”。</p><span id="more"></span><p>比如你用以下Markdown语法来做笔记，</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/88kd1.jpg"></p><p>在浏览器或者Markdown预览工具中，你可以得到这样的效果：<br><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/e1a2m.jpg"></p><p>是不是很神奇的？接下来我给大家介绍一些常用的简单语法，大家花一点时间用它来做一下笔记就可以入门了！</p><p>噢，对了！至于说Markdown可以用来干什么，对我而言，我暂时用它来<em><strong>写博客、写README.md、做笔记</strong></em>。其实，它还有其他用处的。</p><h2 id="标题设置"><a href="#标题设置" class="headerlink" title="标题设置"></a>标题设置</h2><p>在Markdown中设置标题，有两种方法：</p><ul><li>通过在文字下方添加<code>=</code>和<code>-</code>，它们分别表示一级标题和二级标题</li><li>在文字开头加上<code>#</code>，通过<code>#</code>的数量表示几级标题，一共有1～6级标题</li></ul><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 我是标题</span><br><span class="line">## 我是标题</span><br><span class="line">### 我是标题</span><br><span class="line">#### 我是标题</span><br><span class="line">##### 我是标题</span><br><span class="line">###### 我是标题</span><br></pre></td></tr></table></figure><h2 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h2><p>通过在文字开头添加<code>&gt;</code>表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。）</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 我是块注释</span><br></pre></td></tr></table></figure><blockquote><p>我是块注释</p></blockquote><h2 id="斜体、粗体"><a href="#斜体、粗体" class="headerlink" title="斜体、粗体"></a>斜体、粗体</h2><ul><li>将需要设置为斜体的文字两端使用1个<code>*</code>或者<code>_</code>夹起来- </li><li>将需要设置为粗体的文字两端使用2个<code>*</code>或者<code>_</code>夹起来- </li><li>用3个会是什么效果呢？大家试试吧！</li></ul><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*我是斜体文字*</span><br></pre></td></tr></table></figure><p><em>我是斜体效果</em></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>在文字开头添加<code>*, +, -</code>实现无序列表。但是要注意在<code>*, +, -</code>和文字之间需要添加空格。<em><strong>建议：一个文档中只能用一种无序列表的表示方式</strong></em></p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">- C</span><br></pre></td></tr></table></figure><ul><li>A</li><li>B</li><li>C</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>使用数字后面跟上<code>.</code>，注意和文字之间需要添加空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. A</span><br><span class="line">2. B</span><br><span class="line">3. C</span><br></pre></td></tr></table></figure><ol><li>A</li><li>B</li><li>C</li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown中有两种方法实现链接，分别为<em><strong>内联方式</strong></em>和<em><strong>引用方式</strong></em>。</p><ul><li>内联方式：<code>![链接名称](链接地址)</code><br>  如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个 [链接](http://junhaow.com/)</span><br></pre></td></tr></table></figure>  这是一个 <a href="http://junhaow.com/">链接</a></li><li>引用方式：（用法如下）<br>如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里有两个链接 [Google][1]、[Yahoo][2]</span><br><span class="line"></span><br><span class="line">[1]: http://google.com/        &quot;Google&quot; </span><br><span class="line">[2]: http://search.yahoo.com/  &quot;Yahoo Search&quot; </span><br></pre></td></tr></table></figure>  这里有两个超链接 <a href="http://google.com/" title="Google">Google</a>、<a href="http://search.yahoo.com/" title="Yahoo Search">Yahoo</a></li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的处理方法和链接的处理方法非常类似。</p><ul><li><p>内联方式：<code>![可爱的熊猫](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/eh4o1.jpg &quot;标题文字&quot;)</code></p><p>  如：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![可爱的熊猫](panda.jpg &quot;标题文字&quot;)</span><br></pre></td></tr></table></figure><p><img src="/panda.jpg" alt="可爱的熊猫" title="标题文字"></p><ul><li>引用方式：(用法如下)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![可爱的头像][anything] </span><br><span class="line">[anything]: 学会这些简单语法来用Markdown做笔记/maozi.png &quot;标题文字&quot;</span><br></pre></td></tr></table></figure>![可爱的头像][anything]<br>[anything]: <a href="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/nojdu.jpg">https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/nojdu.jpg</a> “标题文字”</li></ul><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“–”，实现的2级标题）</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>实现方法：我是文字[^脚猪]</p><p><em><strong>脚注不是标准MarkDown的范畴，各个扩展的定义可能有所不同。</strong></em></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>实现方法有两种：</p><ul><li>简单代码出现一个代码框。使用一个<code> </code> <code>来包围代码（注意是</code>esc&#96;键下面那个噢!）</li><li>大片文字需要实现代码框。使用三个<code> </code> &#96;包围代码</li></ul><p>如：<code>weapon.attack()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monster.walk()</span><br><span class="line">monster.jump()</span><br><span class="line">monster.fire()</span><br></pre></td></tr></table></figure><p><em><strong>还可以使用语法高亮，只需要在三个<code> </code> &#96;后面附上语言名称即可</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cool\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如可以附上c、objc、java、html。</p><p>以上就是基本语法了，相信大家可以很快掌握它们。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我介绍一款好棒的Markdown编辑器 <a href="http://25.io/mou/">Mou</a> （点击去下载）</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ut87s.jpg" alt="Mou界面"></p><p><strong>常用快捷键：</strong></p><p>粗体 <code>⌘ + B</code></p><p>斜体 <code>⌘ + I</code></p><p>单行代码 <code>⌘ + K</code></p><p>插入链接 <code>⌃ + ⇧ + L</code></p><p>插入图片 <code>⌃ + ⇧ + I</code></p><p>大家快去下载试试吧！^,^</p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数学之美》读书笔记</title>
      <link href="/2016/07/10/015_%E3%80%8A%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/07/10/015_%E3%80%8A%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>其实这本书越早读越好，最好在中学阶段，中国教育最失败的就是学生从上课的第一天到考试结束，都不知道他学的东西能做什么。《数学之美》正好能告诉学生（包括大学生），从小到大学的那些数学知识可以如何改造世界。 —— gj83 &#x2F; 亚马逊读者</p></blockquote><blockquote><p>有时我在想，现在的社会多了一点压力和浮躁，少了一点踏实和对自然科学本质的好奇求知。吴军的这本《数学之美》真的非常好。非常希望吴军今后能写出更多这样深入浅出的好书，它们是给这个社会和年轻人最好的礼物。 —— 李开复</p></blockquote><span id="more"></span><p><em><strong>其实很想将自己理解的数学模型、公式贴上来解释，但现在还不太会怎么弄，而且理解不是非常深！以后有机会的。</strong></em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>很多大学毕业生毕业后，在大学所学的数学可能一辈子都没有机会应用，几年后就忘得差不多了。</p><p>  <em><strong>坐着这里强调了实践的重要性！</strong></em></p></li><li><p>Virtue is like a rich stone, best plain set.</p><p>  <em><strong>美德就如同华贵的宝石，在朴素的衬托下最显华丽。</strong></em></p></li></ul><h3 id="第1章-文字和语言-vs-数字和信息"><a href="#第1章-文字和语言-vs-数字和信息" class="headerlink" title="第1章 文字和语言 vs 数字和信息"></a>第1章 文字和语言 vs 数字和信息</h3><ul><li><p>很多读者问我为什么在《浪潮之巅》一书中讲的公司大多在美国，因为近百年的技术革命大多发生在那里。</p></li><li><p>信息的冗余是信息安全的保障。</p></li><li><p>语言的数据，我们称之为语料，尤其是双语或者多语的对照语料对翻译至关重要，它是我们从事机器翻译研究的基础。</p></li></ul><h3 id="第2章-自然语言处理-——-从规则到统计"><a href="#第2章-自然语言处理-——-从规则到统计" class="headerlink" title="第2章 自然语言处理 —— 从规则到统计"></a>第2章 自然语言处理 —— 从规则到统计</h3><ul><li><p>从20世纪50年代到70年代，是科学家们走弯路的阶段。全世界的科学家对计算机处理自然语言的认识都局限在人类学习语言的方式上，也就是说，用电脑模拟人脑，这20多年的成果近乎为零。直到20世纪70年代，一些自然语言处理的先驱开始重新认识这个问题，找到了基于数学模型和统计的方法，自然语言处理进入第二个阶段。</p></li><li><p>钱钟书在《围城》中讲，老科学家可以理解成“老的科学家”或者“老科学的家”两种。如果是后者，他们年纪不算老，但是已经落伍，大家必须耐心等他们退休让出位子。毕竟，不是所有人都乐意改变自己的观点，无论对错。当然，等这批人退休之后，科学就会以更快的速度发展。因此，我常想，我自己一定要在还不太糊涂和固执时就退休。</p><p>  <em><strong>有道理！人们不敢挑战权威。</strong></em></p></li></ul><h3 id="第3章-统计语言模型"><a href="#第3章-统计语言模型" class="headerlink" title="第3章 统计语言模型"></a>第3章 统计语言模型</h3><ul><li><p>在实际应用中，统计语言模型的零概率问题是无法回避的，必须解决。</p></li><li><p>古德-图灵估计的原理是这样的：对于没有看见的事件，我们不能认为它发生的概率就是零，因此我们从概率的总量（Probability Mass）中，分配一个很小的比例给这些没有看见的事件。</p></li><li><p>在成本不高的情况下，有必要对训练数据进行过滤。</p></li><li><p>数学的魅力就在于将复杂的问题简单化。</p></li></ul><h3 id="第4章-谈谈分词"><a href="#第4章-谈谈分词" class="headerlink" title="第4章 谈谈分词"></a>第4章 谈谈分词</h3><ul><li><p>自然语言处理的许多数学方法是通用的，与具体的语言无关。在Google内部，我们设计语言处理的算法时，都会考虑它是否能很容易地适用于各种自然语言。这样才能有效地支持上百种语言的搜索。</p></li><li><p>需要指出的是任何方法都有它的局限性，虽然利用统计语言模型进行分词，可以取得比人工更好的结果，但是也不可能做到百分之百准确。因为统计语言模型很大程度上是依照“大众的想法”，或者“多数句子的用法”，而在特定情况下可能是错的。</p></li></ul><h3 id="第5章-隐含马尔可夫模型"><a href="#第5章-隐含马尔可夫模型" class="headerlink" title="第5章 隐含马尔可夫模型"></a>第5章 隐含马尔可夫模型</h3><ul><li><p>隐含马尔可夫模型是一个并不复杂的数学模型，到目前为止，它一直被认为是解决大多数自然语言处理问题最快速、有效的方法。它成功地解决了复杂的语音识别、机器翻译等问题。</p></li><li><p>雅各布森通信六个要素是：发送者（信息源），信道，接受者，信息，上下文和编码。</p></li><li><p>隐含马尔可夫模型最早的成功应用是语音识别。20世纪80年代末李开复博士坚持采用隐含马尔可夫模型的框架，成功研发出了世界上第一个大词汇量连续语音识别系统Sphinx。</p></li><li><p>围绕着隐含马尔可夫模型有三个基本问题：</p><ol><li><p>给定一个模型，如何计算某个特定的输出序列的概率；</p></li><li><p>给定一个模型和某个特定的输出序列，如何找到最可能产生这个输出的状态序列；</p></li><li><p>给定足够量的观测数据，如何估计隐含马尔可夫模型的参数。</p></li></ol></li><li><p>数据由人工标注的方法称为有监督的训练方法（Supervised Training）。</p></li></ul><h3 id="第6章-信息的度量和作用"><a href="#第6章-信息的度量和作用" class="headerlink" title="第6章 信息的度量和作用"></a>第6章 信息的度量和作用</h3><ul><li><p>直到1948年，香农（Claude Shannon）在他著名的论文“通信的数学原理”（A Mathematic Theory of Communication）中提出了“信息熵”的概念，才解决了信息的度量问题，并且量化出信息的作用。</p></li><li><p>几乎所有的自然语言处理、信息与信号处理的应用都是一个消除不确定性的过程。</p></li><li><p>合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。</p></li><li><p>信息的作用在于消除不确定性，自然语言处理的大量问题就是寻找相关的信息。</p></li></ul><h3 id="第7章-贾里尼克和现代语言处理"><a href="#第7章-贾里尼克和现代语言处理" class="headerlink" title="第7章 贾里尼克和现代语言处理"></a>第7章 贾里尼克和现代语言处理</h3><ul><li><p>在当今物欲横流的中国社会，学术界浮躁，年轻人焦虑，少数有着远大志向的年轻人实际上是非常孤独的。这很像罗曼·罗兰笔下一战后的法国。罗曼·罗兰为那些追求灵魂高尚而非物质富裕的年轻人写下了《巨人三传》，让大家呼吸到巨人的气息。</p></li><li><p>首先，小学生和中学生其实没有必要花那么多时间读书，而他们的社会经验、生活能力以及在那时树立起的志向将帮助他们的一生。第二，中学阶段花很多时间比同伴多读的课程，上大学以后用很短时间就能读完，因为在大学阶段，人的理解力要强得多。第三，学习（和教育）是持续一辈子的过程。第四，书本的内容可以早学，也可以晚学，但是错过了成长的阶段却是无法补回来的。（因此，少年班的做法不足取。）</p></li><li><p>贾里尼克教授在学术上给我最大的帮助就是提高了我在学术上的境界。他告诉我最多的是：什么方法不好。在这一点上与股神巴菲特给和他吃饭的投资人的建议有异曲同工之处。</p></li></ul><h3 id="第8章-简单之美-——-布尔代数和搜索引擎"><a href="#第8章-简单之美-——-布尔代数和搜索引擎" class="headerlink" title="第8章 简单之美 —— 布尔代数和搜索引擎"></a>第8章 简单之美 —— 布尔代数和搜索引擎</h3><ul><li><p>在腾讯内部升级搜索引擎时，首先要改进和统一的就是所有搜索业务的索引，否则提高搜索质量就如同浮沙建塔一样不稳固。同样，我们在这本书中介绍搜索，也是从索引出发，因为它最基础，也最重要。</p></li><li><p>最简单的所以呢结构是一个很长的二进制数表示一个关键字是否出现在每篇文献中。</p></li></ul><h3 id="第9章-图论和网络爬虫"><a href="#第9章-图论和网络爬虫" class="headerlink" title="第9章 图论和网络爬虫"></a>第9章 图论和网络爬虫</h3><ul><li><p>在网络爬虫中，人们使用一种“散列表”（Hash Table，也叫哈希表）而不是一个记事本记录网页是否下过的信息。</p></li><li><p>如果一个图能够从一个定点出发，每条边不重复地遍历一遍回到这个顶点，那么每一顶点的度必须为偶数。</p></li><li><p>“如何构建一个网络爬虫”是我在Google最常用的一道面试题。一个好的候选人不需要做过网络爬虫也能很好地回答这道题。一般要考虑以下几点：</p><ul><li><p>首先，用BFS还是DFS？网络爬虫对网页遍历的次序不是简单的BFS或者DFS，而是有一个相对复杂的下载优先级排序的方法。管理这个优先级排序的子系统一般称为调度系统（Scheduler），由它来决定当一个网页下载完成后，接下来下载哪一个。其在工程上和BFS更相似，因此BFS成分多一些。</p></li><li><p>第二，页面的分析和URL的提取。不像以前，现在URL可能藏匿于JavaScript代码中。</p></li><li><p>第三，记录哪些网页已经下载过的小本本——URL表。采用散列表的好处是，判断一个网页URL是否在表中，平均只需一次（或者略多的）查找。常遇到的问题：首先，这张散列表会大到一台服务器存储不下。其次，由于每个下载服务器在开始下载前和完成下载后都要访问和维护这张表，以免不同的服务器做重复的工作，这个存储散列表的服务器的通信就成了整个爬虫系统的瓶颈。</p></li></ul></li><li><p>好的爬虫方法一般都采用了这样两个技术：首先明确每台下载服务器的分工，也就是说在调度时一看到某个URL就知道要交给哪台服务器去下载，以免很多服务器都要重复判断某个URL是否需要下载。然后，在明确分工的基础上，判断URL是否下载就可以批处理了，</p></li><li><p>随着互联网的出现，图的遍历方法一下子有了用武之地。很多数学方法就是这样，看上去没有什么实际用途，但是随着时间的推移会突然排上大用场。这恐怕是世界上还有很多人毕业研究数学的原因。</p></li></ul><h3 id="第10章-PageRank-——-Google的民主表决式网页排名技术"><a href="#第10章-PageRank-——-Google的民主表决式网页排名技术" class="headerlink" title="第10章 PageRank —— Google的民主表决式网页排名技术"></a>第10章 PageRank —— Google的民主表决式网页排名技术</h3><ul><li><p>网页排名算法的高明之处在于它把整个互联网当作一个整体来对待。</p></li><li><p>由于PageRank算法受到专利保护，它带来了两个结果。首先，其他搜索引擎开始时都比较遵守游戏规则，不去侵犯它，这对当时还很弱小的Google是一个很好的保护。第二，它使得斯坦福大学拥有了超过1%的Google股票，收益超过10亿美元。</p></li></ul><h3 id="第11章-如何确定网页和查询的相关性"><a href="#第11章-如何确定网页和查询的相关性" class="headerlink" title="第11章 如何确定网页和查询的相关性"></a>第11章 如何确定网页和查询的相关性</h3><ul><li>TF-IDF（Term Frequency &#x2F; Inverse Document Frequency）的概念被公认为信息检索中最重要的发明。即使是对搜索不是很精通的人，直接采用TF-IDF，效果也不会太差。</li></ul><h3 id="第12章-有限状态机和动态规划-——-地图与本地搜索的核心技术"><a href="#第12章-有限状态机和动态规划-——-地图与本地搜索的核心技术" class="headerlink" title="第12章 有限状态机和动态规划 —— 地图与本地搜索的核心技术"></a>第12章 有限状态机和动态规划 —— 地图与本地搜索的核心技术</h3><ul><li><p>有限状态机是一个特殊的有向图，它包括一些状态（节点）和连接这些状态的有向弧。每一个有限状态机都有一个开始状态和一个终止状态，以及若干中间状态。每一条弧上带有从一个状态进入下一个状态的条件。</p></li><li><p>当用户输入的地址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。为了可以进行模糊匹配，科学家们提出基于概率的有限状态机。这种基于概率的有限状态机和离散的马尔可夫链基本上等效。</p></li><li><p>在Google新一代的产品中，有限状态机的一个典型的应用是Google Now —— 一个在智能手机上的基于个人信息的服务软件。</p></li><li><p>全球导航的关键算法是计算机科学图论中的动态规划（Dynamic Programming）的算法。</p></li><li><p>正确的数学模型可以将一个计算量看似很大的问题的计算复杂度大大降低。这便是数学的妙用。</p></li></ul><h3 id="第13章-Google-AK-47-的设计者-——-阿米特·辛格博士"><a href="#第13章-Google-AK-47-的设计者-——-阿米特·辛格博士" class="headerlink" title="第13章 Google AK-47 的设计者 —— 阿米特·辛格博士"></a>第13章 Google AK-47 的设计者 —— 阿米特·辛格博士</h3><ul><li><p>在计算机科学领域，一个好的算法应该像AK-47冲锋枪那样：简单、有效、可靠性好而且容易读懂（或者说易操作），而不应该是故弄玄虚。</p></li><li><p>许多失败并不是因为人不优秀，而是做事情的方法不对，一开始追求大而全的解决方案，之后长时间不能完成，最后不了了之。</p></li><li><p>辛格坚持每天要分析一些搜索结果不好的例子，以掌握第一手的资料，即使在他成为Google Fellow以后，依旧如此。这一点，非常值得从事搜索研究的年轻工程师学习。事实上，我发现中国大部分做搜索的工程师在分析不好的结果上花的时间远比功成名就的辛格要少。</p></li><li><p>辛格非常鼓励年轻人要不怕失败，大胆尝试。有一次，一位刚毕业不久的工程师因为把带有错误的程序推出到Google的服务器上而惶惶不可终日。辛格安慰她说，你知道，我在Google犯的最大一次错误是曾经将所有网页的相关性得分全部变成了零，于是所有搜索的结果全部都是随机的了。后来，这位出过错的工程师为Google开发出了很多好产品。</p></li></ul><h3 id="第14章-余弦定理和新闻的分类"><a href="#第14章-余弦定理和新闻的分类" class="headerlink" title="第14章 余弦定理和新闻的分类"></a>第14章 余弦定理和新闻的分类</h3><ul><li>美国人总是倾向于用机器（计算机）代替人工来完成任务。虽然在短期内需要做一些额外的工作，但是从长远看可以节省很多时间和成本。</li></ul><h3 id="第15章-矩阵运算和文本处理中的两个分类问题"><a href="#第15章-矩阵运算和文本处理中的两个分类问题" class="headerlink" title="第15章 矩阵运算和文本处理中的两个分类问题"></a>第15章 矩阵运算和文本处理中的两个分类问题</h3><ul><li><p>我在大学学习线性代数时，实在想不出这门课除了告诉我们如何解线性方程外，还能有什么别的用途。后来在数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。当时选这些课，完全是为了挣学分得学位，今天大部分大学生恐怕也是如此。我想，很多同学都多多少少有过类似的经历。直到后来长期做自然语言处理的研究，我才发现数学家们提出的那些矩阵的概念和算法，是有实际应用的意义的。</p></li><li><p>在2007年，Google中国（谷歌）的张智威博士带领几个中国的工程师及实习生实现了奇异值的并行算法，这是Google中国对世界的一个贡献。</p></li></ul><h3 id="第16章-信息指纹及其应用"><a href="#第16章-信息指纹及其应用" class="headerlink" title="第16章 信息指纹及其应用"></a>第16章 信息指纹及其应用</h3><ul><li>一段文字所包含的信息，就是它的信息熵。如果对这段信息进行无损压缩编码，理论上编码后的最短长度就是它的信息熵。</li></ul><h3 id="第17章-由电视剧《暗算》所想到的-——-谈谈密码学的数学原理"><a href="#第17章-由电视剧《暗算》所想到的-——-谈谈密码学的数学原理" class="headerlink" title="第17章 由电视剧《暗算》所想到的 —— 谈谈密码学的数学原理"></a>第17章 由电视剧《暗算》所想到的 —— 谈谈密码学的数学原理</h3><ul><li><p>在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在为美军情报部门工作，而信息论实际上就是情报学的直接产物。</p></li><li><p>根据信息论，密码的最高境界是敌方在截获密码后，对我方的所知没有任何增加，即信息量没有增加。</p></li></ul><h3 id="第18章-闪光的不一定是金子-——-搜索反作弊问题和搜索结果的权威性问题"><a href="#第18章-闪光的不一定是金子-——-搜索反作弊问题和搜索结果的权威性问题" class="headerlink" title="第18章 闪光的不一定是金子 —— 搜索反作弊问题和搜索结果的权威性问题"></a>第18章 闪光的不一定是金子 —— 搜索反作弊问题和搜索结果的权威性问题</h3><ul><li>网页搜索反作弊对搜索引擎公司来讲是一项长期的任务。作弊的本质是在网页排名信号中加入了噪音，因此反作弊的关键是去噪音。沿着这个思路可以从根本上提高搜索算法抗作弊的能力，事半功倍。</li></ul><h3 id="第19章-谈谈数学模型的重要性"><a href="#第19章-谈谈数学模型的重要性" class="headerlink" title="第19章 谈谈数学模型的重要性"></a>第19章 谈谈数学模型的重要性</h3><ul><li><p>其实，托勒密在天文学上的地位堪比欧几里得之于几何学，牛顿之于物理学。</p></li><li><p>一个正确的数学模型一般有以下特点：</p><ol><li><p>在形式上是简单的；</p></li><li><p>一开始可能还不如一个精雕细琢过的错误模型来的准确；</p></li><li><p>大量准确的数据对研发很重要；</p></li><li><p>可能会受噪音干扰，而显得不准确，这时需要找到噪音的根源。</p></li></ol></li></ul><h3 id="第20章-不要把鸡蛋放到一个篮子里-——-谈谈最大熵模型"><a href="#第20章-不要把鸡蛋放到一个篮子里-——-谈谈最大熵模型" class="headerlink" title="第20章 不要把鸡蛋放到一个篮子里 —— 谈谈最大熵模型"></a>第20章 不要把鸡蛋放到一个篮子里 —— 谈谈最大熵模型</h3><ul><li><p>最大熵原理指出，对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知条件，而对未知的情况不要做任何主观假设，使得概率分布最均匀，预测的风险最小。</p></li><li><p>最大熵模型在形式上是最漂亮、最完美的统计模型，在自然语言处理和金融方面有很多有趣的应用。注意其在实现上异常复杂，计算量非常大。</p></li><li><p>通用迭代算法GIS（Generalized Iterative Scaling）：</p><ol><li><p>假定第零次迭代的初始模型为等概率的均匀分布。</p></li><li><p>用第N次迭代的模型来估算每种信息特征在训练数据中的分布。如果超过了实际的，就把相应的模型参数变小。否则，将它们变大。</p></li><li><p>重复步骤2，直到收敛。</p></li></ol></li></ul><h3 id="第21章-拼音输入法的数学原理"><a href="#第21章-拼音输入法的数学原理" class="headerlink" title="第21章 拼音输入法的数学原理"></a>第21章 拼音输入法的数学原理</h3><ul><li><p>输入法输入汉字的快慢取决于汉字编码的平均长度。</p></li><li><p>对汉字编码分为两部分：对拼音的编码和消除歧义性的编码。</p></li><li><p>由于种种原因，早期的拼音输入法不是很成功，这就给其他输入法的迅速崛起创造了条件。</p></li></ul><h3 id="第22章-自然语言处理的教父马库斯和他的优秀弟子们"><a href="#第22章-自然语言处理的教父马库斯和他的优秀弟子们" class="headerlink" title="第22章 自然语言处理的教父马库斯和他的优秀弟子们"></a>第22章 自然语言处理的教父马库斯和他的优秀弟子们</h3><ul><li>马库斯的主张一贯是建立几个世界上最好的专业，而不是专业最齐全的系。我觉得，当今中国的大学，最需要的就是马库斯这样卓有远见的管理者。</li></ul><h3 id="第23章-布隆过滤器"><a href="#第23章-布隆过滤器" class="headerlink" title="第23章 布隆过滤器"></a>第23章 布隆过滤器</h3><ul><li><p>布隆过滤器是一个很长的二进制向量和一系列随机映射函数。</p></li><li><p>布隆过滤器背后的数学原理在于两个完全随机的数字相冲突的概率很小。</p></li></ul><h3 id="第24章-马尔可夫链的扩展-——-贝叶斯网络"><a href="#第24章-马尔可夫链的扩展-——-贝叶斯网络" class="headerlink" title="第24章 马尔可夫链的扩展 —— 贝叶斯网络"></a>第24章 马尔可夫链的扩展 —— 贝叶斯网络</h3><ul><li>无</li></ul><h3 id="第25章-条件随机场、文法分析及其他"><a href="#第25章-条件随机场、文法分析及其他" class="headerlink" title="第25章 条件随机场、文法分析及其他"></a>第25章 条件随机场、文法分析及其他</h3><ul><li><p>条件随机场是无向图，而贝叶斯网络是有向图。</p></li><li><p>使用条件随机场模型预测洛杉矶地区犯罪在2011年被《时代》周刊誉为年度最优秀的发明之一。</p></li></ul><h3 id="第26章-维特比和他的维特比算法"><a href="#第26章-维特比和他的维特比算法" class="headerlink" title="第26章 维特比和他的维特比算法"></a>第26章 维特比和他的维特比算法</h3><ul><li><p>码分多址（CDMA）、频分多址（FDMA）、时分多址（TDMA）。</p></li><li><p>世界上绝大多数科学家最大的满足就是自己的研究成果得到同行的认可，如果能有应用就更是喜出望外了。而能够亲自将这些成就应用到实际中的人少之又少，因为做到这一点对科学家来讲很不容易。</p></li></ul><h3 id="第27章-上帝的算法-——-期望最大化算法"><a href="#第27章-上帝的算法-——-期望最大化算法" class="headerlink" title="第27章 上帝的算法 —— 期望最大化算法"></a>第27章 上帝的算法 —— 期望最大化算法</h3><ul><li>EM算法只需要有一些训练数据，定义一个最大化函数，剩下的事情就交给计算机了。经过若干次迭代，我们需要的模型就训练好了。这实在是太美妙了，这也许是造物主刻意安排的。</li></ul><h3 id="第28章-逻辑回归和搜索广告"><a href="#第28章-逻辑回归和搜索广告" class="headerlink" title="第28章 逻辑回归和搜索广告"></a>第28章 逻辑回归和搜索广告</h3><ul><li><p>搜索广告之所以比传统的在线展示广告赚钱多很多，除了搜索者的意图明确外，更重要的是靠预测用户可能会点击哪些广告，来决定搜索结果页中插入哪些广告。</p></li><li><p>逻辑回归模型是指将一个事件出现的概率逐渐适应到一条逻辑曲线（Logistic Curve，其值域在（0，1）之间）上。逻辑曲线是一条S型曲线，特点是一开始变化快，逐渐减慢，最后饱和。</p></li></ul><h3 id="第29章"><a href="#第29章" class="headerlink" title="第29章"></a>第29章</h3><ul><li><p>分治算法是计算机科学中最漂亮的工具之一。它的基本原理是：将一个复杂的问题，分成若干个简单的子问题进行解决。然后，对子问题的结果进行合并，得到原有问题的解。</p></li><li><p>将一个大任务拆分成小任务，并且完成子任务的计算，这个过程叫做Map，将中间结果合并成最终结果，这过过程叫做Reduce。这就是MapReduce。</p></li></ul><h3 id="第30章-Google大脑和人工神经网络"><a href="#第30章-Google大脑和人工神经网络" class="headerlink" title="第30章 Google大脑和人工神经网络"></a>第30章 Google大脑和人工神经网络</h3><ul><li><p>通过“Google大脑”的深度学习后，语音识别的错误率从13.6%下降至11.6%。大家可不要小看这两个百分点，要做到这一点，通常需要全世界语音识别专家们努力两年左右。</p></li><li><p>如果有幸遇到一个好心同时又善于表达的科学家或教授，他愿意花一两个小时的时间，深入浅出地为你讲解人工神经网络的底细，你就会发现，“哦，原来是这么回事”。</p></li><li><p>Google大脑并不是一个什么都能思考的大脑，而是一个很能计算的人工神经网络。因此，与其说Google大脑很聪明，不如说它很能算。</p></li></ul><h3 id="第31章-大数据的威力-——-谈谈数据的重要性"><a href="#第31章-大数据的威力-——-谈谈数据的重要性" class="headerlink" title="第31章 大数据的威力 —— 谈谈数据的重要性"></a>第31章 大数据的威力 —— 谈谈数据的重要性</h3><ul><li><p>在Google内部，产品经理们都遵循这样一个规则：在没有数据之前，不要给出任何结论。</p></li><li><p>数据不仅在科学研究中，而且在生活的方方面面都很重要，它应该成为我们日常做决策的依据。</p></li><li><p>今天IT行业的竞争，在某种程度上已经是数据的竞争了。</p></li></ul><h3 id="附录-计算复杂度"><a href="#附录-计算复杂度" class="headerlink" title="附录 计算复杂度"></a>附录 计算复杂度</h3><ul><li>一个优秀的计算机科学家或者工程师与平庸的程序员的差别在于：前者总是不断寻找并且有能力找到好的算法，而后者仅常常满足于勉强解决问题。</li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li><p>无论是在美国还是在中国，我经常看到大部分软件工程师在一个未知领域都是从直观感觉出发，用“凑”的方法来解决问题，在中国尤其如此。这样的做法说得不好听，就是山寨。</p></li><li><p>在国内，创业小公司做事情重量不重质，倒也无可厚非；但是，上了市、有了钱甚至利润成为在世界上也数得上的公司，做事情依然如此，就让人觉得境界低。另一方面，在修建大楼和装修高管办公室的投入上，这些公司倒是很快超越了许多跨国公司。</p></li><li><p>世界上最好的学者总是有办法深入浅出地把大道理将给外行听，而不是故弄玄虚地把简单的问题复杂化。</p></li></ul><p><a href="https://book.douban.com/subject/26163454/">《数学之美》豆瓣地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管乐团排练曲子合集（附内网下载地址）</title>
      <link href="/2016/07/08/010_%E7%AE%A1%E4%B9%90%E5%9B%A2%E6%8E%92%E7%BB%83%E6%9B%B2%E5%AD%90%E5%90%88%E9%9B%86-%E9%99%84%E5%86%85%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
      <url>/2016/07/08/010_%E7%AE%A1%E4%B9%90%E5%9B%A2%E6%8E%92%E7%BB%83%E6%9B%B2%E5%AD%90%E5%90%88%E9%9B%86-%E9%99%84%E5%86%85%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>为了方便大家下载排练的曲目并认真练习[微笑]，特地整理了一下曲子。</p><p>PS：下载需要连接内网噢！有些不是排练的曲子，但也很好听！</p><span id="more"></span><ul><li><p><a href="http://10.28.31.4/share/music/A%20Christmas%20Wish.mp3">A Chirstmas Wish</a></p></li><li><p><a href="http://10.28.31.4/share/music/Abide%20With%20Me.mp3">Abide With Me</a></p></li><li><p><a href="http://10.28.31.4/share/music/Adagio.mp3">Adagio</a></p></li><li><p><a href="http://10.28.31.4/share/music/All%20About%20That%20Bass%20%28March%20Version%29.mp3">All About That Bass (March Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Ammerland.mp3">Ammerland</a></p></li><li><p><a href="http://10.28.31.4/share/music/And%20Goodnight.mp3">And Goodnight</a></p></li><li><p><a href="http://10.28.31.4/share/music/Around%20the%20World%20In%2080%20Measures.mp3">Around the World In 80 Measures</a></p></li><li><p><a href="http://10.28.31.4/share/music/Beyond%20the%20Riverbend%20by%20Robert%20Sheldon.mp3">Beyond the Riverbend by Robert Sheldon</a></p></li><li><p><a href="http://10.28.31.4/share/music/Blazing%20Bones%20of%20the%20West.mp3">Blazing Bones of the West</a></p></li><li><p><a href="http://10.28.31.4/share/music/Butter%20Fly.mp3">Butter Fly</a></p></li><li><p><a href="http://10.28.31.4/share/music/Canonic%20Fantasy.mp3">Canonic Fantasy</a></p></li><li><p><a href="http://10.28.31.4/share/music/Celebration%20And%20Song.mp3">Celebration And Song</a></p></li><li><p><a href="http://10.28.31.4/share/music/Choreography.mp3">Choreography</a></p></li><li><p><a href="http://10.28.31.4/share/music/I%20Will%20Follow%20Him.mp3">I Will Follow Him</a></p></li><li><p><a href="http://10.28.31.4/share/music/La.Storia..mp3">La.Storia.</a></p></li><li><p><a href="http://10.28.31.4/share/music/Let%20It%20Go.mp3">Let It Go</a></p></li><li><p><a href="http://10.28.31.4/share/music/Low%20Rider.mp3">Low Rider</a></p></li><li><p><a href="http://10.28.31.4/share/music/NOVENA.mp3">NOVENA</a></p></li><li><p><a href="http://10.28.31.4/share/music/Pachebell%27s%20Canon.mp3">Pachebell’s Canon</a></p></li><li><p><a href="http://10.28.31.4/share/music/Pirates%20of%20the%20Caribbean.m4a">Pirates of the Caribbean</a></p></li><li><p><a href="http://10.28.31.4/share/music/Pomp%20And%20Circumstance%20%28March%29.mp3">Pomp And Circumstance (March)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Power%20to%20progress%20-%20Darren%20Loveday%2c%20Stephen%20Loveday%20%28Life%20is%20Strange%20Trailer%20Finale%29.mp3">Power to progress</a></p></li><li><p><a href="http://10.28.31.4/share/music/Rock%20Star%20%28Jazz%29.mp3">Rock Star (Jazz)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Shake%20It%20Off%20%28March%20Version%29.mp3">Shake It Off (March Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Star%20War%20%28March%20Version%29.mp3">Star War (March Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/The%20American%20Way.mp3">The American Way</a></p></li><li><p><a href="http://10.28.31.4/share/music/The%20Best%20of%20Leroy%20Anderson%2c%20Grade%202.mp3">The Best of Leroy Anderson</a></p></li><li><p><a href="http://10.28.31.4/share/music/The%20Phantom%20Of%20The%20Opera.mp3">The Phantom of the Opera</a></p></li><li><p><a href="http://10.28.31.4/share/music/The%20Wild%20Westerns.mp3">The Wild Westerns</a></p></li><li><p><a href="http://10.28.31.4/share/music/Timber%20%28Concert%20Version%29.mp3">Timber (Concert Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Timber%20%28March%20Version%29.mp3">Timber (March Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Transformers.mp3">Transformers</a></p></li><li><p><a href="http://10.28.31.4/share/music/Uptown%20Funk%20%28March%20Version%29.mp3">Uptown Funk (March Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/Viva%20La%20Vida%20%28March%20Version%29.mp3">Viva La Vida (March Version)</a></p></li><li><p><a href="http://10.28.31.4/share/music/You%20Raise%20Me%20Up.mp3">You Raise Me Up</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e5%8a%a0%e5%8b%92%e6%af%94%e6%b5%b7%e7%9b%973%ef%bc%9a%e4%b8%96%e7%95%8c%e7%9a%84%e5%b0%bd%e5%a4%b42%e7%ba%a7.mp3">加勒比海盗3：世界的尽头</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e5%90%8d%e4%be%a6%e6%8e%a2%e6%9f%af%e5%8d%97%28Version1%29.mp3">名侦探柯南 (Version 1)</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e5%90%8d%e4%be%a6%e6%8e%a2%e6%9f%af%e5%8d%97%28Version2%29.mp3">名侦探柯南 (Version 2)</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e6%82%ac%e5%b4%96%e4%b8%8a%e7%9a%84%e9%87%91%e9%b1%bc%e5%85%ac%e4%b8%bb.mp3">悬崖上的金鱼公主</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e7%ae%80%e7%89%88%e5%8a%a0%e5%8b%92%e6%af%94%e6%b5%b7%e7%9b%97.mp3">简版加勒比海盗</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e7%ae%a1%e4%b9%90%e5%9b%a2Butter%20Fly.MOV">管乐团Butter Fly视频</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e7%bb%bf%e9%87%8e%e4%bb%99%e8%b8%aa-%e9%a3%9e%e8%b6%8a%e5%bd%a9%e8%99%b9.mp3">绿野仙踪-飞越彩虹</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e8%83%a1%e6%a1%83%e5%a4%b9%e5%ad%90%28%e8%9b%8b%e9%bb%84%29.mp3">胡桃夹子(蛋黄)</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e9%98%bf%e7%94%98%e6%ad%a3%e4%bc%a0.mp3">阿甘正传</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e9%ad%94%e5%a5%b3%e3%81%ae%e5%ae%85%e6%80%a5%e4%be%bf.mp3">魔女の宅急便</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e9%be%99%e7%8c%ab.wav">龍舌蘭</a></p></li><li><p><a href="http://10.28.31.4/share/music/%e9%be%99%e7%8c%ab.wav">龙猫</a></p></li></ul><p>看完了就点歌赞呗~</p>]]></content>
      
      
      <categories>
          
          <category> Music </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 管乐团 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Campus App at STU - My Team and All Ad Posts We Sent</title>
      <link href="/2016/07/08/009_%E6%B1%95%E5%A4%A7%E8%AF%BE%E7%A8%8B%E8%A1%A8%E5%AE%A3%E4%BC%A0%E6%8E%A8%E6%96%87%E5%90%88%E9%9B%86-%E4%BB%8E%E5%8F%91%E5%B8%83%E5%88%B0%E7%8E%B0%E5%9C%A8/"/>
      <url>/2016/07/08/009_%E6%B1%95%E5%A4%A7%E8%AF%BE%E7%A8%8B%E8%A1%A8%E5%AE%A3%E4%BC%A0%E6%8E%A8%E6%96%87%E5%90%88%E9%9B%86-%E4%BB%8E%E5%8F%91%E5%B8%83%E5%88%B0%E7%8E%B0%E5%9C%A8/</url>
      
        <content type="html"><![CDATA[<p>从发布到现在，从最初的两人到现在的一个团队组织，我们做了好多推文噢～我这里就把它们都整理一下吧！</p><p>Starting by one idea from my friend Xiaofu, we grew our team from two people (one for iOS, one for Android) to three, and to four, to six, to many students!</p><p align="center">  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wks85.jpg" width=600px alt="Our Team (2015), me on the right"></p><p align="center">  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/c7qso.jpg" width=600px alt="Our Team (2016)"></p><p align="center">  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/k5xsp.jpg" width=600px alt="Our Team (2019)"></p><br><p>App Screenshot:</p><p align="center">  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2022-01-11-campus-app-screenshot.jpg" width=800px alt="iOS Version"></p><p>Here are all the posts we have sent out to make more people download and try our app! Sorry they are written in Chinese &gt;&lt;</p><ul><li>2018 &amp; 2019<ul><li>2019-02-19 | <a href="https://mp.weixin.qq.com/s/5YR3ht0tf3GbmTt4da6bfA">课程表 | 新阵容+新目标</a></li><li>2018-11-12 | <a href="https://mp.weixin.qq.com/s/dLRDvqaFVvZn3NVMPpyPbA">汕大课表招新 | 等一个头发浓密的你</a></li></ul></li><li>2017<ul><li>2017-11-20 | <a href="https://mp.weixin.qq.com/s/kYBqQgATWN02FI9UgkIk5A">课表小程序 | 添加课程和课程提醒</a></li><li>2017-10-19 | <a href="https://mp.weixin.qq.com/s/DQh_TrzM22A6Srq86SN5ww">惊喜 | 我们有小程序了</a></li><li>2017-09-26 | <a href="https://mp.weixin.qq.com/s/UoSe0iVeJLt9UPyqf6_akg">福利 | 课程表的第7000个用户，你在哪里？</a></li><li>2017-09-17 | <a href="https://mp.weixin.qq.com/s/926kZwU0DHgChx7iwKUrVQ">你好 | 我叫汕大课程表</a></li><li>2017-03-02 | <a href="https://mp.weixin.qq.com/s/Q1bQzHI3HqN1R2P0cAyv0Q">汕大课程表 | 瑟瑟寒风中的温馨提示！</a></li></ul></li><li>2016<ul><li>2016-12-16 | <a href="https://mp.weixin.qq.com/s/c8qQ6oDpUrVx9BFkT1TG0Q">课程表送礼 | 你猜今天是什么大日子？</a></li><li>2016-11-17 | <a href="https://mp.weixin.qq.com/s/hHs6VTkj7OhRRQCXxTXmRQ">安卓2.0beta | 课程表才不是作妖，你听我解释</a></li><li>2016-11-09 | <a href="https://mp.weixin.qq.com/s/gP-aBWUAJ-ndGTytS5L8bA">安卓大更 | 成为那个“别人家大学的app”</a></li><li>2016-09-29 | <a href="https://mp.weixin.qq.com/s/-EbbT1thTZRMM0AizTKcmQ">委屈 | 课程表背后的我们</a></li><li>2016-09-01 | <a href="https://mp.weixin.qq.com/s/MilaJa9e_3EylSRGxJGXuQ">抽奖 | 小鲜肉们，汕大课程表等你好久啦</a></li><li>2016-06-03 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=2651227285&idx=1&sn=7eb471ff8635632dcd5a718e4bd9f28c#rd">汕大课程表大更新 | “老师&#x2F;医学生&#x2F;研究生, 终于可以一起玩了!”</a></li><li>2016-05-20 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=2651227259&idx=1&sn=20d8fa0a4213706b40af88c974ba0af3#rd">感恩 | 用汕大课程表的故事给你们表白</a> <span class="purple">Our Story</span></li><li>2016-05-12 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=2651227256&idx=1&sn=7c58a4660482ecaadcb218217a7a4f92#rd">汕大课程表又一次更新 | “老是这一套你们腻不腻？”</a></li><li>2016-04-27 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=2651227251&idx=1&sn=31d1e3c7f3430d4e395c501759d01911#rd">汕大课程表更新 | 我们不止是汕大一键联网器</a></li><li>2016-04-01 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=403743600&idx=1&sn=4d68b7c426a7d53aaed69aef228828d3#rd">汕大课程表 | 绝不是玩笑的礼物</a></li><li>2016-03-13 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=403318211&idx=1&sn=80104897adcfc06451c3880780b69a85#rd">汕大课程表更新 | 请给我一百分让我骄傲</a></li></ul></li><li>2015<ul><li>2015-12-19 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=401808707&idx=1&sn=7801927b4a4ab06da6798c7a92301587#rd">恭喜13xpli成为汕大课程表第1000位用户</a></li><li>2015-12-17 | <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjE0NDc5Mw==&mid=401697720&idx=1&sn=eb63bdac3ecfdc3acea7be8d59aa081a#rd">汕大人自己的课程表哎噗 | iOS版 &amp; Android版</a></li></ul></li></ul><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cbpzp.png" title="我和一个医学生画的宣传板"></p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8fdwy.jpg" title="然而第二天被打扫的阿姨清了"></p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汕大课程表 </tag>
            
            <tag> STU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以前做过的一些Unity小游戏</title>
      <link href="/2016/07/08/007_%E4%BB%A5%E5%89%8D%E5%81%9A%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9BUnity%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2016/07/08/007_%E4%BB%A5%E5%89%8D%E5%81%9A%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9BUnity%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>整理一下以前做过的一些Unity游戏，现在看起来真的是非常幼稚的呢。不过在这个过程中也学到了很多东西的，虽然没有碰到Shader、Animation这种高科技的东西。</p><ul><li><p>2015</p><p>  滚球游戏<br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bqyx5.jpg" alt="Unity游戏画面"></p>  <span id="more"></span><p>  太空飞机大战<br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yxsm8.jpg" alt="游戏画面"></p><p>  Q&amp;A（在AppStore上可以下载，这个不是Unity做的呢）<br>  <a href="http://www.tudou.com/programs/view/Bn6-96QT8o0/">视频演示</a><br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xltcb.jpg" alt="游戏记录画面"></p></li><li><p>2014</p><p>  Oscar射手<br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/lw5xn.jpg" alt="Unity游戏主菜单"><br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7n0zq.jpg" alt="Unity游戏主角"></p><p>  加法模拟器<br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ie237.jpg" alt="3D模式"></p><p>  第一人称跑酷<br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/m6ocl.jpg" alt="第一人称跑酷"></p></li><li><p>2013</p><p>  神庙大战江南</p><p>  <a href="http://www.tudou.com/programs/view/ma82WQld-8c/">视频演示</a></p></li><li><p>2012</p><p>  iOS 剪刀石头布游戏演示（这个不是Unity做的呢）<br>  <a href="http://www.tudou.com/programs/view/gW2ShA6qvc4/">视频演示</a></p><p>  快跑工人<br>  <img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/myvkg.jpg" alt="游戏结束画面"></p><p>  欣赏Unity</p></li><li><p>2011</p><p>  井字过三关</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Hexo中无痛地使用本地图片</title>
      <link href="/2016/07/08/006_%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E4%B8%AD%E6%97%A0%E7%97%9B%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
      <url>/2016/07/08/006_%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E4%B8%AD%E6%97%A0%E7%97%9B%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>在Hexo中使用本地图片是件非常让人痛苦的事情，因为在Markdown里面图片地址永远不能和最后生成的网页保持一致。一开始，我打算Bmob来进行图片管理，但是发现这样是不是太麻烦呢？</p><span id="more"></span><p>搜索了下，发现Hexo使用本地图片有以下几种方法：</p><ul><li><p>放在根目录</p><p>  这种方法是把图片放在<code>source/img</code>下，然后在Markdown里写<code>![img](/source/img/anything.png)</code>然而这种方法在本地的编辑器里不能正确识别图片的位置。</p></li><li><p>   asset-image<br>   这是一个在Hexo 2.x时出现的插件，后来被纳进<code>Hexo 3 core</code>。但是很尴尬的是，这种方法直接放弃了Markdown原来的语法，使用类似的语法。这让人有点难以接受咯～</p></li><li><p>解决方法</p><p>  <a href="https://github.com/CodeFalling/hexo-asset-image">hexo-asset-image</a></p><p>  首先确认<code>_config.yml</code>中有<code>post_asset_folder:true</code></p><p>  在Hexo目录，执行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>  比如在</p><pre><code>  文章名  ├── 图片1.jpg  ├── 图片2.jpg  └── 图片3.jpg  文章名.md</code></pre><p>  这样的目录结构，只要使用<code>![图片描述](文章名/图片名称.jpg)</code>就可以插入图片了。</p><p>  最终生成的结构</p><pre><code>  public/2016/07/08/文章名  ├── index.html  ├── 图片1.jpg  └── 图片2.jpg</code></pre><p>  同时生成HTML是</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/2016/07/08/文章名/图片名称.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  而不是愚蠢的</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;文章名/图片名称.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>至此，我们就可以很方便地插入本地图片了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给你推荐一款Mac下的打字练习神器TypeFu</title>
      <link href="/2016/06/17/005_%E7%BB%99%E4%BD%A0%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BEMac%E4%B8%8B%E7%9A%84%E6%89%93%E5%AD%97%E7%BB%83%E4%B9%A0%E7%A5%9E%E5%99%A8TypeFu/"/>
      <url>/2016/06/17/005_%E7%BB%99%E4%BD%A0%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BEMac%E4%B8%8B%E7%9A%84%E6%89%93%E5%AD%97%E7%BB%83%E4%B9%A0%E7%A5%9E%E5%99%A8TypeFu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yp0c7.jpg"></p><p>(第二次发写推文, 有点紧张&gt;&lt;)</p><p>今天给大家推荐一款练打字的Mac应用. &lt;下载链接在猫呆的尾巴&gt;</p><span id="more"></span><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y2ppn.jpg" alt="App图标"></p><p>什么, 为什么要练打字? 程序猿: 敲代码. &lt;这就对了&gt;</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/tfd7z.jpg" alt="App截图"></p><p>在敲代码前, 猫呆曾经花了2个星期练熟了Dvorak键盘布局….(布局如下图)</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/j0e5r.jpg" alt="Dvorak键盘布局"></p><p>当时很多人不敢用猫呆的电脑, &lt;嘻嘻&gt;因为TA根本不知道哪个键对应哪个键…</p><p>当时觉得好爽, 特别在敲英文的时候手指根本就不用动来动去的.</p><p>后来因为学习了Emacs编辑器, 掌握了各种c-x m-x c-f c-b等快捷键.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gliv5.jpg" alt=".emacs配置文件"></p><p>此时, 猫呆发现Dvorak布局下的Emacs不是很好用(因为不能”盗”用很多大神的配置文件了T’T), 之后下决心放弃Dvorak又学习Qwerty布局了.</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/v1afy.jpg" alt="蜜汁凝视"></p><p>和之前学习不同的是, 猫呆花了两个星期学习了盲打&gt;&lt; 然后接下来一个星期一直练打字速度(为了突破50 WPM), 每天去某个外国打字比赛网站去刷速度(网站忘了…)</p><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/h1ute.jpg" alt="word per minute"></p><p>最后, 现在稳定在70WPM(其实, 可以再练习达到100WPM…但你懂得…编程这东西…也要花时间去想想写什么代码…)  但是, 70WPM其实已经非常非常快了…够用了亲!</p><h4 id="点击-这里-去百度云盘下载Dmg安装包"><a href="#点击-这里-去百度云盘下载Dmg安装包" class="headerlink" title="点击 这里 去百度云盘下载Dmg安装包"></a>点击 <a href="http://pan.baidu.com/s/1gf6pjm7#rd">这里</a> 去百度云盘下载Dmg安装包</h4><p>最后最后, 留个GitHub地址, 其实什么都没有…<br><a href="http://github.com/chuckwong">http://github.com/chuckwong</a></p>]]></content>
      
      
      <categories>
          
          <category> Anything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《约翰·史密斯的告白》读书笔记</title>
      <link href="/2016/04/27/014_%E3%80%8A%E7%BA%A6%E7%BF%B0%C2%B7%E5%8F%B2%E5%AF%86%E6%96%AF%E7%9A%84%E5%91%8A%E7%99%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20/"/>
      <url>/2016/04/27/014_%E3%80%8A%E7%BA%A6%E7%BF%B0%C2%B7%E5%8F%B2%E5%AF%86%E6%96%AF%E7%9A%84%E5%91%8A%E7%99%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li><p>唉，这些文学的绿头苍蝇！它们那么热爱腐肉，当一个伟大的头脑不够健康的时候，它们就会在上面聚集起来。如果一个人有五十项高尚的美德，即便只有一个小小的过失，而且出现在以普通读者看来完全不能代表作者风格的最不重要的作品作品中，也会让那些苍蝇一样的评论家顷刻发现，并像苍蝇一样在流血的伤口处产卵。</p><span id="more"></span><p>  <em><strong>非常形象！</strong></em></p></li><li><p>教育水平最高的国家终将被证实为最强大的国家，个人的福祉将会推动整个社会的福祉。</p></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ul><li><p>谁说人类是邪恶和堕落的？如果一个人说他看到了这些，我不会羡慕。他不是在同类那里受到了不公平的待遇，就是对别人抱着偏见。的确，如我昨天所说，婴儿有野蛮复发的倾向，但是说到我们周围的成年人，无论男女，你什么时候听说过那么多恶行？</p></li><li><p>“蚂蚁看不到天上七星。”波斯诗人法利达汀·阿塔尔写道，但天上七星总是存在的。</p></li><li><p>“动摇一个人的信仰。”这个荒唐的说法直到现在还在世界上流传，因为有其现实的基础。</p><p>  <em><strong>如果信仰可以被动摇，那就不是信仰了。</strong></em></p></li><li><p>战争和瘟疫是上帝在修剪树枝，人类之树可能需经随意修剪才会更加茁壮。这是营火哲学。</p><p>  <em><strong>然而百度并没有什么营火哲学T。T</strong></em></p></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ul><li><p>人人都知道解释笑话是件危险的事，而用严格的规则向一个人分析什么地方好笑、什么时候应该笑，那真是个令人郁闷的疯狂行为的开端。</p><p>  <em><strong>所以说，玩游戏输了之后千万不要讲笑话。除非你以前讲过这个笑话，并且能让大部分人笑翻。不然你可能面临解释这个笑话的悲剧啊！</strong></em></p></li><li><p>我们的科学家朋友能否制作两张表格，一张是确信无疑的知识，另一张还有待论证？我想制表的朋友在第一张上花不了多少工夫，第二张却可能耗掉他所有的纸张。</p><p>  <em><strong>数学试卷上，题目的已知什么什么就一两行字，下面一大片空白。</strong></em></p></li><li><p>不要让任何人知道你相信太阳在燃烧，他们会好奇这些年你被关在了什么闭塞的地方。</p><p>  <em><strong>幽默</strong></em></p></li><li><p>作家为了表达自己的看法，而偏离他讲述的故事，这是非常不合适的，也缺乏艺术感。</p></li><li><p>我们的脑子没有办法记住所有的知识。那里的小格子没有弹性的墙壁，每有新的知识到来，就有可能失去旧的知识。避免给大脑带入无用之物就成了重中之重。</p><p>  <em><strong>在电视剧《神探夏洛克》中，福尔摩斯说过类似的话。</strong></em></p></li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ul><li><p>痛风正离我而去。我感觉它在慢慢消失，如同从山顶散去的雾气。新鲜、温暖而健康的血液刺得每条血管麻麻的。这份重获健康的喜悦让生病成为一件值得的事。</p><p>  <em><strong>比如我，咳嗽突然好了！</strong></em></p></li><li><p>在世界历史的任何一个时间点上，你都可以取到人类灵魂的平均值，它会告诉你那个时期人类大家庭在精神、修养和美德上所达到的水准。</p></li><li><p>好人与上帝的区别只在于谁活得更久。</p></li><li><p>母亲的教育是世界上一切保守主义的根源——每一个处在萌芽中的非凡之才都天生怀有激进主义和自由思想的倾向。</p></li><li><p>没有人蠢到或坏到连一个追随者都没有。有句精辟的法国格言可以佐证，纵然他是个傻瓜，也会有更傻的人仰慕他。</p></li><li><p>只有两种想象是人类智力不能企及的——永恒和无限。</p></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ul><li>我承认在音乐这方面我有点外行，我也完全不相信音乐领悟力本身就是一种有教养的标志。</li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ul><li>一个人可以忍受工作的辛劳，可休息却非常耗神。</li></ul><p><a href="https://book.douban.com/subject/6967984/">《约翰·史密斯的告白》豆瓣地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add some useful plugins to your Xcode</title>
      <link href="/2015/08/05/001_Add-some-useful-plugins-to-your-Xcode/"/>
      <url>/2015/08/05/001_Add-some-useful-plugins-to-your-Xcode/</url>
      
        <content type="html"><![CDATA[<p>As we know Xcode is the most important tool for iOS develops. It’s time for us to improve coding environment. However, if you use AppCode for development, it will be better, I think.</p><p>First, go to <a href="http://alcatraz.io/">http://alcatraz.io/</a> or copy the following code to Terminal to install Alcatraz for a better plugin environment in Xcode.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | s</span><br></pre></td></tr></table></figure><span id="more"></span><p>Secondly, now you have Alcatraz to manage your powerful plugins. In Xcode, go to <code>Windows -&gt; Package Manger</code> for plugin management or directly press <code>⌘+⇧+9</code></p><p>Last but not least, here are some very useful plugins that I want to share with you.</p><p>By the way, you can search and install plugins in the Package Manager above.</p><p><strong>Some plugins I am using:</strong> </p><p><a href="https://github.com/neonichu/BBUDebuggerTuckAway">BBUDebuggerTuckAway</a></p><ul><li>It allows Xcode to hide the console automatically while you’re typing.</li></ul><p><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense</a></p><ul><li>It helps you pick color quickly and translates color to codes for you.</li></ul><p><a href="https://github.com/macoscope/CodePilot">CodePilot</a></p><ul><li>It’s like a pilot because it can search everything in your project including codes, methods, etc.</li></ul><p><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">FuzzyAutocompletePlugin</a></p><ul><li>If you feel good about the completion in Xcode, you’ll feel better about this plugin about completion.</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
