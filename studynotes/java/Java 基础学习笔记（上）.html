<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <meta name="description" content="由于太久没碰 Java，而且以前也没有进行系统的学习，最近想通过一些网课先过一遍基础语法和常用 API。我先看了 Udemy 的 Java Programming Masterclass for Software Developers，但看到一半就弃坑了，因为这个课是给零基础的人设计的，讲得太啰嗦了，而且教的内容也太浅了（不过我倒是学了很多 IntelliJ IDEA 的使用技巧）。 之后无意">
<meta property="og:type" content="website">
<meta property="og:title" content="Java 基础学习笔记（上）">
<meta property="og:url" content="https://junhaow.com/studynotes/java/Java%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89.html">
<meta property="og:site_name" content="forkercat.blog">
<meta property="og:description" content="由于太久没碰 Java，而且以前也没有进行系统的学习，最近想通过一些网课先过一遍基础语法和常用 API。我先看了 Udemy 的 Java Programming Masterclass for Software Developers，但看到一半就弃坑了，因为这个课是给零基础的人设计的，讲得太啰嗦了，而且教的内容也太浅了（不过我倒是学了很多 IntelliJ IDEA 的使用技巧）。 之后无意">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1h362.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/l8wkm.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/iexh0.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/by3zw.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ale2i.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/zwpbq.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yn368.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yasac.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1aq9b.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vclwx.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/if1nx.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/v4ew1.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/he0r0.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xgzmc.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/aqvyb.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/89tub.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cmult.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/9mwh6.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/df361.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/x5vhi.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8wp6j.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0edst.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yznxn.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/kkc2f.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/532t4.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cucvr.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wy1uu.jpg">
<meta property="article:published_time" content="2019-02-04T23:55:06.000Z">
<meta property="article:modified_time" content="2024-02-13T00:53:54.203Z">
<meta property="article:author" content="Junhao Wang">
<meta property="article:tag" content="blog, junhaow, game">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1h362.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/resources/favicon/me/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/resources/favicon/me/android-chrome-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/resources/favicon/me/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Java 基础学习笔记（上）</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-146643833-1"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-146643833-1');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/resources/images/me_avatar.jpg" />
    
  
    <div id="title">
      <h1 class="p-name">forkercat.blog</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/archives/">Posts</a></li><!--
   --><!--
     --><li><a href="/studynotes/">Notes</a></li><!--
   --><!--
     --><li><a href="/lc/">Leetcode</a></li><!--
   --><!--
     --><li><a href="/games/">Games</a></li><!--
   --><!--
     --><li><a href="/links/">Links</a></li><!--
   --><!--
     --><li><a href="/about/">Me</a></li><!--
   -->
    </ul>
  </div>
</header>

        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <br>

<p>由于太久没碰 Java，而且以前也没有进行系统的学习，最近想通过一些网课先过一遍基础语法和常用 API。我先看了 Udemy 的 Java Programming Masterclass for Software Developers，但看到一半就弃坑了，因为这个课是给零基础的人设计的，讲得太啰嗦了，而且教的内容也太浅了（不过我倒是学了很多 IntelliJ IDEA 的使用技巧）。</p>
<p>之后无意中看到了廖雪峰的 Java SE 课程，个人感觉非常棒，很适合有其他 OOP 基础的人学习（16 小时、讲解深度适中、干货多）。本文笔记基于这个课程。在学习的过程中，我还阅读很多关于泛型、内存模型等知识的博客文章，毕竟课程的讲解深度有限，这些内容还是挺难理解的（我的两本 Java 经典书籍刚到货，估计之后可以学到更多高级和底层的内容）。</p>
<span id="more"></span>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>快速介绍 Java 的历史，讲解 Java 基本语法、数据类型，掌握如何使用 Eclipse IDE 并快速编写简单的 Java 程序。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Sun 公司<code>James Gosling</code>为手持设备开发的嵌入式编程语言。Java 原名为 Oak，1995 年改名为 Java 正式推出。</p>
<p>三个版本：</p>
<ul>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1h362.jpg" alt="三者关系图"></p>
<p>Java 版本演进：</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">版本</th>
<th align="center">时间</th>
<th align="center">版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1995 年</td>
<td align="center">1.0</td>
<td align="center">2004 年</td>
<td align="center">1.5 &#x2F; 5.0</td>
</tr>
<tr>
<td align="center">1998 年</td>
<td align="center">1.2</td>
<td align="center">2006 年</td>
<td align="center">1.6 &#x2F; 6.0</td>
</tr>
<tr>
<td align="center">2000 年</td>
<td align="center">1.3</td>
<td align="center">2011 年</td>
<td align="center">1.7 &#x2F; 7.0</td>
</tr>
<tr>
<td align="center">2002 年</td>
<td align="center">1.4</td>
<td align="center">2014 年</td>
<td align="center">1.8 &#x2F; 8.0</td>
</tr>
</tbody></table>
<p>Java 规范</p>
<ul>
<li>JSR 规范：Java Specification Request</li>
<li>JCP 组织：Java Community Process</li>
<li>确保 Java 跨平台特性</li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/l8wkm.jpg" alt="Java 规范关系图"></p>
<p>Java 平台</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/iexh0.jpg" alt="Java 平台"></p>
<p>JDK：Java Development Kit<br>JRE：Java Runtime Environment</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Java 的两种变量类型：基本类型、引用类型。</p>
<p><code>int x = n / 0;</code> <strong>运行时</strong>才会报错。<br>Java 中，计算结果溢出不报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n - <span class="number">199</span>;  <span class="comment">// 报错，较大类型整型不能赋值给较小类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) (n - <span class="number">199</span>) <span class="comment">// 强制转型不会报错（可能丢失精度）</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>; <span class="comment">// 结果是 0.099999999999</span></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四舍五入技巧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">12.7</span> + <span class="number">0.5</span>);  <span class="comment">// 加 0.5 再强制转换</span></span><br></pre></td></tr></table></figure>

<p>&amp;&amp; 和 || 被称为<code>短路运算符</code>：</p>
<p><code>false &amp;&amp; (5 / 0)</code>不会报错，因为后面不会被执行。即前面部分 false (&amp;&amp;) 或者 true (||)，后面就不执行了。</p>
<p>三元运算符<code>b ? x : y</code>中 x 和 y 的类型一定要相同。</p>
<p>Java 使用 Unicode 表示字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;   <span class="comment">// char c1 = &#x27;\u0041&#x27;;</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;  <span class="comment">// char c2 = &#x27;\u4e2d&#x27;;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> c1; <span class="comment">// 65</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> c2; <span class="comment">// 20013</span></span><br></pre></td></tr></table></figure>
<p>如果将 char 变量赋值给 int 变量，可以得到该字符的 Unicode 表示。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串类型是<code>引用类型</code>。 </p>
<p>字符串不可变！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>; <span class="comment">// 新字符</span></span><br><span class="line">s = <span class="string">&quot;Hello, &quot;</span> + <span class="string">&quot;s&quot;</span>; <span class="comment">// 新字符</span></span><br><span class="line"><span class="comment">// 旧的两个字符串会被 JVM 垃圾收集器回收。</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是<code>同一数据类型</code>的集合，类型是：<code>类型名[]</code>。元素初始化为默认值，数组创建后大小不可改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ns1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span>[] ns2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] b = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>&#125; &#125;;  <span class="comment">// 因为 java 存数组的本质是 multi-level arrays，相当于 C 语言里的 int *b[]</span></span><br><span class="line">System.out.println(b[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 运行时报错</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;haha&quot;</span>); <span class="comment">// 原来也可以用这个。</span></span><br></pre></td></tr></table></figure>

<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>对浮点数进行<code>==</code>运算不靠谱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0.1</span>) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相反，应该利用差值来判断</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(x - <span class="number">0.1</span>) &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用类型对象的判断方法：</p>
<ul>
<li><code>==</code>判断是否为同一对象（判断 id，即地址）</li>
<li><code>equals()</code>方法判断对象的内容是否相等，如果对象是 null 会报错（NullPointerException）。</li>
</ul>
<p>有两种好的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非 null 的对象放前面</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.equals(str)) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用短路运算符 &amp;&amp;</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span> &amp;&amp; s.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BTW：</strong>Java 里不推荐省略花括号<code>&#123;&#125;</code>（代码风格）。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>for each 遍历数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ns; i++) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">  i++; <span class="comment">// 不要在循环体内修改计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以遍历<code>可迭代</code>数据类型，包括 List、Map 等。但是，for each 循环无法指定遍历顺序；也无法获取数组索引。</p>
<p>使用<code>Arrays.toString()</code>可以快速打印数组内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a); <span class="comment">// 直接打印数组对象</span></span><br><span class="line"><span class="comment">// a = [I@60f82f98  （可能是 id）</span></span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + Arrays.toString(a));</span><br><span class="line"><span class="comment">// a = [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>Arrays.sort() 来进行排序。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;-version&quot;</span>.equals(arg)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;v 1.0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// run in shell</span></span><br><span class="line"><span class="comment">// $ java Main -version -s -t &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>介绍 Java 面向对象编程的概念，掌握数据封装、继承和多态，掌握 Java 的包、作用域及常用核心类。</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>直接把 field 用 public 暴露给外部可能破坏了封装，应该定义 public 方法可以间接访问 field（更加安全）。</p>
<p><code>参数绑定</code>：基本类型、引用类型。</p>
<p>字符串（String）作为参数传递，是值传递，<strong>表现出非对象的特性！（虽然它是引用类型）</strong><code>因为是包装类</code>？</p>
<p>原因：</p>
<p>是因为 new 的问题吗？不对。实际上，字符串直接赋值和用 new 出的对象赋值的区别仅仅在于存储方式不同。</p>
<blockquote>
<p>也许你注意到了 String 类里的 char[]，这说明对 String 的存储实际上通过 char[] 来实现的。怎么样？其实就是一层窗户纸。不知道大家还记不记得在 Java API 中定义的那些基本类型的<code>包装类</code>。比如 Integer 是 int 包装类、Float 是 float 的包装类等等。对这些包装类的值操作实际上都是通过对其对应的<strong>基本类型操作</strong>而实现的。</p>
<p>是不是有所感悟了？对，String 就相当于是 char[] 的包装类。<strong>包装类的特质之一就是在对其值进行操作时会体现出其对应的基本类型的性质</strong>。在参数传递时，包装类就是如此体现的。所以，对于String在这种情况下的展现结果的解释就自然而然得出了。</p>
<p>同样的，Integer、Float 等这些包装类和 String 在这种情况下的表现是相同的，具体的分析在这里就省略了，有兴趣的朋友可以自己做做试验。</p>
</blockquote>
<blockquote>
<p>这也就是为什么当对字符串的操作在通过不同方法来实现的时候，推荐大家使用 StringBuffer 的真正原因了。至于 StringBuffer 为什么不会表现出 String 这种现象，大家再看看的 StringBuffer 的实现就会明白了，在此也不再赘述了。</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>如果自定义了构造方法，编译器就不再<code>自动</code>创建默认构造方法，此时只有自定义的构造方法。</p>
<p>类中初始化的顺序：</p>
<ul>
<li>先初始化<code>字段</code><ul>
<li>没有赋值的字段初始化为默认值：<ul>
<li>基本类型 &#x3D; 0</li>
<li>引用类型 &#x3D; null</li>
</ul>
</li>
</ul>
</li>
<li>再执行构造方法的代码</li>
</ul>
<p>设计思想：将代码逻辑集中在参数<code>最复杂</code>的构造方法中，从而实现代码复用。(利用重载实现)</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>目的：相同功能的方法使用同一个名字；方便调用；代码复用。</p>
<ul>
<li>多个方法的方法名相同</li>
<li>但各自的参数不同（个数、类型、位置【但不应该去交换顺序】）</li>
<li>方法返回值类型<strong>通常</strong>都是相同的<ul>
<li>注意：这不是强制的，但这是应该遵守的规范！</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承，是代码复用的一种方式。</p>
<p>规定：</p>
<ul>
<li>构造方法的第一行语句必须是 super()；如果没有，编译器会<code>自动生成</code> super()。<ul>
<li>（父类有默认的构造方法）</li>
</ul>
</li>
<li>如果父类没有默认的构造方法，<strong>子类必须显式调用</strong> super(…) 方法。<ul>
<li>比如父类自己写了带参数的构造方法，Java 编译器就不会自动为它添加默认的构造方法，因此子类也不会被自动添加默认的构造方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; <span class="comment">// 不能声明为 private</span></span><br><span class="line">    System.out.println(<span class="string">&quot;create Person...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    Person();  <span class="comment">// ERROR! - 不存在 Person()</span></span><br><span class="line">    <span class="comment">// or 什么都不写 - ERROR! - Java 不会自动添加 super(...)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;create Student...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以对实例变量进行<code>向上转型</code>（Upcasting），把一个子类型安全地变为更加抽象的类型。</p>
<p>可以对实例变量进行<code>向下转型</code>（Downcasting），把抽象的类型变成一个具体的子类型。向下转型很可能报错：ClassCastException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p; <span class="comment">// ClassCastException</span></span><br><span class="line"><span class="comment">// 改正</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;  <span class="comment">// instance of</span></span><br><span class="line">  s = (Student) p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p instanceof Person - true</span></span><br><span class="line"><span class="comment">// p instanceof Student - false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// s instanceof Person - true</span></span><br><span class="line"><span class="comment">// s instnaceof Student - true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span> <span class="comment">// 比较的是对象，所以空的时候不正确</span></span><br><span class="line"><span class="comment">// n instanceof Student - false</span></span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>注意搞清楚这几个词的关系：覆盖、覆写、重写（Override）。</p>
<p>加上<code>@Overrite</code>可以让编译器帮助检查是否进行了正确的覆写，但不是必需的。</p>
<p>Java 的实例方法调用是基于运行时实际类型的<code>动态调用</code>（多态）。覆盖的时候可以调用父类的方法，用 super()。</p>
<p>final 关键字：</p>
<ul>
<li>用 final 修饰的方法，不能被覆盖。</li>
<li>用 final 修饰的类，不能被继承。</li>
<li>用 final 修饰的字段在初始化后不能被修改。</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象方法定义了子类必须实现的<code>接口规范</code>，定义了抽象方法的类就是抽象类。从抽象继承的子类必须实现抽象方法；如果不实现抽象方法，则该子类仍是一个抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125; <span class="comment">// 因为无法执行抽象方法，所以这个类也得声明为抽象类。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">// 类不能被实例化</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过子类去继承并实现这些抽象方法，从而实现<code>多态</code>。</p>
<p>所以，面向抽象编程的本质：</p>
<ul>
<li>上层代码只<code>定义规范</code>（abstract class pattern）。</li>
<li>不需要子类就可以实现<code>业务逻辑</code>（可以正常编译）。</li>
<li>具体的业务逻辑由不同的<code>子类实现</code>，调用者并不关心。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果一个抽象类没有字段，所有方法<strong>全部是抽象方法</strong>，就可以把该抽象类改写为接口（Interface）。因为 Java 编译器默认 Interface 是<code>public</code>、<code>abstract</code>，所以我们不用再写这两个修饰符。</p>
<p>注意区分一下接口：</p>
<ul>
<li>Java 的接口特指 interface 定义的接口，只定义方法签名。</li>
<li><code>编程接口</code>泛指<code>接口规范</code>，如方法签名，数据格式，网络协议等。</li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/by3zw.jpg" alt="抽象和接口对比图"></p>
<p>default 方法在<code>&gt;jdk 1.8</code>引入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">default</span> <span class="type">double</span> <span class="title function_">perimeter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 如果不在 default，实现接口的类必须要实现这个方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 也可以继承另一个 interface：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ale2i.jpg" alt="如何合理设计接口和抽象类"></p>
<h3 id="静态字段和方法"><a href="#静态字段和方法" class="headerlink" title="静态字段和方法"></a>静态字段和方法</h3><p>可以将静态字段理解为描述 class 本身的字段。<code>不推荐用实例变量访问静态字段，而推荐用类名访问静态字段</code>。</p>
<p>静态方法类似其他编程语言的函数。静态方法不能访问 this 变量，不能访问实例字段，可以访问静态字段。</p>
<ul>
<li>静态方法经常用于<code>工具类</code><ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
</li>
<li>静态方法经常用于<code>辅助方法</code></li>
<li>Java 程序的入口 main() 也是<code>静态方法</code></li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>这是 Java 定义的一种<code>名字空间</code>，包名 + 类名 &#x3D; 完整类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xiaoming;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">&#125; <span class="comment">// xiaoming.Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> xiaohong;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">&#125; <span class="comment">// xiaohong.Person</span></span><br></pre></td></tr></table></figure>

<p>包可以是多层结构，但包<strong>没有父子关系</strong>。java.util 和 java.util.zip 是不同的包，两者没有任何关系。</p>
<p>JVM 加载 class 并执行时，总是使用 class 的完整类名（编译后也是）。如：java.util.Arrays、Hello（没有定义 package，不推荐）。</p>
<p><code>包作用域</code>：位于同一个包的类，可以访问包作用域的字段和方法。这是缺省修饰符，即不用 public、protected、private 修饰的字段和方法就是包作用域。</p>
<p>引用其他类的方法：</p>
<ul>
<li>使用完整类名</li>
<li>先 import，再使用类名<ul>
<li>import xiaoming;</li>
<li>使用：xiaoming.Person</li>
</ul>
</li>
<li>可以使用<code>*</code>（不推荐，有点类型 C++ 的 using namespace）<ul>
<li><code>import java.util.*;</code></li>
</ul>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Java 的类、接口、字段和方法都可以设置访问权限。</p>
<ul>
<li>访问权限是指一个类的内部，能否引用另一个类以及访问它的字段和方法。</li>
<li>访问权限有 public、protected、private、package（缺省）四种。</li>
</ul>
<p><strong>注意：</strong>private 方法，推荐写在类定义的后面。</p>
<ul>
<li>定义为 private 的 class 无法被其他类访问。</li>
<li>访问 private class 被限定在外层 class 的内部。</li>
<li>定义在一个 class 内部的 class 被称为<code>内部类</code>（inner class）。</li>
<li>在一个 Java 文件中只能定义<code>一个 public 类</code>，但可以定义<code>多个非 public 的类</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.sample</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最佳实践：</p>
<ul>
<li>如果不确定是否需要 public，就不声明为 public，尽可能少地暴露对外的方法。</li>
<li>尽可能把局部变量的作用域缩小。</li>
<li>尽可能延后声明局部变量。</li>
</ul>
<h3 id="classpath-和-jar"><a href="#classpath-和-jar" class="headerlink" title="classpath 和 jar"></a>classpath 和 jar</h3><h4 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h4><ul>
<li>classpath 是一个环境变量</li>
<li>classpath 指示 JVM 如何搜索 class</li>
<li>classpath 设置的搜索路径与操作系统有关：<ul>
<li>win：<code>C:\work\project1\bin;C:\shared;&quot;D:\My Document\project2\bin&quot;</code></li>
<li>mac：<code>/usr/shared:/usr/local/bin:/home/chuck/bin</code></li>
</ul>
</li>
</ul>
<p>win 用分号；mac 用冒号。</p>
<p>假设 classpath 是：<code>.;C:\work\project1\bin;C:\shared</code>，JVM 在加载 com.chuck.Hello 这个类时，依次查找：</p>
<ul>
<li>&lt;当前目录&gt; \com\chuck\Hello.class</li>
<li>C:\work\project1\bin\com\chuck\Hello.class</li>
<li>C:\shared\com\chuck\Hello.class</li>
</ul>
<p><strong>注意：</strong>在某个路径找到了，就不再继续搜索了。如果没找到就报错。</p>
<p>classpath 的设置方法：</p>
<ul>
<li>直接在系统环境中设置 classpath 环境变量（不推荐）</li>
<li>在启动 JVM 时设置 classpath 变量（推荐）：<ul>
<li>java -classpath C:\work\bin;C:\shared com.chuck.hello</li>
<li>java -cp 同上</li>
</ul>
</li>
<li>没有设置环境变量，也没有设置 -cp 参数，默认的 classpath 为当前目录。</li>
<li>在 Eclipse 中运行 Java 程序，Eclipse 自动传入的 -cp 参数是当前工程的 bin 目录和引入的 jar。</li>
</ul>
<h4 id="jar-包"><a href="#jar-包" class="headerlink" title="jar 包"></a>jar 包</h4><ul>
<li>jar 包是 zip 格式的压缩文件，包含若干 .class 文件（可以直接改 zip 文件的扩展名）</li>
<li>jar 包相当于目录</li>
<li>classpath 可以包含 jar 文件：C:\work\bin\all.jar</li>
<li>查找 com.chuck.Hello 类将在 C:\work\bin\all.jar 文件中搜索 com&#x2F;chuck&#x2F;Hello.class</li>
<li>使用 jar 包可以避免大量的目录和 .class 文件（起打包作用）</li>
</ul>
<p>如何创建 jar 包：</p>
<ul>
<li>使用 JDK 自带的 jar 命令</li>
<li>使用构建工具如 Maven 等</li>
</ul>
<p>jar 包的其它功能：</p>
<ul>
<li>jar 包可以包含一个特殊的 &#x2F;META-INF&#x2F;MANIFEST.MF 文件。</li>
<li>MANIFEST.MF 是纯文本，可以指定 Main-Class 和其它信息。</li>
<li>jar 包还可以包含其它 jar 包。</li>
</ul>
<p>JDK 的 class：</p>
<p>JVM 运行时会自动加载 JDK 自带的 class，都被打包在<code>rt.jar</code>文件中，但我们不需要在 classpath 中引用<code>rt.jar</code>。</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/zwpbq.jpg" alt="MAINIFEST.MF 文件，注意不要有空行"></p>
<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><p>这个类可以直接使用<code>&quot;anyString&quot;</code>，且内容是不可变的。</p>
<p>API：</p>
<ul>
<li><p>eqauls(Object)</p>
</li>
<li><p>equalsIgnoreCase(String)</p>
</li>
<li><p>boolean contains(CharSequence)</p>
</li>
<li><p>int indexOf(String)</p>
</li>
<li><p>int lastIndexOf(String)</p>
</li>
<li><p>boolean startsWith(String)</p>
</li>
<li><p>boolean endsWith(String)</p>
</li>
<li><p>trim() 移除<code>首尾</code>空白字符，包括空格、\t、\r、\n。返回的是<code>新的字符串</code>。</p>
</li>
<li><p>substring(startInd, endInd)</p>
</li>
<li><p>toUpperCase()、toLowerCase()</p>
</li>
<li><p>replace(char, char)</p>
</li>
<li><p>replace(CharSequence, CharSequence)</p>
</li>
<li><p>replaceAll(String, String) 正则表达式</p>
</li>
<li><p>String[] split(String)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// 可以传入正则表达式</span></span><br><span class="line"><span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>static String join()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;~~&quot;</span>, arr);</span><br><span class="line"><span class="comment">// &quot;A~~B~~C&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>static String String.valueOf(int)  &#x2F;&#x2F; boolean, Object</p>
</li>
<li><p>static int Integer.parseInt(String)</p>
</li>
<li><p>static Integer Integer.valueOf(String)</p>
</li>
</ul>
<p><strong>注意：</strong><code>Integer I2 = Integer.getInteger(&quot;123&quot;);</code> I2 不是 123，而是环境变量名为 123 的值。</p>
<ul>
<li><p>char[] toCharArray()，String 转为 char[]</p>
</li>
<li><p>new String(char[])，构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] cs = s.toCharArray();  <span class="comment">// s 会复制一份新的 char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);  <span class="comment">// cs 也会被复制一份新的</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>String 转换为 byte[]：</p>
<ul>
<li><p>byte[] getBytes() &#x2F;&#x2F; 不推荐，使用操作系统默认的编码（Win 下默认是 GBK）</p>
</li>
<li><p>byte[] getBytes(String)</p>
</li>
<li><p>byte[] getBytes(Charset)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bs1 = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] bs2 = s.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(bs1, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(bs2, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串构建类"><a href="#字符串构建类" class="headerlink" title="字符串构建类"></a>字符串构建类</h3><p>String 可以用<code>+</code>拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  s = s + String.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次循环都会创建新的字符串对象</li>
<li>绝大部分都是临时对象，浪费内存</li>
<li>影响 GC（Garbage Collection）效率</li>
</ul>
<p>StringBuilder 可以高效拼接字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  sb.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>

<ul>
<li>StringBuilder 是可变对象</li>
<li>StringBuilder 可以预分配缓冲区</li>
</ul>
<p>StringBuilder 还可以进行链式操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sb</span> <span class="operator">=</span> newStringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">  .append(name)</span><br><span class="line">  .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">  .toString();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>我们不需要特别改写字符串<code>+</code>操作，编译器在内部自动把多个连续的<code>+</code>操作优化为 StringBuilder 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>StringBuilder vs. StringBuffer：</p>
<ul>
<li>StringBuilder 和 StringBuffer 接口完全相同</li>
<li>StringBuffer 是 StringBuilder 的线程安全版本</li>
<li>没有必要使用 StringBuffer</li>
</ul>
<p>实现链式操作的关键在于<code>返回实例本身</code>（函数式编程？）。</p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>中文编码：GB2132、GBK、GB18030（本质上是一样的，但后面的字符数更多一些）。一个中文字符占 2 个字节，第一个字节最高位是 1。这个标准是由中国定义的。</p>
<p>其它语言编码： Shift_JIS（日本）、Euc-kr（韩文）。</p>
<p>全球统一编码：Unicode。一个 Unicode 字符通常占用 2 个字节。Java 使用 Unicode 编码。</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yn368.jpg" alt="常见的编码方式"></p>
<p>有了 Unicode 为什么还需要 UTF-8？</p>
<p>因为，英文 Unicode 编码和 ASCII 不一致，包含大量英文的文本会浪费空间。而且很多原来不能识别 Unicode 的软件会报错，不能兼容。而 UTF-8 是<code>变长编码</code>，英文 UTF-8 编码和 ASCII 一致。（还要容错能力强？）</p>
<p><strong>始终优先考虑 UTF-8 编码！</strong></p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yasac.jpg" alt="UTF-8 编码长度规定的方法"></p>
<p>上图中，1110 开头说明占用 3 个字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> c1; <span class="comment">// 65  得到 Unicode 编码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> c2; <span class="comment">// 20013</span></span><br></pre></td></tr></table></figure>

<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>JDK 为每种基本类型都创建了对应的包装类型：</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
</tbody></table>
<p>在int、Integer 和 String 的相互转换中，特别注意 Integer.getInteger(String) 是从系统环境变量中读取系统变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> n1.intValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> n1.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// WARNING:</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">prop</span> <span class="operator">=</span> Integer.getInteger(<span class="string">&quot;cpus&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器的自动装箱：（JDK &gt;&#x3D; 1.5）</p>
<ul>
<li>自动装箱和自动拆箱只发生在<code>编译阶段</code></li>
<li>装箱和拆箱会影响执行效率</li>
<li>编译后的 class 代码是严格区分基本类型和引用类型的</li>
<li><strong>Integer -&gt; int 执行时可能会报错（null）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">99</span>;  <span class="comment">// Integer.valueOf(99)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;  <span class="comment">// n.intValue()</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> i + n;</span><br><span class="line"><span class="comment">// Integer s = Integer.valueOf(i + n.intValue());</span></span><br><span class="line"></span><br><span class="line">Object[] arr = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">9999</span>;  <span class="comment">// Integer.valueOf(9999)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;  <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure>

<p>包装类还定义了一些静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">t</span> <span class="operator">=</span> Boolean.TRUE;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">f</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;  <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE;  <span class="comment">// -2147483648</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sizeOfLong</span> <span class="operator">=</span> Long.SIZE;  <span class="comment">// 64 bits</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesOfLong</span> <span class="operator">=</span> Long.BYTES;  <span class="comment">// 8 bytes</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>维基百科：JavaBeans 是 Java 中一种<code>特殊的类</code>，可以将多个<strong>对象封装到一个对象</strong>（bean）中。其特点是<code>可序列化</code>，提供<code>无参构造器</code>，提供 getter 方法和 setter 方法访问对象的属性。名称中的 Bean 是 Java 的<code>可重用软件组件</code>的惯用叫法。</p>
<p>属性只是一种通用的叫法，它并不是 Java 的语法规定。</p>
<p>符合命名规范的 class 被称为 JavaBean：</p>
<ul>
<li><code>private</code>Type field</li>
<li>public Type getField()  &#x2F;&#x2F; boolean 字段的读方法是：isXXX()</li>
<li>public void setField(Type value)</li>
<li>必须提供<code>空</code>的构造方法</li>
<li>实现 Serializable 接口（可选）</li>
</ul>
<p>通常把一组对应的 getter 和 setter 方法称为<code>属性</code>（Property）。</p>
<p><strong>属性只需要定义 getter &#x2F; setter 方法，不一定需要对应的字段，如 child 是只读属性。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>方便 IDE 工具读写属性</li>
<li>传递数据</li>
<li>枚举属性</li>
<li>封装数据（？）</li>
<li>可重用的组件（？）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 体现封装、抽象、代码复用</span></span><br><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arges)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : bi.getPropertyDescriptors()) &#123;</span><br><span class="line">      printPropertyDescriptor(pd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> vodi <span class="title function_">printPropertyDescriptor</span><span class="params">(PropertyDescriptor pd)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pd.getName();</span><br><span class="line">    Class&lt;?&gt; clazz = pd.getPropertyType();</span><br><span class="line">    <span class="keyword">if</span> (class == <span class="literal">null</span> || name.equals(<span class="string">&quot;class&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">read</span> <span class="operator">=</span> pd.getReadMethod();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">write</span> <span class="operator">=</span> pd.getWriteMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;----- PropertyDescriptor -----&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 enum 定义常量：</p>
<ul>
<li>关键字 enum 定义常量类型</li>
<li>常量本身带有类型信息</li>
<li>使用 &#x3D;&#x3D; 比较：<code>if (day == Weekday.FRI) &#123;...&#125;</code></li>
</ul>
<p>实际上编译器编译出的 class 是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但注意的是，直接编写 class 无法通过编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Color</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 不能通过 new 创建实例</span></span><br><span class="line">  <span class="comment">// 所有常量都是唯一实例（引用类型）</span></span><br><span class="line">  <span class="comment">// 可以用于 switch 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用于 foreach：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Weekday day : Weekday.values()) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Weekday</span> <span class="variable">fri</span> <span class="operator">=</span> Weekday.FRI;</span><br><span class="line"><span class="comment">// - fri.name() - &quot;FRI&quot;  不要用 toString 方法</span></span><br><span class="line"><span class="comment">// - fri.ordinal() - &quot;5&quot;  通常没什么意义</span></span><br><span class="line"><span class="comment">// - Weekday.valueOf(&quot;FRI&quot;).name()</span></span><br></pre></td></tr></table></figure>

<p>可以添加实例字段和方法，且构造方法需要声明为 private。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  SUN(<span class="string">&quot;星期日&quot;</span>), MON(<span class="string">&quot;星期一&quot;</span>), TUE(<span class="string">&quot;星期二&quot;</span>), WED(<span class="string">&quot;星期三&quot;</span>), THU(<span class="string">&quot;星期四&quot;</span>), FRI(<span class="string">&quot;星期五&quot;</span>), SAT(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String chinese;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(String chinese)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toChinese</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Chinese;</span><br><span class="line">  &#125; <span class="comment">// 使用的时候用 fri.toChinese() 得到不同的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><p>Math 提供了数学计算的静态方法：</p>
<ul>
<li>abs &#x2F; min &#x2F; max</li>
<li>pow &#x2F; sqrt &#x2F; exp &#x2F; log &#x2F; log10</li>
<li>sin &#x2F; cos &#x2F; tan &#x2F; asin&#x2F; acos …</li>
</ul>
<p>常量：</p>
<ul>
<li>PI &#x3D; 3.14159 …</li>
<li>E &#x3D; 2.71828 …</li>
</ul>
<p>Math.random() 生成一个随机数（伪随机）：</p>
<ul>
<li>0 &lt;&#x3D; 随机数 &lt; 1</li>
<li>可用于生成某个区间的随机数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 &lt;= R &lt; 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">x1</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="comment">// MIN &lt;= R &lt; MAX</span></span><br><span class="line"><span class="type">long</span> <span class="variable">MIN</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">9000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">x2</span> <span class="operator">=</span> Math.random() * (MAX - MIN) + MIN;</span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> (<span class="type">long</span>) x2;</span><br></pre></td></tr></table></figure>

<p>Random 生成伪随机数：</p>
<ul>
<li>nextInt &#x2F; nextLong &#x2F; nextFloat …</li>
<li>nextInt(N) 生成不大于 N 的随机数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt();</span><br><span class="line">r.nextLong();</span><br><span class="line">r.nextFloat();</span><br><span class="line">r.nextDouble();</span><br><span class="line">r.nextInt(<span class="number">10</span>);  <span class="comment">// 0 ~ 9</span></span><br></pre></td></tr></table></figure>

<p>SecureRandom() 可以用来创建安全的随机数，但是比较慢。</p>
<p>大整数：</p>
<p>BigInteger 用任意多个 int[] 来表示非常大的整数。BigDecimal 类似，两者都继承自 Number。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">big</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;21321321312312&quot;</span>);</span><br><span class="line">System.out.println(big.pow(<span class="number">5</span>));</span><br><span class="line">System.out.println(big.multiply(big));</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> BigDecimal(<span class="string">&quot;123.10&quot;</span>);  <span class="comment">// 它可以精确地表示浮点数，比如 0.1</span></span><br><span class="line">System.out.println(bd);</span><br></pre></td></tr></table></figure>



<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>介绍 Java 的异常体系，掌握如何正确捕获并处理异常，如何自定义异常，如何使用断言和日志。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h4><p>Java 使用异常来表示错误：</p>
<ul>
<li>异常是 class，本身带有类型信息</li>
<li>异常可以在任何地方抛出</li>
<li>异常只需要在上层捕获，和方法调用分离</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> processFile(<span class="string">&quot;/Users/chuck/Desktop/test.txt&quot;</span>);</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  <span class="comment">// file not found</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">  <span class="comment">// no read permission</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e &#123;</span><br><span class="line">  <span class="comment">// io error</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">// other error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的异常也是 class：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1aq9b.jpg" alt="Java 异常类图"></p>
<p>其中，必须捕获的异常：</p>
<ul>
<li>Exception 及其子类，但不包括 RuntimeException 及其子类</li>
<li>要捕获的异常称为<code>Checked Exception</code></li>
</ul>
<p>Why？</p>
<ul>
<li><code>Error</code>是发生了严重错误，程序对此一般无能为力：OutOfMemoryError、NoClassDefFoundError、StackOverflowError 等等。</li>
<li><code>Exception</code>是发生了<code>运行时</code>逻辑错误，应该捕获异常并处理：IOException、NumberFormatException、NullPointerException、IndexOutOfBoundsException。</li>
</ul>
<p>对可能抛出的<code>Checked Exception</code>的方法调用：</p>
<ul>
<li><p>捕获 Exception 并处理（前面的例子）</p>
</li>
<li><p>不捕获但通过 throws 声明，但仍需在上层捕获</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throws 在这里相当于延后捕获，但 main() 是最后捕获的机会了！</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">  <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = toGBK(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="捕获异常（Catch）"><a href="#捕获异常（Catch）" class="headerlink" title="捕获异常（Catch）"></a>捕获异常（Catch）</h4><p>catch 的顺序非常重要，<strong>子类必须写在前面</strong>；且 finally 语句块保证有无错误都会执行，但不是必须的。</p>
<p>Multi-Catch（JDK &gt;&#x3D; 1.7）：如果某些异常的处理逻辑相同，可以写成<code>catch (IOException | NumberFormatException e) &#123;&#125;</code>，但在好的设计中它们<code>不能存在继承关系</code>。</p>
<h4 id="抛出异常（Throw）"><a href="#抛出异常（Throw）" class="headerlink" title="抛出异常（Throw）"></a>抛出异常（Throw）</h4><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vclwx.jpg" alt="异常的传播"></p>
<p>如何抛出异常：</p>
<ol>
<li>创建某个 Exception 实例</li>
<li>用 throw 抛出异常（注意 throw 没<code>s</code>）</li>
</ol>
<p>如何转换异常：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/if1nx.jpg" alt="异常的转换"></p>
<p>但是，写成<code> IllegalArgumentException(e)</code>可以使新的 Exception 保持原始异常的信息。</p>
<p>但注意：在抛出异常前，finally 语句会保证执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    process1(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(catched);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>); <span class="comment">// throw 后会执行</span></span><br><span class="line">    <span class="comment">// 但如果 finally 语句抛出异常，则 catch 语句不再抛出（被屏蔽），如在 finally 里使用：</span></span><br><span class="line">    <span class="comment">// throw new NullPointerException();</span></span><br><span class="line">    <span class="comment">// 在这种情况下，没有被抛出的异常被称为「被屏蔽」的异常（Suppressed Exception）</span></span><br><span class="line">    <span class="comment">// 因此，我们要保证在 finally 中尽量不要抛出异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果保存所有的异常信息？</p>
<ul>
<li>用 origin 变量保存原始异常</li>
<li>如果存在原始异常，用 addSuppressed() 添加新异常</li>
<li>如果存在原始异常，或者新异常，最后在 finally 抛出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Exception</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  process(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  origin = e;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(); <span class="comment">// finally 中抛出异常，屏蔽了 RuntimeException</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin != <span class="literal">null</span>) &#123;</span><br><span class="line">      origin.addSuppressed(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      origin = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (origin != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> origin;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 getSuppressed() 获取所有 Suppressed Exception（JDK &gt;&#x3D; 1.7）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  somethingWrong(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  <span class="keyword">for</span> (Throwable t : e.getSuppressed()) &#123;</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>JDK 定义的常用异常：</p>
<ul>
<li>RuntimeException<ul>
<li>NullPointerException</li>
<li>IndexOutOfBoundsException</li>
<li>SecurityException</li>
<li>IllegalArgumentException<ul>
<li>NumberFormatException</li>
</ul>
</li>
</ul>
</li>
<li>IOException<ul>
<li>UnsupportedCharsetException、FileNotFoundException、SocketException 等</li>
</ul>
</li>
<li>ParseException、GeneralSecurityException、SQLException、TimeoutException 等</li>
</ul>
<p>自定义异常：</p>
<ul>
<li>从适合的 Exception 派生</li>
<li>从 RuntimeException 派生</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BadFileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span> &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐从 RuntimeException 派生，这样不需要强制捕获自定义的异常。catch (RuntimeException) 能捕获到自己的异常。父类能捕获到子类，而不需要自己写 catch (XxxxxxException)。</p>
<p>通常，我们如下定义新的异常关系树：</p>
<ul>
<li>从适合的 Exception 派生 BaseException</li>
<li>其他 Exception 从 BaseException 派生</li>
</ul>
<p>自定义异常应该提供多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// throw new BaseException(&quot;IOError&quot;, e);</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message, cause);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="断言与日志"><a href="#断言与日志" class="headerlink" title="断言与日志"></a>断言与日志</h3><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>断言（Assertion）是一种<code>程序调试</code>的方式。断言很少被使用，更好的方式是编写单元测试。<br>对可恢复的错误不能使用断言，而应该抛出异常。如不可恢复的错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span>  <span class="comment">// 否则抛出 AssertionError</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>; <span class="comment">// 可选的断言消息</span></span><br></pre></td></tr></table></figure>

<p>可恢复的错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 从而实现可恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 默认关闭断言指令，要用<code>-ea</code>参数打开。</p>
<ul>
<li>可以指定特定的类启用断言<ul>
<li>-ea:com.chuck.helloworld.Main</li>
</ul>
</li>
<li>可以指定特定的包启用断言<ul>
<li>-ea:com.chuck</li>
</ul>
</li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>什么是日志（Logging）：</p>
<ul>
<li>日志是为了代替<code>System.out.println()</code></li>
<li>可以设置输出样式</li>
<li>可以设置输出级别，禁止某些级别输出</li>
<li>可以被重定向到文件</li>
<li>可以被包名控制日志级别</li>
</ul>
<p>JDK 内置了 Logging：Java.util.logging：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">logger.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">logger.log(Level.WARNING, <span class="string">&quot;warning...&quot;</span>);</span><br><span class="line">logger.warning(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>JDK Logging 的局限：</p>
<ul>
<li>JVM 启动时读取配置文件并完成初始化</li>
<li>JVM 启动时无法修改配置</li>
<li>需要在 JVM 启东时传递参数：-Djava.util.logging.config.file&#x3D;config-file-name</li>
</ul>
<p>Common Logging 是 Apache 创建的日志模块：</p>
<ul>
<li>可以挂接不同的日志系统</li>
<li>可以通过配置文件指定挂接的日志系统</li>
<li>自动搜索并使用 Log4j（一个由 Apache 开发的更强大的日志系统）</li>
<li>使用 JDK Logging（JDK &gt;&#x3D; 1.4）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.warn(<span class="string">&quot;end.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>定义了六个日志级别：FATAL、ERROR、WARNING、INFO、DEBUG、TRACE。</p>
<h2 id="反射与泛型"><a href="#反射与泛型" class="headerlink" title="反射与泛型"></a>反射与泛型</h2><p>介绍 Java 的反射、注解和泛型，掌握如何使用反射访问字段、方法、构造方法，如何使用注解，如何使用泛型，Java 泛型的实现原理，extends 和 super 通配符的用法。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h4><p>class &#x2F; interface 的数据类型是 Class。每加载一个 class，JVM 就为其创建一个 Class 类型的实例，并关联起来。</p>
<ul>
<li>加载 String 类（读取 String.class 文件）</li>
<li>为 String 类创建一个 Class 实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>️以 String 为例：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/v4ew1.jpg" alt="Class 实例（String）"></p>
<ul>
<li>JVM 为每个加载的 class 创建对应的 Class 实例，并在实例中保存该 class 的所有信息。</li>
<li>如果获取了某个 Class 实例，则可以获取到该实例对应的 class 的所有信息。</li>
<li>通过 Class 实例获取 class 信息的方法称为<code>反射</code>（Reflection）。</li>
<li>Class 实例在 JVM 中是<code>唯一</code>的。</li>
</ul>
<p>获取方法：</p>
<ol>
<li>Type.class  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure></li>
<li>getClass()  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure></li>
<li>Class.forName()  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Class 实例比较和 instanceof 的差别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类和子类的 class 不一样</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>反射的目的</code>是当获得某个 Object 实例时，我们可以获取该 Object 的 class 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> cls.getName(); <span class="comment">// &quot;java.lang.String&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sname</span> <span class="operator">=</span> cls.getSimpleName(); <span class="comment">// &quot;String&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> cls.getPackage().getName();   <span class="comment">// &quot;java.lang&quot;</span></span><br></pre></td></tr></table></figure>

<p>还可以从 Class 实例判断 class 类型：</p>
<ul>
<li>isInterface()</li>
<li>isEnum()</li>
<li>isArray()</li>
<li>isPrimitive()</li>
</ul>
<p><strong>注意：</strong>int 虽然是基本类型，但 JVM 内部会给它创建 class 实例。</p>
<p>从 Class 实例中初始化新的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class; <span class="comment">// 需要强制转换</span></span><br><span class="line"><span class="comment">// or: Class&lt;String&gt; cls = String.class;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance(); <span class="comment">// 局限：只能使用默认构造方法</span></span><br></pre></td></tr></table></figure>

<p>利用 JVM 动态加载 class 的特性，可以在运行期根据条件加载不同的实现类。即使类不存在，我们也可以在运行期动态地加载 class。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(name); <span class="comment">// 不存在会抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h4><p>通过 Class 实例获取字段信息：</p>
<ul>
<li>getField(name)：获取某个 public 的 field（包括父类）</li>
<li>getDeclaredField(name)：获取当前类的某个 field（不包括父类）</li>
<li>getFields()：获取所有 public 的 field（包括父类）</li>
<li>getDeclaredFields()：获取当前类的所有 field（不包括父类）</li>
</ul>
<p>如果用 getField(name) 获取 private 字段，会得到 NoSuchFieldException。应该用 getDeclaredField(name) 获取当前类的 private 字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> n.getClass();</span><br><span class="line">Field[] fs = cls.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : fs) &#123;</span><br><span class="line">  f.getName(); <span class="comment">// field name</span></span><br><span class="line">  f.getType(); <span class="comment">// field type</span></span><br><span class="line">  f.getModifiers();  <span class="comment">// modifiers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> f.get(n);  <span class="comment">// 123，相当于 n.value</span></span><br><span class="line"><span class="comment">// f.get(Object) 获取一个实例的该字段的值。这里反过来了，正常的思路是 n.value()，这就是反射</span></span><br><span class="line"><span class="comment">// 但注意，如果 value 字段是 private，将会报错 IllegalAccessException</span></span><br><span class="line">f.setAccessible(<span class="literal">true</span>); <span class="comment">// 可以使得它可以被访问</span></span><br><span class="line">f.set(n, <span class="number">123123123123</span>);</span><br></pre></td></tr></table></figure>

<p>访问静态字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;number&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span>  f.get(<span class="literal">null</span>); <span class="comment">// 实例对象设置成 null 就可以了</span></span><br></pre></td></tr></table></figure>

<p><code>setAccessible(true)</code>可能会失败：</p>
<ul>
<li>定义了 SecurityManager</li>
<li>SecurityManager 的规则阻止对该 Field 设置 accessible（规则应用于所有 java 和 javax 开头的 package 的类）</li>
</ul>
<p>通常自己编写的类或者第三方的类是没有这样的限制的。</p>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>通过 Class 实例获取方法信息：</p>
<ul>
<li>getMethod(name, Class…)：获取某个 public 的 method（包括父类）</li>
<li>getDeclaredMethod(name, Class…)：获取当前类的某个 method（不包括父类）</li>
<li>getMethods()：获取所有 public 的 methods（包括父类）</li>
<li>getDeclaredMethods()：获取当前类的所有 methods（不包括父类）</li>
</ul>
<p><strong>注意：</strong>上面有的方法中有个 Class…，这是可变参数，或者可以传递数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> n.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) m1.invoke(n);   <span class="comment">// Object invoke(Object obj)</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;compareTo&quot;</span>, Integer.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (Integer) m.invoke(n, <span class="number">456</span>); <span class="comment">// Object invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">// 相当于 int r = n.compareTo(456)</span></span><br></pre></td></tr></table></figure>

<p>记得，还可以使用 JavaBean 获得方法信息。</p>
<p>以上 API 保证了多态的正确性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person p = new Student();</span></span><br><span class="line"><span class="comment">// p.hello();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure>

<h4 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h4><p>Class.newInstance() 只能调用 public 无参数的构造方法。</p>
<p><strong>注意：</strong>Integer 类不能这样用，因为它没有无参数的构造方法！！！</p>
<p>Constructor 对象包含一个构造方法的所有信息，通过它可以创建一个实例：</p>
<ul>
<li>getConstructor(typeClass)：获取某个 public 的 Constructor</li>
<li>getDeclaredConstructor(typeClass)：获取某个 Constructor</li>
<li>getConstructors()：获取所有 public 的 Constructor</li>
<li>getDeclaredConstructors()：获取所有 Constructor</li>
</ul>
<p><strong>注意：</strong>Constructor 总是当前类定义的方法，不会获得父类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Integer.class;</span><br><span class="line"><span class="comment">// Integer(int)</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> cls.getConstructor(<span class="type">int</span>.class); <span class="comment">// 注意和 Integer.class 是不同的</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer(String)</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> cls.getConstructor(String.class);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>


<h4 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h4><p>获取父类的 Class：</p>
<ul>
<li>Class getSuperClass()</li>
<li>Object 的父类是 null</li>
<li>interface 的父类是 null（interface 的父类要用 getInterfaces()）</li>
</ul>
<p>获取当前类<strong>直接</strong>实现的 interface：</p>
<ul>
<li>Class[] getInterfaces()</li>
<li>没有 interface 的 class 返回空数组</li>
<li>interface 返回继承的 interface</li>
<li>如果要获取父类的 interface，需要递归调用方法 getInterfaces()</li>
</ul>
<p>判断向上转型是否成立：</p>
<ul>
<li>isAssignmentFrom(Class)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (People.class.isAssignableFrom(Student.class)) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;People p = new Student(); -- ok&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Student s = new People(); -- ok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  output: People p = new Student(); -- ok</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>对代码逻辑没有任何影响，但是如何使用注解是工具决定的。</p>
<ul>
<li>@Override：让编译器检查该方法是否正确地实现了覆写</li>
<li>@Deprecated：告诉编译器该方法已经被标记为「作废」，在其他地方引用将会出现编译警告</li>
<li>@SuppressWarnings</li>
</ul>
<p>注解可以定义配置参数：</p>
<ul>
<li>配置参数由注解类型定义</li>
<li>配置参数可以包括：<ul>
<li>所有基本类型</li>
<li>String</li>
<li>枚举类型</li>
<li>数组</li>
</ul>
</li>
<li>配置参数必须是常量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="meta">@Test(timeout=100)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺少某个配置参数将使用默认值</li>
<li>如果只写常量，相当于省略了 value 参数</li>
<li>如果只写注解，相当于全部使用默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">  <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Check(value=99)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Check(99)</span>  <span class="comment">// @Check(value=99)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Check</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><p>使用 @interface 定义注解（Annotation）：</p>
<ul>
<li>注解的参数类似无参数方法</li>
<li>可以设定一个默认值（推荐）</li>
<li>把最常用的参数命名为 value（推荐）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 @Target 定义 Annotation 可以被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：ElementType.TYPE</li>
<li>字段：ElementType.FIELD</li>
<li>方法：ElementType.METHOD</li>
<li>构造方法：ElementType.CONSTRUCTOR</li>
<li>方法参数：ElementType.PARAMETER</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要用到多个地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>生命周期：</p>
<p>使用 @Retention 定义 Annotation 的生命周期：</p>
<ul>
<li><code>仅编译器</code>：RetentionPolicy.SOURCE<ul>
<li>编译器在编译时直接丢弃，如 @Override</li>
</ul>
</li>
<li><code>仅 class 文件</code>：RetentionPolicy.CLASS<ul>
<li>仅存储在 class 文件中</li>
</ul>
</li>
<li><code>运行期</code>：RetentionPolicy.RUNTIME<ul>
<li>在运行期可以读取 Annotation</li>
</ul>
</li>
</ul>
<p>如果 @Retention 不存在，则该 Annotation 默认为 CLASS。通常自定义的 Annotation 都是 RUNTIME。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 @Inherited 定义子类是否可以继承父类定义的 Annotation：</p>
<ul>
<li>仅针对 @Target 为 TYPE 类型（即类、接口）的 Annotation<ul>
<li>仅针对 class 的继承</li>
<li>对 interfade 的继承无效</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>总结定义 Annotation 的步骤：</p>
<ul>
<li>用 @interface 定义注解</li>
<li>用<code>元注解</code>（meta annotation）配置注解<ul>
<li><code>@Target</code>：必须设置</li>
<li><code>@Retention</code>：一般设置为 RUNTIME，默认是 CLASS</li>
<li>通常不必写 @Inherited、@Repeatable 等等</li>
</ul>
</li>
<li>定义注解参数和默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NotNull</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotNull &#123;</span><br><span class="line">    <span class="comment">// 没有任何参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="meta">@Range(max = 20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age</span><br></pre></td></tr></table></figure>

<h4 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h4><p>如何使用注解完全由工具决定的，这里只针对 RUNTIME 类型的注解。</p>
<p>如何读取 RUNTIME 类型的注解？</p>
<ul>
<li>Annotation 也是 class</li>
<li>所有 Annotation 继承自 java.lang.annotation.Annotation</li>
<li>使用反射 API</li>
</ul>
<p>判断 Annotation 是否存在：</p>
<ul>
<li>Class.isAnnotationPresent(Class)</li>
<li>Field.isAnnotationPresent(Class)</li>
<li>Method.isAnnotationPresent(Class)</li>
<li>Constructor.isAnnotationPresent(Class)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line">cls.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>

<p>获取 Annotation：</p>
<ul>
<li>Class.getAnnotation(Class)</li>
<li>Field.getAnnotation(Class)</li>
<li>Method.getAnnotation(Class)</li>
<li>Constructor.getAnnotation(Class)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> report.type();</span><br><span class="line"><span class="type">String</span> <span class="variable">level</span> <span class="operator">=</span> report.level();</span><br></pre></td></tr></table></figure>

<p>继续之前的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPerson</span><span class="params">(Person p)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;check &quot;</span> + p + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">  <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Person.class;</span><br><span class="line">  <span class="keyword">for</span> (Field f : clz.getFields()) &#123;</span><br><span class="line">    checkField(f, p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkField</span><span class="params">(Field f, Person p)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (f.isAnnotationPresent(NotNull.class)) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">r</span> <span class="operator">=</span> f.get(p);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error: field&quot;</span> + f.getName() + <span class="string">&quot;is null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 但如果按照上面的方法是读取不了的，因为 NotNull 不是 RUNTIME。要加上 @Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">  <span class="keyword">if</span> (f.isAnnotationPresent(Range.class)) &#123;</span><br><span class="line">    <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> f.getAnnotation(Range.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (Integer) f.get(p);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; range.min() || n &gt; range.max()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error: field &quot;</span> + f.getName() + <span class="string">&quot;is out of range.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外：</p>
<ul>
<li>对 JavaBean 的属性值可以按规则进行检查</li>
<li>JUnit 会自动运行 @Test 注解的测试方法</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/claram/article/details/51889214">Java泛型一：泛型定义及规则</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/claram/article/details/51899898">Java泛型二：泛型类 泛型接口 泛型方法详解</a></li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>如果没有泛型，需要强制转型来引用里面的对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList 里面没有用到泛型，一律用 Object</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>必须把 ArrayList 变成一种模板 ArrayList<T>，也可以叫做参数类类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> T[] array;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span> <span class="params">(<span class="type">int</span> index)</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>注意泛型的继承关系：</p>
<p>不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>，因为<code>ArrayList&lt;Number&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>两者没有继承关系。</p>
<h4 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h4><p>在不使用泛型的时候，Java 总是会自动为泛型类型提供一个相应的原始类型。所谓原始类型就是指泛型的第一个限定类型（<code>从左向右</code>，比如下面的 Comparable），无限定类型泛型的原始类型默认为 Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot; World!&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// T 的原始类型为 Number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serilizable, V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// K 的原始类型为 Comparable &amp; Serilizable，V 的原始类型为 Object。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了提高效率，应该将标签接口（没有方法的接口）放在边界限定列表的末尾。</span></span><br></pre></td></tr></table></figure>

<p>调整<code>extends Serializable &amp; Comparable</code>顺序后，K 的原始类型为 Serializable ，V 的原始类型为 Object。</p>
<p>注意：extends后可以继承多个类、多个接口，原始类型为从左向右排序的第一个类或者接口。为了提高效率，应该将标签接口（即没有方法的接口）放在边界限定列表的末尾。清楚了原始类型之后，我们接下来讲解类型擦除。</p>
<p>可以省略部分声明，编译器能自动推断出的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line"><span class="comment">// 省略后：（也叫 &lt;&gt; 为 Diamond）</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h4><ul>
<li>编写泛型类比普通类复杂</li>
<li>泛型类一般用在集合类，如：ArrayList<T></li>
<li><strong>很少需要编写泛型类</strong></li>
</ul>
<p>泛型类型<code>&lt;T&gt;</code>不能用于静态方法：</p>
<ul>
<li>编译错误：编译器无法在静态字段或静态方法中使用泛型类型 <T>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在 static 后面加了个<code>&lt;T&gt;</code>就不会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这个和上面定义的<code>&lt;T&gt;</code>没什么关系，是方法的泛型类型（这里是泛型静态方法），一般应该改写为其它字母，如 K。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/he0r0.jpg" alt="一张图（什么意思？完了，看不懂自己的笔记）"></p>
<h4 id="擦拭法（Type-Erasure）"><a href="#擦拭法（Type-Erasure）" class="headerlink" title="擦拭法（Type Erasure）"></a>擦拭法（Type Erasure）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/claram/article/details/51969324">Java泛型四：泛型实现原理之类型擦除</a></p>
<p>擦拭法是 Java 泛型的实现方式。在泛型代码编译的时候，编译器其实把所有类型的泛型类型 T 视为 Object 类型。换句话说，虚拟机其实对泛型一无所知，所有的工作都是编译器做的。最终加了强制转换。</p>
<p>擦拭法的局限：</p>
<ul>
<li><T> 不能是基本类型（和 C++ 的不同，但是可以用包装类解决这个问题）</li>
<li>Object 字段无法持有基本类型</li>
<li>无法取得带泛型的 Class（因为在编译后就不存在范型类型了）</li>
<li>无法判断带泛型的 Class</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>&lt;String&gt;();</span><br><span class="line"><span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line"><span class="keyword">if</span> (p1 <span class="keyword">instanceof</span> People) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;YES1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p2 <span class="keyword">instanceof</span> People) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;YES2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 <span class="keyword">instanceof</span> People&lt;String&gt;) &#123;</span><br><span class="line">  <span class="comment">/* ERROR: Use the form People&lt;?&gt; instead since further generic type information will be erased at runtime */</span></span><br><span class="line">  System.out.println(<span class="string">&quot;YES3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p2 <span class="keyword">instanceof</span> People&lt;?&gt;) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;YES4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output: YES1,2,4 */</span></span><br></pre></td></tr></table></figure>

<p>不能实例化 T 类型，因为擦拭后实际上是 new Object()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> T first;</span><br><span class="line">  <span class="keyword">private</span> T last;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// compile error:</span></span><br><span class="line">    first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>而应该借助 Class<T>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructor</span></span><br><span class="line"><span class="keyword">private</span> T first;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">    first = clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(String.class); <span class="comment">// OK</span></span><br><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(Integer.class); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>再有，要注意擦拭法带来的方法重名问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T pair)</span> &#123;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/xgzmc.jpg" alt="范型方法"></p>
<p>在调用泛型方法的时候，在不指定泛型的情况下，泛型变量的类型为该方法中的<code>几种类型的同一个父类的最小级</code>，直到 Object。在指定泛型的时候，该方法中的几种类型必须是该泛型实例类型或者其子类。</p>
<p>泛型继承：子类可以获取父类的泛型类型 <T>。</p>
<ul>
<li>父类的类型是 Pair<Integer></li>
<li>子类的类型是 IntPair</li>
<li>子类可以获取父类的泛型类型 Integer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line"><span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperClass();</span><br><span class="line"><span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">  <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) t;</span><br><span class="line">  Type[] types = pt.getActualTypeArguments();</span><br><span class="line">  <span class="type">Type</span> <span class="variable">firstType</span> <span class="operator">=</span> types[<span class="number">0</span>];</span><br><span class="line">  Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">  System.out.println(typeClass);  <span class="comment">// Integer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Type 接口：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/aqvyb.jpg"></p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>转移阵地：<a href="http://junhaow.com/2019/02/14/046%20%7C%20%E5%A5%BD%E5%A5%BD%E8%B0%83%E6%88%8F%20Java%20%E8%8C%83%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%BE%B9%E7%95%8C%E9%99%90%E5%AE%9A%E8%A7%84%E5%88%99/">好好调戏 Java 范型中的通配符以及边界限定规则</a></p>
<h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><p>部分反射 API 是泛型，如 Class<T>：</p>
<ul>
<li>T newInstance()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile warning if not w/ (String)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) clazz.newInstance();</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> clazz.newInstance(); <span class="comment">// T newInstance()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Class&lt;? super T&gt; getSuperclass()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? <span class="built_in">super</span> String&gt; sup = clazz.getSuperclass();</span><br></pre></td></tr></table></figure>

<ul>
<li>Constructor<T></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> cons.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>


<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20928981/answer/117521433">java为什么不支持泛型数组？ - 胖君的回答 - 知乎</a></p>
<p>可以声明带泛型的数组，但不能用 new 创建带泛型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = <span class="literal">null</span>; <span class="comment">// OK</span></span><br><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">2</span>]; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="comment">// 只能通过强制转型实现</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>这里实际上是利用了编译器的类型擦除，所以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ps.getClass() == Pair[].class) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不能直接创建 T[] 数组：擦拭后代码变成 new Object[5]。</p>
<ol>
<li>借助 Class<T>：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abc</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// compile error</span></span><br><span class="line">  T[] createArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">5</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 必须借助 Class&lt;T&gt;</span></span><br><span class="line">  T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(cls, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用可变参数创建 T[] 数组，用 @SafeVarargs 消除警告：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayHelper</span> &#123;</span><br><span class="line">  <span class="meta">@SafeVarargs</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">    <span class="keyword">return</span> objs;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] ss = ArrayHelper.asArray(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Integer[] ns = ArrayHelper.asArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>


<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>介绍 Java 集合的常用类，理解并掌握常用集合类包括 List、Set、Map、Queue、Stack 的数据结构、用法和适用场景。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>集合（Collection），这里不是指 set。</p>
<p>定义：一个 Java 对象可以在内部持有若干其它 Java 对象，并对外提供访问接口。Java 的数组可以看作是一种集合。</p>
<p>JDK 自带的 java.util 包提供了集合类：</p>
<ul>
<li>Collection：集合类的根接口<ul>
<li>List：一种有序列表</li>
<li>Set：一种保证没有重复元素的集合</li>
<li>Map：一种通过 Key 查找 Value 的映射表集合</li>
</ul>
</li>
</ul>
<p>Java 集合设计的特点：</p>
<ul>
<li><code>接口和实现相分离</code>：List 接口，ArrayList、LinkedList 实现</li>
<li><code>支持泛型</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure></li>
<li><code>访问集合有统一的方法</code>：迭代器（Iterator），都实现了 Iterable 接口</li>
</ul>
<p>JDK 的部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li>Hashtable：一种线程安全的 Map 实现</li>
<li>Vector：一种线程安全的 List 实现</li>
<li>Stack：基于 Vector 实现的 LIFO 的栈</li>
</ul>
<p>还有，Enumeration<E> 是遗留接口，已被 Iterator<E> 取代。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List<E> 是一种有序链表：</p>
<ul>
<li>void add(E e) 在末尾添加一个元素</li>
<li>void add(int index, E e) 在指定索引添加一个元素</li>
<li>int remove(int index) 删除指定索引的元素</li>
<li>int remove(Object e) 删除某个元素</li>
<li>E get(int index) 获取指定索引的元素</li>
<li>int size() 获取链表大小（包含元素的个数）</li>
</ul>
<p>数组也是有序结构，但是大小固定，且删除元素时需要移动后续元素：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/89tub.jpg" alt="移动后续元素"></p>
<p>List 的元素可以重复，且可以是 null。</p>
<p>ArrayList<E>：内部使用数组存储所有元素。当元素满了时候，会先创建一个新的数组，在复制过去。</p>
<p>ListedList<E>：内部每个元素都指向下一个元素。</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cmult.jpg"></p>
<p>遍历数组的方式：</p>
<ul>
<li><p>在 for 中用 get(i) 来访问，对 ArrayList 来讲效率高，而对 LinkedList 来说较低。</p>
</li>
<li><p>Iterator<E></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123; </span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>foreach（所有实现了 Iterable 接口都可以用这个方法遍历）<br>编译器会自动地把 foreach 循环改写成上面的 Iterator 迭代方式。</p>
</li>
</ul>
<p>List 和 Array 转换：</p>
<ul>
<li>把 List<E> 变为 Array：<ul>
<li>Object[] toArray()</li>
<li><T> T[] toArray(T[] a)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// &#123;1, 2, 3&#125;   new Integer[2] 无效，会被扔掉</span></span><br><span class="line">Integer[] array2 = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>]);</span><br><span class="line"><span class="comment">// &#123;1, 2, 3, null, null&#125;</span></span><br><span class="line">Integer[] array3 = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br><span class="line"><span class="comment">// 最好的办法，大小一一对应。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>把 Array 变为 List<E>：<ul>
<li><T> List<T> Arrays.asList(T… a)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// **注意返回的 list 并不是 ArrayList，而是 List**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 list 对象实际上是 Array 内部实现的一个 List 类，并且是只读的。</span></span><br><span class="line">list.add(<span class="number">4</span>);  <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line"><span class="comment">// 如果想创建 ArrayList，还需做：</span></span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.addAll(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者一行代码：</span></span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));</span><br><span class="line"><span class="comment">// 注意，如果不需要可变的 list，就没必要再转换成 ArrayList</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>List 中的 contains 和 indexOf 会用到所存对象的 equals 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> p.name.equals(<span class="built_in">this</span>.name) &amp;&amp; p.age == <span class="built_in">this</span>.age; <span class="comment">// 但这里有个问题 p.name 可能是空，会报错</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> (p.name == <span class="built_in">this</span>.name || p.name != <span class="literal">null</span> &amp;&amp; p.name.equals(<span class="built_in">this</span>.name)) &amp;&amp; p.age == <span class="built_in">this</span>.age; <span class="comment">// 但这样写好麻烦</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> Objects.equals(p.name, <span class="built_in">this</span>.name) &amp;&amp; p.age == <span class="built_in">this</span>.age;</span><br><span class="line">    <span class="comment">// Objects.equals()</span></span><br><span class="line">    <span class="comment">// null vs. null -&gt; true</span></span><br><span class="line">    <span class="comment">// null vs. &quot;abc&quot; -&gt; false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="使用-Map"><a href="#使用-Map" class="headerlink" title="使用 Map"></a>使用 Map</h4><p>Map&lt;K, V&gt;</p>
<ul>
<li>SortedMap<ul>
<li>TreeMap</li>
</ul>
</li>
<li>HashMap</li>
</ul>
<p>API：</p>
<ul>
<li>V put(K key, V value)</li>
<li>V get(K key)</li>
<li>boolean containsKey(K key)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = ...</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常用的实现类是 HashMap，HashMap 内部存储不保证有序。遍历时的顺序不一定是 put 放入的顺序，也不一定是 Key 的排序顺序。</p>
<p>SortedMap 是有序的（对 Key 排序，和 Value 无关）。</p>
<p>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap 实现。</p>
<p>倒序排序 Key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Person&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="equals-hashCode"><a href="#equals-hashCode" class="headerlink" title="equals() &amp; hashCode()"></a>equals() &amp; hashCode()</h4><p>正确使用 Map 必须保证：</p>
<ul>
<li>作为 Key 的对象必须正确覆写 equals() 方法，例如：String、Integer、Long</li>
<li>作为 Key 的对象必须正确覆写 hashCode() 方法<ul>
<li>如果两个对象相等，则两个对象的 hashCode() 必须相等</li>
<li>如果两个对象不相等，则两个对象的 hashCode() 不需要相等</li>
</ul>
</li>
<li>如果一个对象覆写了 equals() 方法，就必须覆写 hashCode() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private String name;</span></span><br><span class="line"><span class="comment">// private int age;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span> <span class="params">(Object obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(<span class="built_in">this</span>.name, p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 其实就是重新表达要比较的对象</span></span><br><span class="line">  <span class="keyword">return</span> Objects.hash(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>默认的 equals 方法等价于 &#x3D;&#x3D; 方法。</p>
<p>虽然，每个 Java 类都包含 hashCode() 函数。但是，仅仅当创建类的散列表时，该类的 hashCode() 才有用。其作用是：确定该类的每一个对象在散列表中的位置；其它情况下（例如，创建类的单个对象，或者创建类的对象数组等等，没有作用）。</p>
<p>hashCode() 和 equals() 的关系：</p>
<ol>
<li><p>不创建类对应的散列表<br>  在这种情况下，两者没半毛钱关系。hashCode() 根本不会起任何作用。</p>
</li>
<li><p>创建类对应的散列表<br>  如果两个对象相等，那么 hashCode() 值一定相等；如果两个对象 hashCode() 相等，equals 不一定等于 true。（哈希冲突）</p>
</li>
</ol>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>Properties 用于读取配置，<code>.properties</code>文件只能使用 ASCII 编码。</p>
<p>如果要写中文，只能写 Unicode 码，如<code>\u96c6\u5408\u7c7b</code>。</p>
<p>读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件系统中读取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="string">&quot;~/Desktop/setting.properties&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;default description&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 classpath 中读取</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以读取多个<code>.properties</code>文件，后读取的 Key-Value 会覆盖已读取的 Key-Value。这个特性可以让我们先把默认的特性放在 classpath 中。</p>
<p>Properties 实际上侍从 Hashtable 派生：</p>
<ul>
<li>String getProperty(String key) √</li>
<li>void setProperty(String key, String value) √</li>
<li>Object get(Object key) ✕</li>
<li>void put(Object key, Object value) ✕</li>
</ul>
<p>但这种派生实际上是有误的，所以在实际中不要使用后面两个方法。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>Set<ul>
<li>SortedSet<ul>
<li>TreeSet</li>
</ul>
</li>
<li>HashSet</li>
</ul>
</li>
</ul>
<p>Set<E> 用于存储不重复的元素集合：</p>
<ul>
<li>boolean add(E e)</li>
<li>boolean remove(Object o)</li>
<li>boolean contains(Object o)</li>
<li>int size()</li>
</ul>
<p>Set 实际上相当于不存储 Value 的 Map，放入 Set 的元素要正确实现 equals() 和 hashCode() 方法。</p>
<p>Set 不保证有序：</p>
<ul>
<li>HashSet 是无序的</li>
<li>TreeSet 是有序的</li>
<li>实现了 SortedSet 接口的是有序的</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="使用-Queue"><a href="#使用-Queue" class="headerlink" title="使用 Queue"></a>使用 Queue</h4><p>Queue<E> 实现了一个先进先出（FIFO）的队列。LinkedList 实现了 Queue<E> 接口。</p>
<ul>
<li>获取队列长度：size()</li>
<li>添加元素到队尾：boolean add(E e) &#x2F; boolean offer(E e)</li>
<li>获取队列头部元素并删除：E remove() &#x2F; E poll()</li>
<li>获取队列头部元素但不删除：E element() &#x2F; E peek()</li>
</ul>
<p>为什么都有两种方法？</p>
<p>当添加或获取元素失败时，左边的方法返回 Exception，右边的方法返回 false 或 null。</p>
<p>可以先用 isEmpty 判断，避免把 null 添加到队列。</p>
<h4 id="使用-PriorityQueue"><a href="#使用-PriorityQueue" class="headerlink" title="使用 PriorityQueue"></a>使用 PriorityQueue</h4><p>PriorityQueue<E> 的出队顺序与元素的优先级有关，remove() &#x2F; poll(）总是取优先级最高的元素。</p>
<p>放入 PriorityQueue 的元素必须实现 Comparable 接口，或者通过在 new 的时候传入 Comparator 自定义排序的算法。</p>
<h4 id="使用-Deque"><a href="#使用-Deque" class="headerlink" title="使用 Deque"></a>使用 Deque</h4><p>Deque<E> 实现一个双端队列（Double Ended Queue）。</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/9mwh6.jpg" alt="Queue 和 Deque 常用的方法"></p>
<p>Deque 还有：</p>
<ul>
<li>addFirst(E e) &#x2F; offerFirst(E e)</li>
<li>E removeLast() &#x2F; E pollLast()</li>
<li>E getLast() &#x2F; E peekLast()</li>
<li>直接写 offer() 是调用 offerLast 方法，但不要这么用。</li>
</ul>
<p>Deque 的实现类：</p>
<ul>
<li>ArrayDeque</li>
<li>LinkedList</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; obj = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">obj.offerLast(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; obj = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">obj.offerLast(<span class="string">&quot;z&quot;</span>); <span class="comment">// 注意第二个是不会报错的，确实不会。</span></span><br><span class="line"><span class="comment">// 但这样的设计意义在哪里???</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; obj = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">obj.add(<span class="string">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到 LinkedList 是<code>全能选手</code>。但是我们使用的时候总是用特定的接口去引用它，这是因为持有接口，抽象程度更高，而接口本身定义的方法代表了本身特定的用途。</p>
<p>这里可以看出面向对象抽象编程的原则之一：<strong>尽量持有接口，而不是实现类。</strong></p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>栈是一种后进先出（LIFO）的数据结构：</p>
<ul>
<li>push(E e)：把元素压栈</li>
<li>pop(E e)：把栈顶的元素弹出</li>
</ul>
<p>用 Deque 可以实现 Stack 的功能：</p>
<ul>
<li>push(E e)：addFirst(E e)</li>
<li>pop()：removeFirst()</li>
<li>peek()：peekFirst()</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="给对象添加-Iterator-特性"><a href="#给对象添加-Iterator-特性" class="headerlink" title="给对象添加 Iterator 特性"></a>给对象添加 Iterator 特性</h4><p>如何让自己编写的集合类使用 foreach 循环：</p>
<ul>
<li>实现 Iterable 接口</li>
<li>返回 Iterator 对象</li>
<li>用 Iterator 对象迭代</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">  E[] array;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ReadOnlyList</span><span class="params">(E... array)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array = array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyIterator</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ReadOnlyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    ReadOnlyList.<span class="built_in">this</span>.array.length;</span><br><span class="line">    <span class="comment">// 内部类可以直接访问对应外部类的字段和方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    E[] array;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@SafeVarargs</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ReadOnlyList</span><span class="params">(E... array)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array = array;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyIterator</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ReadOnlyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> index &lt; ReadOnlyList.<span class="built_in">this</span>.array.length();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[index];</span><br><span class="line">      index++; <span class="comment">// 为什么不是 index++;  return array[index];</span></span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="使用-Collections"><a href="#使用-Collections" class="headerlink" title="使用 Collections"></a>使用 Collections</h4><p>Collections 是 JDK 提供的工具类：</p>
<ul>
<li>boolean addAll(Collection&lt;? super T&gt; c, T… elements)</li>
</ul>
<p>创建空集合（不可变）：</p>
<ul>
<li>List<T> emptyList()</li>
<li>Map&lt;K, V&gt; emptyMap()</li>
<li>Set<T> emptySet()</li>
</ul>
<p>创建单元素集合（不可变）：</p>
<ul>
<li>Set<T> singleton(T o)</li>
<li>List<T> singletonList(T o)</li>
<li>Map&lt;K, V&gt; singletonMap(K key, V value)</li>
</ul>
<p>对 List 排序（必须传入可变 List）：</p>
<ul>
<li>void sort(List<T> list)</li>
<li>void sort(List<T> list, Comparator&lt;? super T&gt; c)</li>
</ul>
<p>随机重置 list 的元素顺序：</p>
<ul>
<li>void shuffle(List&lt;?&gt; list)</li>
</ul>
<p>把可变集合变为不可变集合：</p>
<ul>
<li>List<T> unmodifiableList(List&lt;? extends T&gt; list)</li>
<li>Set<T> unmodifiableSet(Set&lt;? extends T&gt; set)</li>
<li>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：通过 list 引用还是可以改的，所以最好写成一行（不要创建 list 引用）</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">List&lt;String&gt; readOnlyList = Collections.unmodifiableList(list);</span><br><span class="line">System.out.println(readOnlyList);</span><br><span class="line">list.add(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">System.out.println(readOnlyList);</span><br></pre></td></tr></table></figure>

<p>把线程不安全的集合变为线程安全的集合：</p>
<ul>
<li>List<T> synchronizedList(List<T> list)</li>
<li>Set<T> synchronizedSet(Set<T> s)</li>
<li>Map&lt;K, V&gt; synchronizedSet(Map&lt;K, V&gt; m)</li>
<li>…（不推荐使用，有更好的方法）</li>
</ul>
<h2 id="IO-编程"><a href="#IO-编程" class="headerlink" title="IO 编程"></a>IO 编程</h2><p>介绍 Java 的 IO 流接口，掌握使用 InputStream &#x2F; OutputStream 和 Reader &#x2F; Writer，理解并应用 Filter 模式组合流接口。</p>
<h3 id="IO-基础"><a href="#IO-基础" class="headerlink" title="IO 基础"></a>IO 基础</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>IO 流是一种<code>流式顺序</code>读写数据的模式：</p>
<ul>
<li>单向流动</li>
<li>以 byte 为最小单位（字节流）</li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/df361.jpg" alt="字节流示意图"></p>
<p>如果字符不是单字节表示的 ASCII：</p>
<ul>
<li>Java 提供了 Reader &#x2F; Writer 表示字符流（其本质上是一个<code>能自动编解码</code>的 InputStream &#x2F; OutputStream）</li>
<li>字符流传输的最小数据单位是<code>char</code></li>
<li>字符流输出的 byte 取决于<code>编码方式</code></li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/x5vhi.jpg" alt="字符流示意图"></p>
<p>究竟使用 Reader 还是 InputStream，要取决具体的场景。如果数据源不是文本，只能使用 InputStream；如果数据源是文本，则使用 Reader 会方便一些。</p>
<p>同步 IO（JDK 提供<code>java.io</code>）：</p>
<ul>
<li>读写 IO 时代码等待数据返回后才继续执行后续代码</li>
<li>代码编写简单，CPU 执行效率低</li>
</ul>
<p>异步 IO（JDK 提供<code>java.nio</code>）：</p>
<ul>
<li>读写 IO 时仅发出请求，然后立刻执行后续代码</li>
<li>代码编写复杂，CPU 执行效率高</li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8wp6j.jpg" alt="抽象类 vs. 实现类"></p>
<p>Java 的 IO 流的接口和实现是分离的：</p>
<ul>
<li>字节流接口：InputStream &#x2F; OutputStream</li>
<li>字符流接口：Reader &#x2F; Writer</li>
</ul>
<h4 id="File-对象"><a href="#File-对象" class="headerlink" title="File 对象"></a>File 对象</h4><p>java.io.File 表示文件系统的一个文件或者目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">abs_f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/usr/local/...&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">rel_f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./Desktop/javac&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> f.getPath(); <span class="comment">// 返回的是传入的目录</span></span><br><span class="line"><span class="type">String</span> <span class="variable">apath</span> <span class="operator">=</span> f.getAbsolutePath();  <span class="comment">// 包含两个点</span></span><br><span class="line"><span class="type">String</span> <span class="variable">cpath</span> <span class="operator">=</span> f.getCanoicalPath();  <span class="comment">// 不包含两个点的实际目录（规范路径）</span></span><br></pre></td></tr></table></figure>

<p>注意的是：在构造一个 File 对象时，即使我们传入的路径不存在，也不会报错，因为构造的时候不会进行磁盘操作，直到调用某些 API 进行操作。还有很多 API，如 isFile、isDirector、canRead、createNewFile、list、listFiles(FileFilter filter)、mkdir 等等。</p>
<h3 id="Input-和-Output"><a href="#Input-和-Output" class="headerlink" title="Input 和 Output"></a>Input 和 Output</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>java.io.InputStream 是所有输入类的超类：</p>
<ul>
<li>abstract int read()<ul>
<li>读取下一个字节，并返回字节（0 ~ 255）</li>
<li>如果已读到末尾，返回 -1</li>
</ul>
</li>
<li>int read(byte[] b)：读取若干字节并填充到 byte[] 数组，返回读取的字节数</li>
<li>int read(byte[] b, int off, int len)：指定 byte[] 数组的偏移量和最大填充数</li>
<li>void close()：关闭输入流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">  &#125;</span><br><span class="line">  input.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用 try / finally</span></span><br><span class="line"><span class="comment">// 最好的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125; <span class="comment">// 在此自动关闭 InputStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>java.io.OutputStream 是所有输出流的超类：</p>
<ul>
<li>abstract write(int b)：写入一个字节</li>
<li>void write(byte[] b)：写入 byte[] 数组的所有字节</li>
<li>void write(byte[] b, int off, int len)：写入 byte[] 数组指定范围的字节</li>
<li>void close()：关闭输出流</li>
<li>void flush()：将缓冲区的内容输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt)) &#123;</span></span><br><span class="line"><span class="string">    byte[] b = &quot;</span>Hello<span class="string">&quot;.getBytes(&quot;</span>UTF-<span class="number">8</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">    // ...</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Filter-模式（Decorator-模式）"><a href="#Filter-模式（Decorator-模式）" class="headerlink" title="Filter 模式（Decorator 模式）"></a>Filter 模式（Decorator 模式）</h4><p>filter 模式，在运行时动态增加功能。JDK 提供的 InputStream 包括：</p>
<ul>
<li>FileInputStream：从文件中读取数据</li>
<li>ServletInputStream：从 HTTP 请求读取数据</li>
<li>Socket.getInputStream()：从 TCP 连接读取数据</li>
</ul>
<p>下面是以 FileInputStream 为例：</p>
<ul>
<li><p>添加缓冲功能：<br>BufferedFileInputStream extends FileInputStream</p>
</li>
<li><p>添加计算签名的功能：<br>DigestFileInputStream extends FileInputStream</p>
</li>
<li><p>添加加密、解密功能：<br>CipherFileInputStream extends FileInputStream</p>
</li>
</ul>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0edst.jpg" alt="类图"></p>
<p>会导致子类爆炸。为了解决这种失控的问题，JDK 把 InputStream 分为两类：</p>
<ul>
<li>直接提供数据的<code>InputStream</code>：<ul>
<li>FileInputStream、ByteArrayInputStream、ServletInputStream</li>
</ul>
</li>
<li>提供额外附加功能的<code>FilterInputStream</code>：<ul>
<li>BufferedInputStream、DigestInputStream、CipherInputStream</li>
</ul>
</li>
</ul>
<p><code>组合功能</code>而<code>非继承</code>的设计模式称为 Filter 模式（或者 Decorator 模式），通过少量的类实现了各种功能组合。</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/yznxn.jpg" alt="数据源子类 + 附加功能子类"></p>
<p>组合 InputStream：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/kkc2f.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论我们包装多少次，还是 InputStream</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.gz&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">实现一个 CountInputStream：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CountInputStream</span><span class="params">(InputStream in)</span> &#123;   </span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="built_in">super</span>.read(b, off, len); <span class="comment">// 注意 super</span></span><br><span class="line">    count += n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountInputStream</span>(<span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(...))) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="操作-Zip"><a href="#操作-Zip" class="headerlink" title="操作 Zip"></a>操作 Zip</h4><p>ZipInputStream 是一种 FilterInputStream，可以直接读取 Zip 内容。</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/532t4.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZipInputStream</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ZipInputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="string">&quot;~/Desktop/a.txt&quot;</span>)) &#123;</span><br><span class="line">  <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getName();</span><br><span class="line">    <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">      <span class="type">int</span> n;</span><br><span class="line">      <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// foo</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZipOutputStream</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ZipOutputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="string">&quot;~/Desktop/a.txt&quot;</span>)) &#123;</span><br><span class="line">  File[] files = ...</span><br><span class="line">  <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    zip.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(file.getName()));</span><br><span class="line">    zip.write(getFileDataAsBytes(file));</span><br><span class="line">    zip.closeEntry();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="classpath-资源"><a href="#classpath-资源" class="headerlink" title="classpath 资源"></a>classpath 资源</h4><p>Java 存放 .class 的目录或 jar 包也可以包含任意其他类型的文件：.properties、.txt、.jpg、.mov 等等。</p>
<p>从 classpath 读取文件可以避免不同环境下文件路径不一致的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    props.load(input);</span><br><span class="line">    <span class="comment">// ... 如果是 txt 文件</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(props));</span><br><span class="line">    System.out.println(reader.readLine());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>序列化是指把一个 Java 对象变成二进制内容（byte[]）：</p>
<ul>
<li>序列化后可以把 byte[] 保存到文件中</li>
<li>序列化后可以把 byte[] 通过网络传输</li>
</ul>
<p>一个 Java 对象要能序列化，必须实现 Serializable 接口：</p>
<ul>
<li>Serializable 接口没有定义任何方法</li>
<li>空接口被称为<code>标记接口</code>（Marker Interface）</li>
</ul>
<p>反序列化是指把一个二进制内容（byte[]）变成一个 Java 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一个 Java 对象写入二进制流：</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(...)) &#123;</span><br><span class="line">  output.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">  output.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从二进制流读取一个 Java 对象：</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(...)) &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> input.readObject();</span><br><span class="line">  <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) input.readObject();</span><br><span class="line">  <span class="comment">// 可能抛出 ClassNotFoundException：没有找到对应的 Class</span></span><br><span class="line">  <span class="comment">// InvalidClassException：Class 不匹配</span></span><br><span class="line">  <span class="comment">// 比如 field 的字段类型不同 int / long</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化的重要特点：</p>
<p>反序列化是由 JVM 直接构造出 Java 对象，<strong>不调用构造方法</strong>。</p>
<p>序列化的类可以添加一个 serialVersionUID 作为版本号（非必需）作对比。</p>
<p>Java 的序列化机制仅适用于 Java。如果需要与其它语言交换数据，必须使用<code>通用的序列化方法</code>，例如 JSON。</p>
<h3 id="Reader-和-Writer"><a href="#Reader-和-Writer" class="headerlink" title="Reader 和 Writer"></a>Reader 和 Writer</h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>Reader 和 InputStream 的区别：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cucvr.jpg" alt="Reader 和 InputStream 的区别"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里使用的是系统默认的编码</span></span><br><span class="line">    reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;radme.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123; reader.close(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK &gt;= 1.7 | try(resource) 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;readme.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = reader.read()) != -<span class="number">1</span>) &#123; </span><br><span class="line">      System.out.println((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// 在此自动关闭 Reader</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;readme.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> buffer.read(buffer) ;</span><br><span class="line">    System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">    <span class="comment">// or 太大了要读很多次</span></span><br><span class="line">    <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reader 实际上是基于 InputStream 构造的：</p>
<ul>
<li>FileReader 内部持有一个 FileInputStream</li>
<li>Reader 可以通过 InputStream 构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">reader.close();</span><br><span class="line"><span class="comment">// 不要调用 input.close()</span></span><br><span class="line"><span class="comment">// reader.close() 帮我们调用了</span></span><br></pre></td></tr></table></figure>

<h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p>Writer 和 OutputStream 的区别：</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wy1uu.jpg" alt="OutputStream 和 Writer 的区别"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 字符编码是系统默认编码</span></span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;readme.txt&quot;</span>);</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123; writer.close(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK &gt;= 1.7 | try(resource)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;readme.txt&quot;</span>)) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;Hello &quot;</span>.toCharArray());</span><br><span class="line">    writer.write(<span class="string">&quot;world.&quot;</span>);</span><br><span class="line">  &#125; <span class="comment">// 在此自动关闭 Writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer 实际上是基于 OutputStream 构造的：</p>
<ul>
<li>FileWriter 内部持有一个 FileOutputStream</li>
<li>Writer 可以通过 OutputStream 构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename);</span><br><span class="line"><span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">writer.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 OutputStream 转换编码</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>))) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125; <span class="comment">// 用了 try(resource) 就不用手动去关闭了</span></span><br></pre></td></tr></table></figure>


        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Junhao Wang
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'junhaow';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
