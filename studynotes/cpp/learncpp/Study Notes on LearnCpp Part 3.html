<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <meta name="description" content="Source: LearnCpp.com by Alex Basic Object-Oriented ProgrammingIn C++, classes and structs are essentially the same. In fact, the following struct and class are effectively identical:">
<meta property="og:type" content="website">
<meta property="og:title" content="Study Notes on LearnCpp (Part 3 - OOP, Overload Operators)">
<meta property="og:url" content="https://junhaow.com/studynotes/cpp/learncpp/Study%20Notes%20on%20LearnCpp%20Part%203.html">
<meta property="og:site_name" content="forkercat.blog">
<meta property="og:description" content="Source: LearnCpp.com by Alex Basic Object-Oriented ProgrammingIn C++, classes and structs are essentially the same. In fact, the following struct and class are effectively identical:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-02-18T06:03:11.000Z">
<meta property="article:modified_time" content="2024-02-13T00:53:54.184Z">
<meta property="article:author" content="Junhao Wang">
<meta property="article:tag" content="blog, junhaow, game">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/resources/favicon/me/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/resources/favicon/me/android-chrome-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/resources/favicon/me/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Study Notes on LearnCpp (Part 3 - OOP, Overload Operators)</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-146643833-1"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-146643833-1');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/resources/images/me_avatar.jpg" />
    
  
    <div id="title">
      <h1 class="p-name">forkercat.blog</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/archives/">Posts</a></li><!--
   --><!--
     --><li><a href="/studynotes/">Notes</a></li><!--
   --><!--
     --><li><a href="/lc/">Leetcode</a></li><!--
   --><!--
     --><li><a href="/games/">Games</a></li><!--
   --><!--
     --><li><a href="/links/">Links</a></li><!--
   --><!--
     --><li><a href="/about/">Me</a></li><!--
   -->
    </ul>
  </div>
</header>

        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <br>

<p>Source: <a target="_blank" rel="noopener" href="https://www.learncpp.com/">LearnCpp.com</a> by Alex</p>
<h2 id="Basic-Object-Oriented-Programming"><a href="#Basic-Object-Oriented-Programming" class="headerlink" title="Basic Object-Oriented Programming"></a>Basic Object-Oriented Programming</h2><p>In C++, classes and structs are essentially the same. In fact, the following struct and class are effectively identical:</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DateStruct</span> &#123;</span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_year;</span><br><span class="line">  <span class="type">int</span> m_month;</span><br><span class="line">  <span class="type">int</span> m_day;</span><br><span class="line">&#125;; <span class="comment">// don&#x27;t forget the semicolon!</span></span><br></pre></td></tr></table></figure>

<p><strong>Just like a struct declaration, a class declaration does not declare any memory. It only defines what the class looks like.</strong></p>
<p>Using the <code>m_</code> prefix for member variables helps distinguish member variables from function parameters or local variables inside member functions. This is useful for several reasons:</p>
<ul>
<li>First, when we see an assignment to a variable with the “m_” prefix, we know that we are changing the state of the class. </li>
<li>Second, unlike function parameters or local variables, which are declared within the function, member variables are declared in the class definition. Consequently, if we want to know how a variable with the “m_” prefix is declared, we know that we should look in the class definition instead of within the function.</li>
</ul>
<p><strong>A note about structs in C++</strong></p>
<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>In C, structs can only hold data, and do not have associated member functions. In C++, after designing classes (using the class keyword), Bjarne Stroustrup spent some amount of time considering whether structs (which were inherited from C) should be granted the ability to have member functions. Upon consideration, he determined that they should, in part to have a unified ruleset for both. So although we wrote the above programs using the class keyword, we could have used the struct keyword instead.</p>
<p>Many developers (including myself) feel this was the <code>incorrect decision</code> to be made, as it can lead to dangerous assumptions: For example, it’s fair to assume a class will clean up after itself (e.g. a class that allocates memory will deallocate it before being destroyed), but it’s not safe to assume a struct will. Consequently, <strong>we recommend using the struct keyword for data-only structures</strong>, and the class keyword for defining objects that require both data and functions to be bundled together.</p>
<p><strong>Rule:</strong> Use the struct keyword for data-only structures. Use the class keyword for objects that have both data and functions.</p>
<h3 id="Public-vs-private-access-specifiers"><a href="#Public-vs-private-access-specifiers" class="headerlink" title="Public vs private access specifiers"></a>Public vs private access specifiers</h3><p>Members are public by default.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="type">int</span> month; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">  <span class="type">int</span> day; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">  <span class="type">int</span> year; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123; <span class="comment">// members are private by default</span></span><br><span class="line">  <span class="type">int</span> m_month; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">  <span class="type">int</span> m_day; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">  <span class="type">int</span> m_year; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Classes can (and almost always do) use multiple access specifiers to set the access levels of each of its members. <code>There is no limit</code> to the number of access specifiers you can use in a class.</p>
<p>In general, member variables are usually made <code>private</code>, and member functions are usually made <code>public</code>.</p>
<p>Some programmers prefer to list private members first, because the public members typically use the private ones, so it makes sense to define the private ones first. However, a good counterargument is that users of the class don’t care about the private members, so the public ones should come first. <strong>Either way is fine.</strong></p>
<h3 id="Access-functions-and-encapsulation"><a href="#Access-functions-and-encapsulation" class="headerlink" title="Access functions and encapsulation"></a>Access functions and encapsulation</h3><p><strong>Encapsulation</strong></p>
<p>In object-oriented programming, <code>Encapsulation</code> (also called <code>information hiding</code>) is the process of keeping the details about how an object is implemented hidden away from users of the object. Instead, users of the object access the object through a public interface. In this way, users are able to use the object without having to understand how it is implemented.</p>
<p>In C++, we implement encapsulation via access specifiers. Typically, all member variables of the class are made private (hiding the implementation details), and most member functions are made public (exposing an interface for the user). Although requiring users of the class to use the public interface may seem more burdensome than providing public access to the member variables directly, doing so actually provides a large number of useful benefits that help encourage class <code>re-usability</code> and <code>maintainability</code>.</p>
<p><strong>Note:</strong> The word encapsulation is also sometimes used to refer to the packaging of data and functions that work on that data together. We prefer to just call that object-oriented programming.</p>
<ul>
<li><strong>Rule:</strong> Only provide access functions when it makes sense for the user to be able to get or set a value directly.</li>
<li><strong>Rule:</strong> Getters should usually return by <code>value</code> or <code>const reference</code>, <code>not non-const reference</code>.</li>
</ul>
<h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><p>Unlike normal member functions, constructors have specific rules for how they must be named:</p>
<ul>
<li>Constructors must have the <code>same name</code> as the class (with the same capitalization)</li>
<li>Constructors have <code>no return type</code> (not even void)</li>
</ul>
<p><strong>Remember:</strong> Fundamental variables aren’t initialized by default. they should be initialized in constructors.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fraction</span>(<span class="type">int</span>, numerator, <span class="type">int</span> denominator=<span class="number">1</span>) &#123;</span><br><span class="line">  m_numerator = numerator;</span><br><span class="line">  m_denominator = denominator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Fraction <span class="title">fiveThirds1</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Fraction fiveThirds2 &#123;<span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">Fraction <span class="title">fiveThirds3</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>Copy initialization using equals with classes</strong></p>
<p>Much like with fundamental variables, it’s also possible to initialize classes using copy initialization:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span>; <span class="comment">// Copy initialize an integer</span></span><br><span class="line">Fraction six = <span class="built_in">Fraction</span>(<span class="number">6</span>); <span class="comment">// Copy initialize a Fraction, will call Fraction(6, 1)</span></span><br><span class="line">Fraction seven = <span class="number">7</span>; <span class="comment">// Copy initialize a Fraction.</span></span><br><span class="line"><span class="comment">// The compiler will try to find a way to convert 7 to a Fraction, which will invoke the Fraction(7, 1) constructor.</span></span><br></pre></td></tr></table></figure>

<p>However, we recommend you avoid this form of initialization with classes, as it may be less efficient. <strong>Although <code>direct initialization</code>, <code>uniform initialization</code>, and <code>copy initialization</code> all work identically with fundamental types, copy-initialization does not work the same with classes (though the end-result is often the same). We’ll explore the differences in more detail in a future chapter.</strong></p>
<p><strong>Rule:</strong> Do not use copy initialization for your classes.</p>
<p><strong>Reducing your constructors</strong></p>
<p>In the above two-constructor declaration of the Fraction class, the default constructor is actually somewhat redundant. We could simplify this class as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Default</span></span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Although this constructor is still a default constructor, it has now been defined in a way that it can accept one or two user-provided values as well.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fraction zero;   <span class="comment">// will call Fraction(0, 1)</span></span><br><span class="line"><span class="function">Fraction <span class="title">six</span><span class="params">(<span class="number">6</span>)</span></span>; <span class="comment">// will call Fraction(6, 1)</span></span><br><span class="line"><span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;  <span class="comment">// will call Fraction(5, 3)</span></span><br></pre></td></tr></table></figure>

<p>This may produce unexpected results for classes that have multiple default parameters of different types. Consider:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Something</span>(<span class="type">int</span> n = <span class="number">0</span>, <span class="type">double</span> d = <span class="number">1.2</span>) &#123; <span class="comment">// allows us to construct a Something(int, double), Something(int), or Something()</span></span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Something s1 &#123; <span class="number">1</span> &#125;;</span><br><span class="line">Something s2;</span><br><span class="line">Something s3 &#123; <span class="number">2.4</span> &#125;;  <span class="comment">// will not compile, as there&#x27;s no constructor to handle Something(double)</span></span><br></pre></td></tr></table></figure>

<p>If we want to be able to construct a <code>Something</code> with only a double, we’ll need to add a second (non-default) constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default constructor</span></span><br><span class="line"><span class="built_in">Something</span>(<span class="type">int</span> n = <span class="number">0</span>, <span class="type">double</span> d = <span class="number">1.2</span>) &#123; </span><br><span class="line">  <span class="comment">// allows us to construct:</span></span><br><span class="line">  <span class="comment">// Something(int, double)</span></span><br><span class="line">  <span class="comment">// Something(int)</span></span><br><span class="line">  <span class="comment">// Something()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// non-default constructor</span></span><br><span class="line"><span class="built_in">Something</span>(<span class="type">double</span> d) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>An implicitly generated default constructor</strong></p>
<p>If your class has no other constructors, C++ will automatically generate a <code>public default constructor</code> for you. This is sometimes called an implicit constructor (or implicitly generated constructor).</p>
<p>If your class has any other constructors, the implicitly generated constructor <strong>will not be provided</strong>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Date data; <span class="comment">// error: Can&#x27;t instantiate object because default constructor doesn&#x27;t exist and the compiler won&#x27;t generate one.</span></span><br></pre></td></tr></table></figure>

<p>Generally speaking, it’s a good idea to always provide at least one constructor in your class. This explicitly allows you to control how objects of your class are allowed to be created, and will prevent your class from potentially breaking later when you add other constructors.</p>
<p><strong>Rule:</strong> Provide at least one constructor for your class, even if it’s an empty default constructor.</p>
<p>Many new programmers are confused about whether constructors create the objects or not. They do not (the code the compiler creates does that).</p>
<p>Constructors actually serve two purposes. The primary purpose is to <code>initialize objects</code> that have just been created. The secondary purpose is to determine <code>whether creation of an object is allowed</code>. That is, an object of a class can only be created if a matching constructor can be found. This means that a class without any public constructors can’t be created!</p>
<p>Constructors are only intended to be used for initialization when the object is created. <strong>You should not try to call a constructor to re-initialize an existing object.</strong> While it may compile, the results will not be what you intended (instead, the compiler will create a temporary object and then discard it).</p>
<p>Some types of data (e.g. <code>const</code> and <code>reference</code> variables) must be initialized on the line they are declared. Consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Something</span>() &#123;</span><br><span class="line">    m_value = <span class="number">1</span>; <span class="comment">// error: const vars cannot be assigned to</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Member initializer lists</strong></p>
<p>To solve this problem, C++ provides a method for initializing class member variables (rather than assigning values to them after they are created) via a <code>member initializer list</code> (often called a “member initialization list”). <strong>Do not confuse these with the similarly named initializer list that we can use to assign values to arrays.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_value1;</span><br><span class="line">  <span class="type">double</span> m_value2;</span><br><span class="line">  <span class="type">char</span> m_value3;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Something</span>() : <span class="built_in">m_value1</span>(<span class="number">1</span>), <span class="built_in">m_value2</span>(<span class="number">2.2</span>), <span class="built_in">m_value3</span>(<span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// directly initialize our member variables</span></span><br><span class="line">  <span class="comment">// No need for assignment here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Something something;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or more useful</span></span><br><span class="line">  <span class="built_in">Something</span>(<span class="type">int</span> value1, <span class="type">double</span> value2, <span class="type">char</span> value3=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    : <span class="built_in">m_value1</span>(value1), <span class="built_in">m_value2</span>(value2), <span class="built_in">m_value3</span>(value3) &#123;</span><br><span class="line">    <span class="comment">// directly initialize our member variables</span></span><br><span class="line">    <span class="comment">// No need for assignment here</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">Something <span class="title">something</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>)</span></span>;</span><br><span class="line"><span class="comment">// value = 1, value2 = 2.2, value3 gets default value &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Const problem solved:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Something</span>(): <span class="built_in">m_value</span>(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// directly initialize our const member variable</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Rule:</strong> Use member initializer lists to initialize your class member variables instead of assignment.</p>
<p>Or even in C++11, we can use <code>m_value &#123;5&#125;</code>.</p>
<p>We strongly encourage you to begin using this new syntax (even if you aren’t using const or reference member variables) as initialization lists are required when doing composition and inheritance (subjects we will be covering shortly).</p>
<p><strong>Rule:</strong> Favor uniform initialization over direct initialization if your compiler is C++11 compatible</p>
<p>Prior to C++11, you can only zero an array member via a member initialization list:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> m_array[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Something</span>(): m_array &#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// zero the member array</span></span><br><span class="line">    <span class="comment">// If we want the array to have values, we&#x27;ll have to use assignment here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>However, in C++11, you can fully initialize a member array using uniform initialization:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> m_array[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Something</span>() : m_array &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125; &#123;</span><br><span class="line">  <span class="comment">// use uniform initialization to initialize our member array</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A member initialization list can also be used to initialize members that are classes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> y) : <span class="built_in">m_a</span>(y<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// call A(int) constructor to initialize member m_a</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Formatting your initializer lists</strong></p>
<p>C++ gives you a lot of flexibility in how to format your initializer lists, and it’s really up to you how you’d like to proceed. But here are some recommendations:</p>
<p>If the initializer list fits on the same line as the function name, then it’s fine to put everything on one line:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Something</span>() : <span class="built_in">m_value1</span>(<span class="number">1</span>), <span class="built_in">m_value2</span>(<span class="number">2.2</span>), <span class="built_in">m_value3</span>(<span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// everything on one line</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the initializer list doesn’t fit on the same line as the function name, then it should go indented on the next line.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Something</span>(<span class="type">int</span> value1, <span class="type">double</span> value2, <span class="type">char</span> value3=<span class="string">&#x27;c&#x27;</span>) &#123; <span class="comment">// this line already has a lot of stuff on it</span></span><br><span class="line">    : <span class="built_in">m_value1</span>(value1), <span class="built_in">m_value2</span>(value2), <span class="built_in">m_value3</span>(value3)</span><br><span class="line">  <span class="comment">// so we can put everything indented on next line</span></span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  <span class="comment">// :m_value1(value1),</span></span><br><span class="line">  <span class="comment">// m_value2(value2),</span></span><br><span class="line">  <span class="comment">// m_value3(value3),</span></span><br><span class="line">  <span class="comment">// m_value4(value4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Initializer list order</strong></p>
<p>Perhaps surprisingly, variables in the initializer list are not initialized in the order that they are specified in the initializer list. <strong>Instead, they are initialized in the order in which they are declared in the class</strong>.</p>
<p>For best results, the following recommendations should be observed:</p>
<ul>
<li><strong>Don’t initialize member variables in such a way that they are dependent upon other member variables being initialized first.</strong> In other words, ensure your member variables will properly initialize even if the initialization ordering is different).</li>
<li><strong>Initialize variables in the initializer list in the same order in which they are declared in your class</strong>. This isn’t strictly required so long as the prior recommendation has been followed, but your compiler may give you a <code>warning</code> if you don’t do so and you have all warnings turned on.</li>
</ul>
<p><strong>Non-static member initialization</strong></p>
<p>Starting with C++11, it’s possible to give normal class member variables (<strong>those that don’t use the <code>static</code> keyword</strong>) a default initialization value directly:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> m_length = <span class="number">1.0</span>; <span class="comment">// m_length has a default value of 1.0</span></span><br><span class="line">  <span class="type">double</span> m_width = <span class="number">1.0</span>; <span class="comment">// m_width has a default value of 1.0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rectangle</span>() &#123;</span><br><span class="line">    <span class="comment">// This constructor will use the default values above since they aren&#x27;t overridden here</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Rectangle</span>(<span class="type">double</span> length, <span class="type">double</span> width)</span><br><span class="line">      : <span class="built_in">m_length</span>(length), <span class="built_in">m_width</span>(width) &#123;</span><br><span class="line">    <span class="comment">// m_length and m_width are initialized by the constructor (the default values aren&#x27;t used)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Non-static member initialization (also called in-class member initializers) provides default values for your member variables that your constructors will use if the constructors do not provide initialization values for the members themselves (via the member initialization list).</p>
<p><strong>Overlapping and delegating constructors</strong></p>
<p>Overlapping functionality problem:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    <span class="comment">// code to do A</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="comment">// code to do A</span></span><br><span class="line">    <span class="comment">// code to do B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>The obvious solution doesn’t work prior to C++11</strong></p>
<p>The obvious solution would be to have the <code>Foo(int)</code> constructor call the <code>Foo()</code> constructor to do the A portion.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    <span class="comment">// code to do A</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(); <span class="comment">// use the above constructor to do A (doesn&#x27;t work)</span></span><br><span class="line">    <span class="comment">// code to do B</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> value) : <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    <span class="comment">// code to do B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, with a pre-C++11 compiler, if you try to have one constructor call another constructor, it will often compile, but it will not work as you expect, and you will likely spend a long time trying to figure out why, even with a debugger.</p>
<p><strong>Note:</strong> Prior to C++11, calling a constructor explicitly from another constructor creates a temporary object, initializes the temporary object using the constructor, and then discards it, leaving your original object unchanged.</p>
<p><strong>Using a separate function</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Foo</span>() &#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="comment">// do something with value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// code to init Foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>One small caveat: be careful when using Init() functions and dynamically allocated memory. Because Init() functions can be called by anyone at any time, dynamically allocated memory may or may not have already been allocated when Init() is called. Be careful to handle this situation appropriately – it can be slightly confusing, since a non-null pointer could be either dynamically allocated memory or an uninitialized pointer!</p>
<p><strong>Delegating constructors in C++11</strong></p>
<p>Starting with C++11, constructors are now allowed to call other constructors. This process is called <code>delegating constructors</code> (or <code>constructor chaining</code>).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    <span class="comment">// code to do A</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> value) : <span class="built_in">Foo</span>() &#123;</span><br><span class="line">    <span class="comment">// use Foo() default constructor to do A</span></span><br><span class="line">    <span class="comment">// code to do B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This works exactly as you’d expect. <strong>Make sure you’re calling the constructor from the member initializer list, not in the body of the constructor.</strong></p>
<p>Here’s another example of using delegating constructor to reduce redundant code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_id;</span><br><span class="line">  std::string m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// delegated constructor</span></span><br><span class="line">  <span class="built_in">Employee</span>(<span class="type">int</span> id=<span class="number">0</span>, <span class="type">const</span> std::string &amp;name=<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">m_id</span>(id), <span class="built_in">m_name</span>(name) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Employee &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; created.\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Use a delegating constructor to minimize redundant code</span></span><br><span class="line">  <span class="built_in">Employee</span>(<span class="type">const</span> std::string &amp;name)</span><br><span class="line">      : <span class="built_in">Employee</span>(<span class="number">0</span>, name) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Destructors</strong></p>
<p>If your class object is holding any resources (e.g. dynamic memory, or a file or database handle), or if you need to do any kind of maintenance before the object is destroyed, the destructor is the perfect place to do so, as it is typically the last thing to happen before the object is destroyed.</p>
<p>Like constructors, destructors have specific naming rules:</p>
<ol>
<li>The destructor must have the same name as the class, preceded by a tilde (~).</li>
<li>The destructor cannot take arguments.</li>
<li>The destructor has no return type.</li>
</ol>
<p>Generally you should not call a destructor explicitly (as it will be called automatically when the object is destroyed), since there are rarely cases where you’d want to clean up an object more than once. <strong>However, destructors may safely call other member functions since the object isn’t destroyed until after the destructor executes.</strong></p>
<p><code>RAII (Resource Acquisition Is Initialization)</code> is a programming technique whereby resource use is tied to the lifetime of objects <strong>with automatic duration</strong> (e.g. non-dynamically allocated objects). In C++, RAII is implemented via classes with constructors and destructors. A resource (such as memory, a file or database handle, etc…) is typically acquired in the object’s constructor (though it can be acquired after the object is created if that makes sense). <strong>That resource can then be used while the object is alive.</strong> The resource is released in the destructor, when the object is destroyed. The primary advantage of RAII is that it helps prevent resource leaks (e.g. memory not being deallocated) as all resource-holding objects are cleaned up automatically.</p>
<p><strong>Under the RAII paradigm, objects holding resources should not be dynamically allocated. This is because destructors are only called when an object is destroyed.</strong> For objects allocated on the stack, this happens automatically when the object goes out of scope, so there’s no need to worry about a resource eventually getting cleaned up. However, for dynamically allocated objects, the user is responsible for deletion – if the user forgets to do that, then the destructor will not be called, and the memory for both the class object and the resource being managed will be leaked!</p>
<p>The IntArray class at the top of this lesson is an example of a class that implements RAII – allocation in the constructor, deallocation in the destructor. std::string and std::vector are examples of classes in the standard library that follow RAII – dynamic memory is acquired on initialization, and cleaned up automatically on destruction.</p>
<p><strong>Rule:</strong> If your class dynamically allocates memory, use the RAII paradigm, and <strong>don’t allocate objects of your class dynamically</strong>.</p>
<p><strong>A warning about the exit() function</strong></p>
<p>Note that if you use the <code>exit()</code> function, <strong>your program will terminate and no destructors will be called</strong>. Be wary if you’re relying on your destructors to do necessary cleanup work (e.g. write something to a log file or database before exiting).</p>
<h3 id="The-hidden-“this”-pointer"><a href="#The-hidden-“this”-pointer" class="headerlink" title="The hidden “this” pointer"></a>The hidden “this” pointer</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">simple.<span class="built_in">setID</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// compiler convert it to: setID(&amp;simple, 2);</span></span><br><span class="line"><span class="comment">// void setID(Simple* const this, int id) &#123;</span></span><br><span class="line"><span class="comment">//   this-&gt;m_id = id;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>Putting it all together:</p>
<ol>
<li>When we call <code>simple.setID(2)</code>, the compiler actually calls <code>setID(&amp;simple, 2)</code>.</li>
<li>Inside <code>setID()</code>, the “this” pointer holds the address of object simple.</li>
<li>Any member variables inside <code>setID()</code> are prefixed with “this-&gt;”. So when we say <code>m_id = id</code>, the compiler is actually executing <code>this-&gt;m_id = id</code>, which in this case updates <code>simple.m_id</code> to <code>id</code>.</li>
</ol>
<p>Although using <code>this-&gt;xxx</code> is acceptable coding practice, we find using the “m_” prefix on all member variable names provides a better solution by preventing duplicate names altogether!</p>
<p><strong>Some developers prefer to explicitly add this-&gt; to all class members. We recommend that you avoid doing so, as it tends to make your code less readable for little benefit.</strong> Using the <code>m_</code> prefix is a more readable way to differentiate member variables from non-member (local) variables.</p>
<p><strong>Chaining member functions</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; userName;</span><br></pre></td></tr></table></figure>

<p>In this case, std::cout is an object, and operator <code>&lt;&lt;</code> is a member function that operates on that object. The compiler evaluates the above snippet like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span>) &lt;&lt; userName;</span><br><span class="line"><span class="comment">// -&gt;  (std::cout) &lt;&lt; userName;</span></span><br><span class="line"><span class="comment">// operator &lt;&lt; returns *this, which in this context is just std::cout</span></span><br></pre></td></tr></table></figure>

<p>Here is a version of Calc with “chainable” functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calc</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Calc</span>() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">   <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">   <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Calc calc;</span><br><span class="line">calc.<span class="built_in">add</span>(<span class="number">5</span>).<span class="built_in">sub</span>(<span class="number">3</span>).<span class="built_in">mult</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>






<h3 id="Class-code-and-header-files"><a href="#Class-code-and-header-files" class="headerlink" title="Class code and header files"></a>Class code and header files</h3><p><strong>Defining member functions outside the class definition</strong></p>
<p>C++ provides a way to separate the “declaration” portion of the class from the “implementation” portion. This is done by defining the class member functions outside of the class definition. To do so, simply define the member functions of the class as if they were normal functions, but prefix the class name to the function using the scope resolution operator (::) (same as for a namespace).</p>
<p>Here is our Date class with the Date constructor and setDate() function defined outside of the class definition. Note that the prototypes for these functions still exist inside the class definition, but the actual implementation has been moved outside:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calc</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Calc</span>(<span class="type">int</span> value=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">  <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">  <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Calc::<span class="built_in">Calc</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Calc&amp; <span class="title">Calc::add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  m_value += value;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><strong>Putting class definitions in a header file</strong></p>
<p>Date.h:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_year;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Date.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day) &#123;</span><br><span class="line">  <span class="built_in">SetDate</span>(year, month, day);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::SetDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span>&#123;</span><br><span class="line">  m_month = month;</span><br><span class="line">  m_day = day;</span><br><span class="line">  m_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Doesn’t defining member functions in the header violate the one-definition rule?</strong></p>
<p>It depends. Member functions defined inside the <code>class definition</code> are considered <code>implicitly inline</code>. Inline functions are exempt from the one definition per program part of the one-definition rule. This means <code>there is no problem defining trivial member functions (such as access functions) inside the class definition itself</code>.</p>
<p>Member functions defined outside the class definition are treated like <code>normal functions</code>, and are subject to the one definition per program part of the one-definition rule. Therefore, those functions should be defined in a code file, not inside the header. The one exception for this is for template functions, which we’ll cover in a future chapter.</p>
<p><strong>So what should I define in the .h file vs the .cpp file, and what inside the class definition vs outside?</strong></p>
<p>You might be tempted to put all of your member function definitions into the header file, inside the class. While this will compile, there are a couple of downsides to doing so. </p>
<ul>
<li>First, as mentioned above, this <code>clutters up</code> your class definition. </li>
<li>Second, functions defined inside the class are <code>implicitly inline</code>. For larger functions that are called from many places, this can bloat your code. </li>
<li>Third, <strong>if you change anything about the code in the header, then you’ll need to <code>recompile</code> every file that includes that header.</strong> This can have a ripple effect, where one minor change causes the entire program to need to recompile (which can be slow). If you change the code in a .cpp file, only that .cpp file needs to be recompiled!</li>
</ul>
<p>Therefore, we recommend the following:</p>
<ul>
<li>For classes that are used in only one file and aren’t generally reusable, define them directly in the single <code>.cpp</code> file they’re used in.</li>
<li>For classes used in multiple files, or <strong>intended for general reuse</strong>, define them in a <code>.h</code> file that has the same name as the class.</li>
<li>Trivial member functions (trivial <code>constructors</code> or <code>destructors</code>, access functions, etc…) can be defined inside the class.</li>
<li>Non-trivial member functions should be defined in a <code>.cpp</code> file that has the same name as the class.</li>
</ul>
<p><strong>Default parameters</strong></p>
<p><strong>Default parameters for member functions should be declared in the class definition (in the header file)</strong>, where they can be seen by whomever #includes the header.</p>
<p><strong>Libraries</strong></p>
<p>Separating the class definition and class implementation is very common for libraries that you can use to extend your program. Throughout your programs, you’ve #included headers that belong to the standard library, such as iostream, string, vector, array, and other. Notice that you haven’t needed to add iostream.cpp, string.cpp, vector.cpp, or array.cpp into your projects. Your program needs the declarations from the header files in order for the compiler to validate you’re writing programs that are syntactically correct. <strong>However, the implementations for the classes that belong to the C++ standard library is contained in a precompiled file that is linked in at the link stage.</strong> <code>You never see the code.</code></p>
<p>Outside of some open source software (where both .h and .cpp files are provided), most 3rd party libraries provide only header files, along with a precompiled library file. There are several reasons for this: </p>
<ol>
<li>It’s faster to link a precompiled library than to recompile it every time you need it.</li>
<li>A single copy of a precompiled library can be shared by many applications, whereas compiled code gets compiled into executable copies that uses it (inflating file sizes).</li>
<li>Intellectual property reasons (you don’t want people stealing your code).</li>
</ol>
<p>Having your own files separated into declaration (header) and implementation (code file) is not only good form, it also makes creating your own custom libraries easier. Creating your own libraries is beyond the scope of these tutorials, but separating your declaration and implementation is a prerequisite to doing so.</p>
<h3 id="Const-class-objects-and-member-functions"><a href="#Const-class-objects-and-member-functions" class="headerlink" title="Const class objects and member functions"></a>Const class objects and member functions</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Date date1; <span class="comment">// initialize using default constructor</span></span><br><span class="line"><span class="function"><span class="type">const</span> Date <span class="title">date2</span><span class="params">(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">16</span>)</span></span>;    <span class="comment">// initialize using parameterized constructor</span></span><br><span class="line"><span class="type">const</span> Date date3 &#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">16</span> &#125;; <span class="comment">// initialize using parameterized constructor (C++11)</span></span><br></pre></td></tr></table></figure>

<p>Once a const class object has been initialized via constructor, any attempt to modify the member variables of the object is disallowed, as it would violate the const-ness of the object. <strong>This includes both changing member variables directly (if they are public), or calling member functions that set the value of member variables.</strong> Consider the following class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Something something;</span><br><span class="line">something.m_value = <span class="number">5</span>; <span class="comment">// Not allowed</span></span><br><span class="line">something.<span class="built_in">setValue</span>(<span class="number">5</span>); <span class="comment">// Not allowed</span></span><br></pre></td></tr></table></figure>

<p>Now, consider the following line of code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; something.<span class="built_in">getValue</span>();</span><br></pre></td></tr></table></figure>

<p>Perhaps surprisingly, this will also cause a compile error, even though getValue() doesn’t do anything to change a member variable! It turns out that <strong>const class objects can only explicitly call const member functions</strong>, and getValue() has not been marked as a const member function.</p>
<p>A <code>const member function</code> is a member function that guarantees it will not modify the object or call any non-const member functions (as they may modify the object).</p>
<p>To make getValue() a const member function, we simply append the const keyword to the function prototype, after the parameter list, but before the function body:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">  <span class="comment">// note addition of const keyword after parameter list, but before function body</span></span><br></pre></td></tr></table></figure>

<p>Futhermore, any const member function that attempts to change a member variable or call a non-const member function will cause a compiler error to occur.</p>
<p><strong>Note that constructors cannot be marked as const.</strong> This is because constructors need to be able to initialize their member variables, and a const constructor would not be able to do so. Consequently, the language disallows const constructors.</p>
<p><strong>Const references</strong></p>
<p>Although instantiating const class objects is one way to create const objects, <code>a more common way is by passing an object to a function by const reference.</code></p>
<p>We covered the merits of passing class arguments by const reference instead of by value. To recap, passing a class argument by value causes a copy of the class to be made (which is slow) – most of the time, we don’t need a copy, a reference to the original argument works just fine, and is more performant because it avoids the needless copy. We typically make the reference const in order to ensure the function does not inadvertently change the argument, and to allow the function to work with R-values (e.g. literals), which can be passed as const references, but not non-const references.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDate</span><span class="params">(<span class="type">const</span> Date &amp;date)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; date.<span class="built_in">getYear</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; date.<span class="built_in">getMonth</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; date.<span class="built_in">getDay</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const is necessary; otherwise it will cause a compile error</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getYear</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMonth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDay</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Overloading const and non-const function</strong></p>
<p>Finally, although it is not done very often, it is possible to overload a function in such a way to have a const and non-const version of the same function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Something</span>(<span class="type">const</span> std::string &amp;value=<span class="string">&quot;&quot;</span>) &#123; m_value = value; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">  <span class="comment">// getValue() for const objects</span></span><br><span class="line">  <span class="function">std::string&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">  <span class="comment">// getValue() for non-const objects</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>The non-const version of getValue() will only work with non-const objects, but is more flexible in that we can use it to both read and write m_value (which we do by assigning the string “Hi”).</p>
</li>
<li><p>The const version of getValue() will work with either const or non-const objects, but returns a const reference, to ensure we can’t modify the const object’s data.</p>
</li>
</ul>
<p>Because passing objects by const reference is common, your classes should be const-friendly. <strong>That means making any member function that does not modify the state of the class object const!</strong></p>
<h3 id="Static-member-variables"><a href="#Static-member-variables" class="headerlink" title="Static member variables"></a>Static member variables</h3><p>C++ introduces two more uses for the static keyword when applied to classes: static member variables, and static member functions. Fortunately, these uses are fairly straightforward. We’ll talk about static member variables in this lesson, and static member functions in the next.</p>
<p>Member variables of a class can be made static by using the static keyword. Unlike normal member variables, static member variables are shared by all objects of the class. Consider the following program, similar to the above:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> s_value;</span><br><span class="line">  <span class="comment">// Note that the static member definition is not subject to access controls: you can define and initialize the value even if it&#x27;s declared as private (or protected) in the class</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Something::s_value = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Something first;</span><br><span class="line">  Something second;</span><br><span class="line">  first.s_value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; first.s_value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; second.s_value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// but we&#x27;d better use Something::s_value!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the class is defined in a .h file, the static member definition is usually placed in the associated code file for the class (e.g. Something.cpp). If the class is defined in a .cpp file, the static member definition is usually placed directly underneath the class. Do not put the static member definition in a header file (much like a global variable, if that header file gets included more than once, you’ll end up with multiple definitions, which will cause a compile error).</p>
<p><strong>Static member functions</strong></p>
<p>What if static member variables are declared private:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> s_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Something::s_value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// initializer, this is okay even though s_value is private since it&#x27;s a definition</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Something::s_value can&#x27;t be accessed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Normally we access private members through public member functions. While we could create a normal public member function to access s_value, we’d then need to instantiate an object of the class type to use the function! We can do better. It turns out that we can also make functions static.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_value; &#125;</span><br></pre></td></tr></table></figure>

<p>*<em>Static member functions have no <em>this pointer</em></em></p>
<p><strong>C++ does not support static constructors</strong></p>
<p>If initializing your static member variable <code>requires executing code</code> (e.g. a loop), there are many different, somewhat obtuse ways of doing this. The following code presents one of the better methods. However, it is a little tricky, and you’ll probably never need it, so feel free to skip the remainder of this section if you desire.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> std::vector&lt;<span class="type">char</span>&gt; s_mychars;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">_init</span> &#123; </span><br><span class="line">    <span class="comment">// we&#x27;re defining a nested class named _init</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    _init() &#123;</span><br><span class="line">      s_mychars.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      s_mychars.<span class="built_in">push_back</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> _init s_initializer;</span><br><span class="line">  <span class="comment">// we&#x27;ll use this static object to ensure the _init constructor is called</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; MyClass::s_mychars;</span><br><span class="line"><span class="comment">// define our static member variable</span></span><br><span class="line">MyClass::_init MyClass::s_initializer;</span><br><span class="line"><span class="comment">// define our static initializer, which will call the _init constructor, which will initialize s_mychars</span></span><br></pre></td></tr></table></figure>




<h3 id="Friend-functions-and-classes"><a href="#Friend-functions-and-classes" class="headerlink" title="Friend functions and classes"></a>Friend functions and classes</h3><p>A <code>friend</code> function is a function that can access the private members of a class as though it were a member of that class. In all other regards, the friend function is just like a <code>normal function</code>. A friend function may be either a normal function, or a member function of another class. To declare a friend function, simply use the friend keyword in front of the prototype of the function you wish to be a friend of the class. <strong>It does not matter whether you declare the friend function in the private or public section of the class.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Accumulator</span>() &#123; m_value = <span class="number">0</span>; &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value += value; &#125; </span><br><span class="line">  <span class="comment">// Make the reset() function a friend of this class</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset() is now a friend of the Accumulator class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// And can access the private data of Accumulator objects</span></span><br><span class="line">  accumulator.m_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Accumulator acc;</span><br><span class="line">  acc.<span class="built_in">add</span>(<span class="number">5</span>); <span class="comment">// add 5 to the accumulator</span></span><br><span class="line">  <span class="built_in">reset</span>(acc); <span class="comment">// reset the accumulator to 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we have to pass an Accumulator object to reset(). This is because reset() is not a member function. It does not have a *this pointer, nor does it have an Accumulator object to work with, unless given one.</p>
<p><strong>Note:</strong> A function can be a friend of more than one class at the same time.</p>
<p>It is also possible to make an entire class a friend of another class. <strong>This gives all of the members of the friend class access to the private members of the other class.</strong> Here is an example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_nValue;</span><br><span class="line">  <span class="type">double</span> m_dValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Storage</span>(<span class="type">int</span> nValue, <span class="type">double</span> dValue) &#123;</span><br><span class="line">    m_nValue = nValue;</span><br><span class="line">    m_dValue = dValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Make the Display class a friend of Storage</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Display</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> m_displayIntFirst;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Display</span>(<span class="type">bool</span> displayIntFirst) &#123; m_displayIntFirst = displayIntFirst; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">displayItem</span><span class="params">(Storage &amp;storage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_displayIntFirst)</span><br><span class="line">      std::cout &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// display double first</span></span><br><span class="line">      std::cout &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Friend member functions</strong></p>
<p>Instead of making an entire class a friend, you can make a single member function a friend. This is done similarly to making a normal function a friend, except using the name of the member function with the className:: prefix included (e.g. Display::displayItem).</p>
<p>However, in actuality, this can be a little trickier than expected. Let’s convert the previous example to make Display::displayItem a friend member function. You might try something like this:</p>
<p><strong>Note:</strong> But it is not a member function! (member func -&gt; a friend)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display::displayItem</span><span class="params">(Storage&amp; storage)</span></span>;</span><br><span class="line">  <span class="comment">// error: Storage hasn&#x27;t seen the full definition of class Display</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>However, it turns out this won’t work. In order to make a class’s member function a friend, the compiler <code>has to have seen the full definition for the class of the friend member function</code> (not just a forward declaration). Since class Storage hasn’t seen the full definition for class Display yet, the compiler will error at the point where we try to make the member function a friend.</p>
<p>Fortunately, this is easily resolved simply by moving the definition of class Display before the definition of class Storage.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forward declaration</span></span><br><span class="line"><span class="comment">// class Storage;   // forward declaration for Storage</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">  <span class="comment">// if displayItem() here uses Storage as a reference, we can add forward declaration before &quot;class Display &#123; ... &#125;;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="comment">// goo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If this seems like a pain – it is. Fortunately, this dance is only necessary because we’re trying to do everything in a single file. A better solution is to put each class definition in a separate header file, with the member function definitions in corresponding .cpp files. That way, all of the class definitions would have been visible immediately in the .cpp files, and no rearranging of classes or functions is necessary!</p>
<p><strong>Summary</strong></p>
<p><strong>A friend function or class is a function or class that can access the private members of another class as though it were a member of that class. This allows the friend or class to work intimately with the other class, without making the other class expose its private members (e.g. via access functions).</strong></p>
<p>Friending is <code>uncommonly</code> used when two or more classes need to work together in an intimate way, or much more commonly, when defining overloading operators (which we’ll cover in chapter 9).</p>
<p>Note that making a specific member function a friend requires the full definition for the class of the member function to have been seen first.</p>
<h3 id="Anonymous-objects"><a href="#Anonymous-objects" class="headerlink" title="Anonymous objects"></a>Anonymous objects</h3><p>Although our prior examples have been with built-in data types, it is possible to construct anonymous objects of our own class types as well. This is done by creating objects like normal, but omitting the variable name.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cents <span class="title">cents</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">Cents</span>(<span class="number">7</span>);   <span class="comment">// anonymous object</span></span><br></pre></td></tr></table></figure>

<p>More specifically,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cents</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cents</span>(<span class="type">int</span> cents) &#123; m_cents = cents; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;; <span class="comment">// end of the class</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Cents &amp;cents)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; cents.<span class="built_in">getCents</span>() &lt;&lt; <span class="string">&quot; cents&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cents <span class="title">add</span><span class="params">(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Cents</span>(c1.<span class="built_in">getCents</span>() + c2.<span class="built_in">getCents</span>());</span><br><span class="line">  <span class="comment">// return anonymous Cents value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">Cents</span>(<span class="number">6</span>));</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">add</span>(<span class="built_in">Cents</span>(<span class="number">6</span>), <span class="built_in">Cents</span>(<span class="number">8</span>)).<span class="built_in">getCents</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>It is worth noting that anonymous objects are treated as rvalues</strong> (not lvalues, which have an address). This means anonymous objects can only be passed or returned by value or const reference. Otherwise, a named variable must be used instead.</p>
<h3 id="Nested-types-in-classes"><a href="#Nested-types-in-classes" class="headerlink" title="Nested types in classes"></a>Nested types in classes</h3><p>Unlike functions, which can’t be nested inside each other, in C++, types can be defined (nested) inside of a class. To do this, you simply define the type inside the class, under the appropriate access specifier.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Note: we&#x27;ve moved FruitType inside the class</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">FruitType</span> &#123;</span><br><span class="line">    APPLE,</span><br><span class="line">    BANANA,</span><br><span class="line">    CHERRY</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Here, we can access the enum by Fruit::FruitType::APPLE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Classes essentially act as a namespace for any nested types.</strong> In the prior example, we were able to access enumerator APPLE directly, because the APPLE enumerator was placed into the global scope (we could have prevented this by using an enum class instead of an enum, in which case we’d have accessed APPLE via <code>Fruit::FruitType::APPLE</code> instead). Now, because FruitType is considered to be part of the class, we access the APPLE enumerator by prefixing it with the class name: Fruit::APPLE.</p>
<p>Note that because enum classes also act like namespaces, if we’d nested FruitType inside Fruit as an enum class instead of an enum, we’d access the APPLE enumerator via <code>Fruit::FruitType::APPLE</code>.</p>
<p>Although enumerations are probably the most common type that is nested inside a class, C++ will let you define other types within a class, such as <code>typedefs, type aliases, and even other classes</code>!</p>
<p>Like any normal member of a class, nested classes have the same access to members of the enclosing class that the enclosing class does. <strong>However, the nested class does not have any special access to the “this” pointer of the enclosing class.</strong></p>
<p><strong>Defining nested classes isn’t very common, but the C++ standard library does do so in some cases, such as with iterator classes.</strong></p>
<h3 id="Timing-your-code-Timing-API"><a href="#Timing-your-code-Timing-API" class="headerlink" title="Timing your code (Timing API)"></a>Timing your code (Timing API)</h3><p>One easy way is to time your code to see how long it takes to run. C++11 comes with some functionality in the <code>chrono library</code> to do just that. However, using the chrono library is a bit arcane. The good news is that we can easily encapsulate all the timing functionality we need into a class that we can then use in our own programs.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Type aliases to make accessing nested type easier</span></span><br><span class="line">  <span class="keyword">using</span> <span class="type">clock_t</span> = std::chrono::high_resolution_clock;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">second_t</span> = std::chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>&gt; &gt;;</span><br><span class="line"></span><br><span class="line">  std::chrono::time_point&lt;<span class="type">clock_t</span>&gt; m_beg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Timer</span>() : <span class="built_in">m_beg</span>(<span class="type">clock_t</span>::<span class="built_in">now</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_beg = <span class="type">clock_t</span>::<span class="built_in">now</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">elapsed</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::chrono::<span class="built_in">duration_cast</span>&lt;<span class="type">second_t</span>&gt;(<span class="type">clock_t</span>::<span class="built_in">now</span>() - m_beg).<span class="built_in">count</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_arrayElements = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="type">int</span>, g_arrayElements&gt; array;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_arrayElements; ++i)</span><br><span class="line">    array[i] = g_arrayElements - i;</span><br><span class="line"></span><br><span class="line">  Timer t;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Time taken: &quot;</span> &lt;&lt; t.<span class="built_in">elapsed</span>() &lt;&lt; <span class="string">&quot; seconds\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Timing is straightforward, but your results can be significantly impacted by a number of things, and it’s important to be aware of what those things are.</p>
<ol>
<li>Make sure you’re using a release build target, not a debug build target. Debug build targets typically <code>turn optimization off</code>, and that optimization can have a significant impact on the results.</li>
<li>For best results, make sure your system isn’t doing anything CPU or memory intensive.</li>
<li>When doing comparisons between two sets of code, be wary of what may change between runs that could impact timing. Your system may have kicked off an antivirus scan in the background, or maybe you’re streaming music now when you weren’t previously. Randomization can also impact timing.</li>
</ol>
<h2 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h2><p><strong>In C++, operators are implemented as functions.</strong> By using function overloading on the operator functions, you can define your own versions of the operators that work with different data types (including classes that you’ve written). Using function overloading to overload operators is called operator overloading.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x + y <span class="comment">// translated as follow</span></span><br><span class="line"><span class="keyword">operator</span>+(x, y) <span class="comment">// where operator+ is the name of the function</span></span><br></pre></td></tr></table></figure>

<p><strong>Resolving overloaded operators</strong></p>
<p>When evaluating an expression containing an operator, the compiler uses the following rules:</p>
<ul>
<li>If <strong>all</strong> of the operands are <code>fundamental data types</code>, the compiler will call a built-in routine if one exists. If one does not exist, the compiler will produce a compiler error.</li>
<li>If <strong>any</strong> of the operands are <code>user data types</code> (e.g. one of your classes, or an enum type), the compiler looks to see whether the type has a matching overloaded operator function that it can call. If it can’t find one, <strong>it will try to convert one or more of the user-defined type operands into fundamental data types</strong> so it can use a matching built-in operator (via an overloaded typecast, which we’ll cover later in this chapter). If that fails, then it will produce a compile error.</li>
</ul>
<p><strong>Note:</strong></p>
<ul>
<li><p>First, almost any existing operator in C++ can be overloaded. The exceptions are: conditional (?:), sizeof, scope (::), member selector (.), and member pointer selector (.*).</p>
</li>
<li><p>Second, you can only overload the operators that exist. You cannot create new operators or rename existing operators. For example, you could not create an operator ** to do exponents.</p>
</li>
<li><p>Third, at least one of the operands in an overloaded operator must be a user-defined type. This means you can not overload the plus operator (+) to work with one integer and one double. However, you could overload the plus operator to work with an integer and a MyString.</p>
</li>
<li><p>Fourth, it is not possible to change the number of operands an operator supports.</p>
</li>
<li><p>Finally, all operators keep their default precedence and associativity (regardless of what they’re used for) and this cannot be changed.</p>
<ul>
<li>One example: Some new programmers attempt to overload the bitwise XOR operator (^) to do exponentiation. However, in C++, operator^ has a lower precedence level than the basic arithmetic operators, which causes expressions to evaluate incorrectly.</li>
</ul>
</li>
</ul>
<p><strong>Rule:</strong> When overloading operators, it’s best to keep the function of the operators as <code>close to the original intent</code> of the operators as possible.</p>
<p><strong>Rule:</strong> If the meaning of an operator when applied to a custom class is not clear and intuitive, use a named function instead.</p>
<h3 id="Overload-the-arithmetic-operators-using-friend-functions"><a href="#Overload-the-arithmetic-operators-using-friend-functions" class="headerlink" title="Overload the arithmetic operators using friend functions"></a>Overload the arithmetic operators using friend functions</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addCents example</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cents</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2);</span><br><span class="line">  <span class="comment">// if we declare it as a member function, we need an Cents object to use this function!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2) &#123;</span><br><span class="line">  <span class="comment">// note: this function is not a member function!</span></span><br><span class="line">  <span class="comment">// we can access m_cents directly because this is a friend function</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Cents</span>(c1.m_cents + c2.m_cents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Friend functions can be defined inside the class:</strong></p>
<p>Even though friend functions are not members of the class, they can still be defined inside the class if desired:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// but it is not a member function</span></span><br><span class="line">  <span class="keyword">friend</span> Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cents</span>(c1.m_cents + c2.m_cents);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>We generally don’t recommend this, as non-trivial (important) function definitions are better kept in a separate .cpp file, outside of the class definition. However, we will use this pattern in future tutorials to keep the examples concise.</p>
<p><strong>Overloading operators for operands of different types</strong></p>
<p>When C++ evaluates the expression x + y, x becomes the first parameter, and y becomes the second parameter. When x and y have the same type, it does not matter if you add x + y or y + x – either way, the same version of operator+ gets called. However, when the operands have different types, x + y does not call the same function as y + x.</p>
<p>For example, <code>Cents(4) + 6</code> would call <code>operator+(Cents, int)</code>, and <code>6 + Cents(4)</code> would call <code>operator+(int, Cents)</code>.</p>
<p>Therefore, we need to write two functions separately:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add Cents + int using a friend function</span></span><br><span class="line"><span class="keyword">friend</span> Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add int + Cents using a friend function</span></span><br><span class="line"><span class="keyword">friend</span> Cents <span class="keyword">operator</span>+(<span class="type">int</span> value, <span class="type">const</span> Cents &amp;c1) &#123;</span><br><span class="line">  <span class="keyword">return</span> c1 + value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It is often possible to define overloaded operators by calling other overloaded operators. You should do so if and when doing so produces simpler code.</p>
<h3 id="Overload-operators-using-normal-functions"><a href="#Overload-operators-using-normal-functions" class="headerlink" title="Overload operators using normal functions"></a>Overload operators using normal functions</h3><p>Using a friend function to overload an operator is convenient because it gives you direct access to the internal members of the classes you’re operating on. In the initial Cents example above, our friend function version of operator+ accessed member variable <code>m_cents</code> directly.</p>
<p>However, if you don’t need that access, you can write your overloaded operators as normal non-member functions. Note that the Cents class above contains an access function (<code>getCents()</code>) that allows us to get at <code>m_cents</code> without having to have direct access to private members. Because of this, we can write our overloaded operator+ as a non-friend:</p>
<p>One-file version:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: this function is not a member function nor a friend function!</span></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2) &#123;</span><br><span class="line">  <span class="comment">// use the Cents constructor and operator+(int, int)</span></span><br><span class="line">  <span class="comment">// we don&#x27;t need direct access to private members here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Cents</span>(c1.<span class="built_in">getCents</span>() + c2.<span class="built_in">getCents</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Two-file version:</p>
<ul>
<li><p>Cents.h:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cents</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cents</span>(<span class="type">int</span> cents) &#123; m_cents = cents; &#125; </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Need to explicitly provide prototype for operator+ so uses of operator+ in other files know this overload exists</span></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cents.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cents.h&quot;</span></span></span><br><span class="line"><span class="comment">// note: this function is not a member function nor a friend function!</span></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;c1, <span class="type">const</span> Cents &amp;c2) &#123;</span><br><span class="line">  <span class="comment">// use the Cents constructor and operator+(int, int)</span></span><br><span class="line">  <span class="comment">// we don&#x27;t need direct access to private members here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Cents</span>(c1.<span class="built_in">getCents</span>() + c2.<span class="built_in">getCents</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>In general, a normal function should be preferred over a friend function if it’s possible to do so with the existing member functions available (the less functions touching your classes’ internals, the better). However, don’t add additional access functions just to overload an operator as a normal function instead of a friend function!</p>
<p><strong>Rule:</strong> Prefer overloading operators as normal functions instead of friends if it’s possible to do so without adding additional functions.</p>
<h3 id="Overload-the-I-O-operators"><a href="#Overload-the-I-O-operators" class="headerlink" title="Overload the I&#x2F;O operators"></a>Overload the I&#x2F;O operators</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::ostream is the type for object std::cout</span></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="type">const</span> Point &amp;point);</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="type">const</span> Point &amp;point) &#123;</span><br><span class="line">  <span class="comment">// Since operator&lt;&lt; is a friend of the Point class, we can access Point&#x27;s members directly.</span></span><br><span class="line">  out &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.m_x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point.m_y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Point <span class="title">point</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; point &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The trickiest part here is the return type. With the arithmetic operators, we calculated and returned a single answer by value (because we were creating and returning a new result). <strong>However, if you try to return std::ostream by value, you’ll get a compiler error. This happens because std::ostream specifically disallows being copied.</strong></p>
<p>In this case, we return the left-hand parameter as a reference. This not only prevents a copy of std::ostream from being made, it also allows us to “chain” output commands together, such as <code>std::cout &lt;&lt; point &lt;&lt; std::endl;</code>.</p>
<p><strong>Overloading operator&gt;&gt;</strong></p>
<p>It is also possible to overload the input operator. This is done in a manner analogous to overloading the output operator. The key thing you need to know is that std::cin is an object of type std::istream. Here’s our Point class with an overloaded operator&gt;&gt;:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream &amp;in, Point &amp;point) &#123;</span><br><span class="line">  in &gt;&gt; point.m_x;</span><br><span class="line">  in &gt;&gt; point.m_y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Point point;</span></span><br><span class="line"><span class="comment">// std::cin &gt;&gt; point;</span></span><br></pre></td></tr></table></figure>

<p>In conclusion, overloading operator&lt;&lt; and operator&gt;&gt; make it extremely easy to output your class to screen and accept user input from the console.</p>
<h3 id="Overload-operators-using-member-functions"><a href="#Overload-operators-using-member-functions" class="headerlink" title="Overload operators using member functions"></a>Overload operators using member functions</h3><p>Overloading operators using a member function is very similar to overloading operators using a friend function. When overloading an operator using a member function:</p>
<ul>
<li>The overloaded operator must be added as a member function of the left operand.</li>
<li>The left operand becomes the implicit *this object</li>
<li>All other operands become function parameters.</li>
</ul>
<p>Converting a friend overloaded operator to a member overloaded operator is easy:</p>
<ol>
<li>The left parameter is removed, because that parameter now becomes the implicit *this object.</li>
<li>Inside the function body, all references to the left parameter can be removed (e.g. cents.m_cents becomes m_cents, which implicitly references the *this object).</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// friend version</span></span><br><span class="line"><span class="keyword">friend</span> Cents <span class="keyword">operator</span>+(<span class="type">const</span> Cents &amp;cents, <span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// member version</span></span><br><span class="line">Cents <span class="keyword">operator</span>+(<span class="type">int</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Cents</span>(m_cents + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Cents cents2 = cents1 + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// friend version: operator+(cents1, 2)</span></span><br><span class="line"><span class="comment">// member version: cents1.operator+(2) --implicitly--&gt; operator+(&amp;cents1, 2)</span></span><br></pre></td></tr></table></figure>

<p>So if we can overload an operator as a friend or a member, which should we use? In order to answer that question, there’s a few more things you’ll need to know.</p>
<p><strong>Not everything can be overloaded as a friend function:</strong></p>
<p>The assignment (&#x3D;), subscript ([]), function call (()), and member selection (-&gt;) operators must be overloaded as member functions, because the language requires them to be.</p>
<p><strong>Not everything can be overloaded as a member function:</strong></p>
<p>In lesson 9.3 – Overloading the I&#x2F;O operators, we overloaded operator&lt;&lt; for our Point class using the friend function method.</p>
<p>However, we are not able to overload operator&lt;&lt; as a member function. Why not? <strong>Because the overloaded operator must be added as a member of the left operand.</strong> In this case, the left operand is an object of type std::ostream. std::ostream is fixed as part of the standard library. We can’t modify the class declaration to add the overload as a member function of std::ostream. This necessitates that operator&lt;&lt; be overloaded as a friend.</p>
<p>Similarly, although we can overload operator+(Cents, int) as a member function (as we did above), we can’t overload operator+(int, Cents) as a member function, because int isn’t a class we can add members to.</p>
<p>Typically, we won’t be able to use a member overload if the left operand is either not a class (e.g. int), or it is a class that we can’t modify (e.g. std::ostream).</p>
<p><strong>When do we use a normal, friend, or member function overload?</strong></p>
<p>One of the two is usually a better choice than the other.</p>
<ul>
<li><p>When dealing with <code>binary operators</code> that <code>don&#39;t modify the left operand</code> (e.g. operator+), the normal or friend function version is typically preferred, because it works for all parameter types (even when the left operand isn’t a class object, or is a class that is not modifiable). The normal or friend function version has the added benefit of “symmetry”, as all operands become explicit parameters (instead of the left operand becoming *this and the right operand becoming an explicit parameter).</p>
</li>
<li><p>When dealing with <code>binary operators</code> that <code>do modify the left operand</code> (e.g. operator+&#x3D;), the member function version is typically preferred. In these cases, the leftmost operand will always be a class type, and having the object being modified become the one pointed to by *this is natural. Because the rightmost operand becomes an explicit parameter, there’s no confusion over who is getting modified and who is getting evaluated.</p>
</li>
<li><p><code>Unary operators</code> are usually overloaded as member functions as well, since the member version has no parameters.</p>
</li>
</ul>
<p>The following rules of thumb can help you determine which form is best for a given situation:</p>
<ul>
<li>If you’re overloading assignment (&#x3D;), subscript ([]), function call (()), or member selection (-&gt;), do so as a <code>member function</code>.</li>
<li>If you’re overloading a <code>unary operator</code>, do so as a <code>member function</code>.</li>
<li>If you’re overloading a <code>binary operator</code> that modifies its left operand (e.g. operator+&#x3D;), do so as a <code>member function</code> if you can.</li>
<li>If you’re overloading a <code>binary operator</code> that does not modify its left operand (e.g. operator+), do so as a <code>normal function or friend function</code>. (if left operands of basic types change, they are new variables, not the original ones)</li>
</ul>
<p>Also, friend or normal?</p>
<ul>
<li>Depending on whether you’re going to access the private members of the class.</li>
<li>But in the normal version, you can still call public getter and setter to access private members.</li>
</ul>
<h3 id="Overload-unary-operators-and"><a href="#Overload-unary-operators-and" class="headerlink" title="Overload unary operators +, -, and !"></a>Overload unary operators +, -, and !</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// const! member function</span></span><br><span class="line">  Cents <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cents</span>(-m_cents);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Note that there’s no confusion between the negative operator- and the<br>minus operator- since they have a different number of parameters.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// const! (member function)</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (m_x == <span class="number">0.0</span> &amp;&amp; m_y == <span class="number">0.0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>




<h3 id="Overload-the-comparison-operators"><a href="#Overload-the-comparison-operators" class="headerlink" title="Overload the comparison operators"></a>Overload the comparison operators</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal or friend version (don&#x27;t need const)</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Car &amp;c1, <span class="type">const</span> Car &amp;c2) &#123;</span><br><span class="line">  <span class="built_in">return</span> (c1.m_make == c2.m_make &amp;&amp; c1.m_model == c2.m_model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What about operator&lt; and operator&gt;? What would it mean for a Car to be greater or less than another Car? We typically don’t think about cars this way. Since the results of operator&lt; and operator&gt; would not be immediately intuitive, it may be better to leave these operators undefined.</p>
<p><strong>Recommendation:</strong> Don’t define overloaded operators that don’t make sense for your class.</p>
<p>However, there is one common exception to the above recommendation. What if we wanted to <code>sort a list of Cars</code>? In such a case, we might want to overload the comparison operators to return the member (or members) you’re most likely to want to sort on. For example, an overloaded operator&lt; for Cars might sort based on make and model alphabetically.</p>
<h3 id="Overload-the-increment-and-decrement-operators"><a href="#Overload-the-increment-and-decrement-operators" class="headerlink" title="Overload the increment and decrement operators"></a>Overload the increment and decrement operators</h3><p>Because the increment and decrement operators are both <code>unary</code> operators and they <code>modify</code> their operands, they’re best overloaded as member functions. We’ll tackle the prefix versions first because they’re the most straightforward.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// prefix version</span></span><br><span class="line">  Digit&amp; <span class="keyword">operator</span>++ () &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_digit == <span class="number">9</span>)</span><br><span class="line">      m_digit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++m_digit;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Overloading postfix increment and decrement</strong></p>
<p>Normally, functions can be overloaded when they have the same name but a different number and&#x2F;or different types of parameters. However, consider the case of the prefix and postfix increment and decrement operators. Both have the same name (eg. operator++), are unary, and take one parameter of the same type. So how it is possible to differentiate the two when overloading?</p>
<blockquote>
<p>dummy &#x3D; fake, false</p>
</blockquote>
<p>The answer is that C++ uses a <code>dummy variable</code> or <code>dummy argument</code> for the postfix operators. This argument is a fake integer parameter that only serves to distinguish the postfix version of increment&#x2F;decrement from the prefix version.</p>
<ul>
<li><p><code>++i</code>: i is the (this), so the 1st parameter is not needed.</p>
</li>
<li><p><code>i++</code>: i corresponds the 2nd parameter “int”, but we don’t use it; instead we’ll use the implicit, hidden 1st parameter (this).</p>
</li>
</ul>
<p>I don’t know if it is correct. Too confusing. Maybe it just belongs to syntax stuff.</p>
<p>Here is the above Digit class with both prefix and postfix overloads:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// prefix  | ++i</span></span><br><span class="line">  Digit&amp; <span class="keyword">operator</span>++(); <span class="comment">// member function</span></span><br><span class="line">  <span class="comment">// postfix | i++</span></span><br><span class="line">  Digit <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">// member function</span></span><br><span class="line">    <span class="comment">// Create a temp</span></span><br><span class="line">    <span class="function">Digit <span class="title">temp</span><span class="params">(m_digit)</span></span>;</span><br><span class="line">    <span class="comment">// apply the prefix operator above, cut down duplicate code!</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Return temp result</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>There are a few interesting things going on here. </p>
<ul>
<li><p>First, note that we’ve distinguished the prefix from the postfix operators by providing an integer dummy parameter on the postfix version. </p>
</li>
<li><p>Second, because the dummy parameter is not used in the function implementation, we have not even given it a name. This tells the compiler to treat this variable as a <code>placeholder</code>, which means it won’t warn us that we declared a variable but never used it.</p>
</li>
<li><p>Third, note that the prefix and postfix operators do the same job – they both increment or decrement the object. The difference between the two is in the value they return. The overloaded prefix operators return the object after it has been incremented or decremented. Consequently, overloading these is fairly straightforward. We simply increment or decrement our member variables, and then return <code>*this</code>.</p>
</li>
<li><p>The postfix operators, on the other hand, need to return the state of the object before it is incremented or decremented. This leads to a bit of a conundrum – if we increment or decrement the object, we won’t be able to return the state of the object before it was incremented or decremented. On the other hand, if we return the state of the object before we increment or decrement it, the increment or decrement will never be called.</p>
</li>
</ul>
<p>The typical way this problem is solved is to use a temporary variable that holds the value of the object before it is incremented or decremented. Then the object itself can be incremented or decremented. And finally, the temporary variable is returned to the caller. In this way, the caller receives a copy of the object before it was incremented or decremented, but the object itself is incremented or decremented. <strong>Note that this means the return value of the overloaded operator must be a non-reference, because we can’t return a reference to a local variable that will be destroyed when the function exits.</strong> Also note that this means the postfix operators are typically <code>less efficient</code> than the prefix operators because of the added overhead of instantiating a temporary variable and returning by value instead of reference.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that there are two different objects!</span></span><br><span class="line">C &gt; C++ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>





<h3 id="Overload-the-subscript-operator"><a href="#Overload-the-subscript-operator" class="headerlink" title="Overload the subscript operator"></a>Overload the subscript operator</h3><p>The subscript operator is one of the operators that must be overloaded as a <code>member function</code>. An overloaded operator[] function will always take <code>one parameter</code> (unary): the subscript that the user places between the hard braces. In our IntList case, we expect the user to pass in an integer index, and we’ll return an integer value back as a result.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_list[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// including setter and getter!</span></span><br><span class="line"><span class="type">int</span>&amp; IntList::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> index) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="number">10</span>); <span class="comment">// error checking</span></span><br><span class="line">  <span class="keyword">return</span> m_list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is both easy syntactically and from a comprehension standpoint. When list[2] evaluates, the compiler first checks to see if there’s an overloaded operator[] function. If so, it passes the value inside the hard braces (in this case, 2) as an argument to the function.</p>
<p>Note that although you can provide a default value for the function parameter, actually using operator[] without a subscript inside is not considered a valid syntax, so there’s no point.</p>
<p><strong>Why operator[] returns a reference</strong></p>
<p>Let’s take a closer look at how list[2] &#x3D; 3 evaluates. Because the subscript operator has a higher precedence than the assignment operator, list[2] evaluates first. list[2] calls operator[], which we’ve defined to return a reference to list.m_list[2]. Because operator[] is returning a reference, it returns the actual list.m_list[2] array element. Our partially evaluated expression becomes list.m_list[2] &#x3D; 3, which is a straightforward integer assignment.</p>
<p><strong>Note:</strong> Because the result of operator[] can be used on the left-hand side of an assignment, the return value of operator[] must be l-value, because you can only take a reference of variables that have memory addresses.</p>
<p><strong>Dealing with const objects</strong></p>
<p>In the above IntList example, operator[] is <code>non-const</code>, and we can use it as an l-value to change the state of non-const objects. However, <code>what if our IntList object was const</code>? In this case, we wouldn’t be able to call the non-const version of operator[] because that would allow us to potentially change the state of a const object.</p>
<p>The good news is that we can define a non-const and a const version of operator[] separately. The non-const version will be used with non-const objects, and the const version with const-objects.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> index);</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> index);  <span class="comment">// add const?</span></span><br></pre></td></tr></table></figure>

<p><strong>Pointers to objects and overloaded operator[] don’t mix</strong></p>
<p>If you try to call operator[] on a pointer to an object, C++ will assume you’re trying to index an array of objects of that type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntList *list = <span class="keyword">new</span> IntList;</span><br><span class="line">list[<span class="number">2</span>] = <span class="number">3</span>;  <span class="comment">// error: this will assume we&#x27;re accessing index 2 of an array of IntLists</span></span><br><span class="line"><span class="comment">// proper syntax:</span></span><br><span class="line">(*list)[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">delete</span> list;</span><br></pre></td></tr></table></figure>

<p>Because we can’t assign an integer to an IntList, this won’t compile. However, if assigning an integer was valid, this would compile and run, with undefined results.</p>
<p><strong>Rule:</strong> Make sure you’re not trying to call an overloaded operator[] on a pointer to an object.</p>
<p><strong>The function parameter does not need to be an integer</strong></p>
<p>As mentioned above, C++ passes what the user types between the hard braces as an argument to the overloaded function. In most cases, this will be an integer value. However, this is not required – and in fact, you can define that your overloaded operator[] take a value of any type you desire. You could define your overloaded operator[] to take a double, a std::string, or whatever else you like.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stupid</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>[](std::string index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// It does not make sense to print sth., but it is the easiest way to show that the function parameter can be a non-integer</span></span><br><span class="line"><span class="type">void</span> Stupid::<span class="keyword">operator</span>[](std::string index) &#123;</span><br><span class="line">  std::cout &lt;&lt; index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Overload-the-parenthesis-operator"><a href="#Overload-the-parenthesis-operator" class="headerlink" title="Overload the parenthesis operator"></a>Overload the parenthesis operator</h3><p><strong>Why this one is special</strong></p>
<p>All of the overloaded operators you have seen so far let you define the type of the operator’s parameters, but not the number of parameters (which is fixed based on the type of the operator). For example, operator&#x3D;&#x3D; always takes two parameters, whereas operator! always takes one. <strong>The parenthesis operator() is a particularly interesting operator in that it allows you to vary both the <code>type AND number</code> of parameters it takes.</strong></p>
<p>There are two things to keep in mind: </p>
<ul>
<li>First, the parenthesis operator must be implemented as a <code>member function</code>. </li>
<li>Second, in non-object-oriented C++, the () operator is used to call functions. In the case of classes, operator() is just a normal operator that calls a function (named operator()) like any other overloaded operator.</li>
</ul>
<p>The following content is about Matrix.</p>
<p>Operator[] is limited to a single parameter, it is not sufficient to let us index a two-dimensional array.</p>
<p>However, because the () operator can take as many parameters as we want it to have, we can declare a version of operator() that takes two integer index parameters, and use it to access our two-dimensional array. Here is an example of this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> data[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert</span></span><br><span class="line">    <span class="keyword">return</span> data[row][col];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">double</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert</span></span><br><span class="line">    <span class="keyword">return</span> data[row][col];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reset all elements of the matrix to 0.0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Matrix matrix;</span><br><span class="line"><span class="built_in">matrix</span>(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">4.5</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">matrix</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">matrix</span>(); <span class="comment">// erase matrix</span></span><br></pre></td></tr></table></figure>

<p>Because the () operator is so flexible, it can be tempting to use it for many different purposes. <strong>However, this is strongly discouraged, since the () symbol does not really give any indication of what the operator is doing.</strong> In our example above, it would be better to have written the erase functionality as a function called clear() or erase(), as matrix.erase() is easier to understand than matrix() (which could do anything!).</p>
<p><strong>Having fun with functors</strong></p>
<p>Operator() is also commonly overloaded to implement <code>functors</code> (or function object), which are classes that operate like functions. The advantage of a functor over a normal function is that functors can store data in member variables (since they are classes).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_counter = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Accumulator</span>() &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_counter += i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Accumulator acc;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">acc</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// prints 10</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">acc</span>(<span class="number">20</span>) &lt;&lt; std::endl; <span class="comment">// prints 30</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that using our Accumulator looks just like making a normal function call, but our Accumulator object is storing an accumulated value.</p>
<p>You may wonder why we couldn’t do the same thing with a normal function and a static local variable to preserve data between function calls. We could, but because functions only have <code>one</code> global instance, we’d be limited to using it for one thing at a time. With functors, we can instantiate as <code>many</code> separate functor objects as we need and use them all simultaneously.</p>
<h3 id="Overload-typecasts"><a href="#Overload-typecasts" class="headerlink" title="Overload typecasts"></a>Overload typecasts</h3><p>C++ already knows how to convert between the built-in data types. However, it does not know how to convert any of our user-defined classes. That’s where overloading the typecast operators comes into play.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Cents <span class="title">cents</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">  <span class="built_in">printInt</span>(cents.<span class="built_in">getCents</span>()); <span class="comment">// print 7</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we have already written a lot of functions that take integers as parameters, our code will be littered with calls to getCents(), which makes it more messy than it needs to be.</p>
<p>To make things easier, we can overload the int typecast, which will allow us to cast our Cents class object directly into an int. The following example shows how this is done:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cents</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cents</span>(<span class="type">int</span> cents=<span class="number">0</span>) &#123;</span><br><span class="line">    m_cents = cents;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Overloaded int typecast</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125; <span class="comment">// no return type!</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCents</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setCents</span><span class="params">(<span class="type">int</span> cents)</span> </span>&#123; m_cents = cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Cents <span class="title">cents</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">  <span class="built_in">printInt</span>(cents);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are two things to note:</p>
<ul>
<li>To overload the function that casts our class to an int, we write a new function in our class called <code>operator int()</code>. Note that there is a space between the word operator and the type we are casting to.</li>
<li><strong>Casting operators do not have a return type. C++ assumes you will be returning the correct type.</strong></li>
</ul>
<p>We can now also explicitly cast our Cents variable to an int by <code>static_cast&lt;int&gt;()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cents <span class="title">cents</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(cents);</span><br></pre></td></tr></table></figure>

<p>You can overload cast operators for any data type you wish, including your own <code>user-defined data types</code>!</p>
<p>Here’s a new class called Dollars that provides an overloaded Cents cast operator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dollars</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_dollars;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dollars</span>(<span class="type">int</span> dollars=<span class="number">0</span>) &#123;</span><br><span class="line">    m_dollars = dollars;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow us to convert Dollars into Cents</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Cents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cents</span>(m_dollars * <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">Dollars <span class="title">dollars</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="built_in">printCents</span>(dollars);  <span class="comment">// dollars will be implicitly cast to a Cents here</span></span><br><span class="line">Cents c = <span class="built_in">static_cast</span>&lt;Cents&gt;(dollars); <span class="comment">// or use static_cast&lt;Cents&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="The-copy-constructor"><a href="#The-copy-constructor" class="headerlink" title="The copy constructor"></a>The copy constructor</h3><p>Recap the types of initialization that C++ supports:</p>
<ul>
<li>direct initialization</li>
<li>uniform initialization</li>
<li>copy initialization</li>
</ul>
<p>With direct and uniform initialization, the object being created is <code>directly</code> initialized. However, copy initialization is a little more complicated. We’ll explore copy initialization in more detail in the next lesson. But in order to do that effectively, we need to take a short detour.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>; <span class="comment">// Direct initialize a Fraction, calls Fraction(int, int) constructor</span></span><br><span class="line">  <span class="function">Fraction <span class="title">fCopy</span><span class="params">(fiveThirds)</span></span>;  <span class="comment">// with what constructor??</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The answer is that this line is calling Fraction’s <code>copy constructor</code>. <strong>A copy constructor is a special type of constructor used to create a new object as a copy of an existing object</strong>. And much like a default constructor, if you do not provide a copy constructor for your classes, <strong>C++ will create a public copy constructor for you</strong>. Because the compiler does not know much about your class, by default, the created copy constructor utilizes a method of initialization called <code>memberwise initialization</code>. Memberwise initialization simply means that each member of the copy is initialized directly from the member of the class being copied. In the above example, <code>fCopy.m_numerator</code> would be initialized from <code>fiveThirds.m_numerator</code>, etc.</p>
<p>Just like we can explicitly define a default constructor, we can also explicitly define a copy constructor. The copy constructor looks just like you’d expect it to:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line"><span class="built_in">Fraction</span>(<span class="type">const</span> Fraction &amp;fraction)</span><br><span class="line">    : <span class="built_in">m_numerator</span>(fraction.m_numerator), <span class="built_in">m_denominator</span>(fraction.m_denominator) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Copy constructor called\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>One interesting note:</strong> You’ve already seen a few examples of overloaded operator&lt;&lt;, where we’re able to access the private members of parameter f1 because the function is a friend of the Fraction class. Similarly, member functions of a class can access the private members of parameters of the same class type. Since our Fraction copy constructor takes a parameter of the class type (to make a copy of), we’re able to access the members of parameter fraction directly, even though it’s not the implicit object.</p>
<p><strong>Preventing copies</strong></p>
<p>We can prevent copies of our classes from being made by making the copy constructor private:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">const</span> Fraction &amp;fraction)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(fraction.m_numerator), <span class="built_in">m_denominator</span>(fraction.m_denominator) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Testing&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>The copy constructor may be elided</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">const</span> Fraction &amp;fraction)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(fraction.m_numerator), <span class="built_in">m_denominator</span>(fraction.m_denominator) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Testing&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// original version</span></span><br><span class="line"><span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Fraction <span class="title">fCopy</span><span class="params">(fiveThirds)</span></span>;</span><br><span class="line"><span class="comment">// output: Testing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Elided version</span></span><br><span class="line"><span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(Fraction(<span class="number">5</span>, <span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="comment">// output: nothing!</span></span><br></pre></td></tr></table></figure>

<p>Why didn’t our copy constructor get called?</p>
<p>Note that initializing an <code>anonymous</code> object and then using that object to direct initialize our defined object takes two steps (one to create the anonymous object using the default constructor, one to call the copy constructor). However, the end result is essentially identical to just doing a direct initialization, which only takes one step.</p>
<p>For this reason, in such case, the compiler is allowed to opt out of calling the copy constructor and just do a direct initialization instead. This process is called <code>elision</code>.</p>
<p>So although you wrote:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(Fraction(<span class="number">5</span>, <span class="number">3</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>The compiler may change this to:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>which only requires one constructor call (to Fraction(int, int)). Note that in cases where elision is used, any statements in the body of the copy constructor are not executed, even if they would have produced side effects (like printing to the screen)!</p>
<p>Prior to C++17, copy elision is an optimization the compiler can make. As of C++17, some cases of copy elision (including the example above) have been made mandatory.</p>
<p>Finally, note that if you make the copy constructor private, any initialization that would use the copy constructor will cause a compile error, <code>even if the copy constructor is elided</code>! <strong>Jesus!</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy constructor is private</span></span><br><span class="line"><span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(Fraction(<span class="number">5</span>, <span class="number">3</span>))</span></span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>



<h3 id="Copy-initialization"><a href="#Copy-initialization" class="headerlink" title="Copy initialization"></a>Copy initialization</h3><p>Consider the following line of code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>This statement uses <code>copy initialization</code> to initialize newly created integer variable x to the value of 5. However, classes are a little more complicated, since they use constructors for initialization.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fraction six = oldSix; <span class="comment">// evaluated as Fraction six(oldSix);</span></span><br><span class="line"><span class="comment">// so</span></span><br><span class="line">Fraction six = <span class="built_in">Fraction</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// it is evaluated the same way as the following</span></span><br><span class="line"><span class="function">Fraction <span class="title">six</span><span class="params">(Fraction(<span class="number">6</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>And as you learned in the previous lesson, this can potentially make calls to both <code>Fraction(int, int)</code> and the Fraction <code>copy constructor</code> (which may be elided for performance reasons). However, because eliding isn’t guaranteed (prior to C++17, where elision in this particular case is now mandatory), it’s better to avoid copy initialization for classes, and use uniform initialization instead.</p>
<p><strong>Other places copy initialization is used</strong></p>
<p>There are a few other places copy initialization is used, but two of them are worth mentioning explicitly. <strong>When you <code>pass or return</code> a class by <code>value</code>, that process uses copy initialization.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">makeNegative</span><span class="params">(Fraction f)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ideally we should do this by const reference</span></span><br><span class="line">  f.<span class="built_in">setNumerator</span>(-f.<span class="built_in">getNumerator</span>());</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>In the above case, both the argument passed by value and the return value cannot be elided.</strong> However, in other cases, if the argument or return value meet specific criteria, the compiler may opt to elide the copy constructor. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Something <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Something s;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Something s = <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Something <span class="title">goo</span><span class="params">(Something s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">goo</span>(<span class="built_in">Something</span>()); <span class="comment">// default constructor</span></span><br></pre></td></tr></table></figure>

<p>In this case, the compiler will probably elide the copy constructor, even though variable s is returned by value.</p>
<h3 id="Convert-constructors-explicit-and-delete"><a href="#Convert-constructors-explicit-and-delete" class="headerlink" title="Convert constructors, explicit, and delete"></a>Convert constructors, explicit, and delete</h3><p>By default, C++ will treat any constructor as an <code>implicit conversion operator</code>. Consider the following case:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Default constructor</span></span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(numerator), <span class="built_in">m_denominator</span>(denominator) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(denominator != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">makeNegative</span><span class="params">(Fraction f)</span> </span>&#123;</span><br><span class="line">  f.<span class="built_in">setNumerator</span>(-f.<span class="built_in">getNumerator</span>());</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">makeNegative</span>(<span class="number">6</span>); <span class="comment">// note the integer here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Although function <code>makeNegative()</code> is expecting a Fraction, we’ve given it the integer literal 6 instead. <strong>Because Fraction has a constructor willing to take a single integer, the compiler will implicitly convert the literal 6 into a Fraction object.</strong> It does this by <code>copy-initializing</code> makeNegative() parameter f using the <code>Fraction(int, int)</code> constructor. And in this case, copy initialization is elided.</p>
<p><strong>Note:</strong> This implicit conversion works for all kinds of initialization (direct, uniform, and copy).</p>
<p>Constructors eligible to be used for implicit conversions are called <code>converting constructors</code> (or conversion constructors). Prior to C++11, only constructors taking one parameter could be converting constructors. However, with the new uniform initialization syntax in C++11, this restriction was lifted, and constructors taking multiple parameters can now be converting constructors.</p>
<p><strong>The explicit keyword</strong></p>
<p>While doing implicit conversions makes sense in the Fraction case. In other cases, this may be undesirable, or lead to unexpected behaviors:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyString</span>(<span class="type">int</span> x) &#123; <span class="comment">// allocate string of size x</span></span><br><span class="line">    m_string.<span class="built_in">resize</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *string) &#123; <span class="comment">// allocate string to hold string value</span></span><br><span class="line">    m_string = string;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">MyString mine = <span class="string">&#x27;x&#x27;</span>;  <span class="comment">// use copy initialization for MyString</span></span><br></pre></td></tr></table></figure>

<p>In the above example, the user is trying to initialize a string with a char. Because chars are part of the integer family, the compiler will use the converting constructor MyString(int) constructor to implicitly convert the char to a MyString. The program will then print this MyString, to unexpected results.</p>
<p>One way to address this issue is to make constructors (and conversion functions) explicit via the <code>explicit</code> keyword, which is placed in front of the constructor’s name. <strong>Constructors and conversion functions made explicit will not be used for implicit conversions or copy initialization</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    m_string.<span class="built_in">resize</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">MyString mine = <span class="string">&#x27;x&#x27;</span>; <span class="comment">// compile error, since MyString(int) is now explicit and nothing will match this</span></span><br></pre></td></tr></table></figure>

<p>However, note that making a constructor <code>explicit</code> only prevents implicit conversions. Explicit conversions (via casting) are still allowed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">static_cast</span>&lt;MyString&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Allowed: explicit cast of 5 to MyString(int)</span></span><br></pre></td></tr></table></figure>

<p><strong>Direct or uniform initialization will also still convert parameters to match</strong> (uniform initialization will not do narrowing conversions, but it will happily do other types of conversions).</p>
<p><strong>I am losing myself! Complicated!</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">str</span><span class="params">(<span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">// Allowed: initialization parameters may still be implicitly converted to match</span></span><br></pre></td></tr></table></figure>

<p><strong>Rule:</strong> Consider making your constructors and user-defined conversion member functions <code>explicit</code> to prevent implicit conversion errors.</p>
<p>In C++11, the explicit keyword can also be used with conversion operators.</p>
<p><strong>The delete keyword</strong></p>
<p>In our MyString case, we really want to completely disallow ‘x’ from being converted to a MyString (whether implicit or explicit, since the results aren’t going to be intuitive). One way to partially do this is to add a MyString(char) constructor, and make it private:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">MyString</span>(<span class="type">char</span>) &#123;</span><br><span class="line">    <span class="comment">// Objects of type MyString(char) can&#x27;t be constructed from outside the class</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>However, this constructor can still be used from inside the class (private access only prevents non-members from calling this function).</p>
<p>A better way to resolve the issue is to use the <code>delete</code> keyword (introduced in C++11) to delete the function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myString</span>(<span class="type">char</span>) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">/* any use of this constructor is an error */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">mine</span><span class="params">(<span class="string">&#x27;x&#x27;</span>)</span></span>;  <span class="comment">// compile error, since MyString(char) is deleted</span></span><br></pre></td></tr></table></figure>

<p><strong>When a function has been deleted, any use of that function is considered a compile error.</strong></p>
<p>Note that the <code>copy constructor</code> and <code>overloaded operators</code> may also be deleted in order to prevent those functions from being used.</p>
<h3 id="Overload-the-assignment-operator"><a href="#Overload-the-assignment-operator" class="headerlink" title="Overload the assignment operator"></a>Overload the assignment operator</h3><p><strong>Assignment vs Copy constructor</strong></p>
<p>The purpose of the copy constructor and the assignment operator are almost equivalent – <strong>both copy one object to another</strong>. However, the copy constructor <code>initializes</code> new objects, whereas the assignment operator <code>replaces</code> the contents of existing objects.</p>
<p>The difference between the copy constructor and the assignment operator causes a lot of confusion for new programmers, but it’s really not all that difficult. Summarizing:</p>
<p><strong>It depends on whether the new object has been created or not.</strong></p>
<ul>
<li>If a new object has to be created before the copying can occur, the copy constructor is used (<strong>note:</strong> this includes passing or returning objects by value).</li>
<li>If a new object does not have to be created before the copying can occur, the assignment operator is used.</li>
</ul>
<p>Overloading the assignment operator (<code>operator=</code>) is fairly straightforward, with one specific caveat that we’ll get to. The assignment operator must be overloaded as a member function.</p>
<p><strong>If operator&#x3D; is not overloaded, copy constructor is always used.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Copy constructor</span></span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">const</span> Fraction &amp;copy)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(copy.m_numerator), <span class="built_in">m_denominator</span>(copy.m_denominator) &#123;</span><br><span class="line">      <span class="comment">// foo</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// Overloaded assignment</span></span><br><span class="line">  Fraction&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Fraction &amp;fraction) &#123;</span><br><span class="line">    <span class="comment">// do the copy</span></span><br><span class="line">    m_numerator = fraction.m_numerator;</span><br><span class="line">    m_denominator = fraction.m_denominator;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// support chained assignment</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">Fraction <span class="title">f1</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Fraction <span class="title">f2</span><span class="params">(<span class="number">7</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Fraction <span class="title">f3</span><span class="params">(<span class="number">9</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">f1 = f2 = f3; <span class="comment">// chained assignment: all uses assignment operator=</span></span><br><span class="line"><span class="comment">// only assign member variables</span></span><br></pre></td></tr></table></figure>

<p><strong>Issues due to self-assignment</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Fraction <span class="title">f1</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  f1 = f1; <span class="comment">// self assignment</span></span><br><span class="line">  <span class="comment">/* this will call f1.operator=(f1) */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This will call <code>f1.operator=(f1)</code>, and under the simplistic implementation above, all of the members will be assigned to themselves. In this particular example, the self-assignment causes each member to be assigned to itself, which has no overall impact, other than wasting time. In most cases, a self-assignment doesn’t need to do anything at all!</p>
<p><strong>Solution:</strong> detecting and handling self-assignment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A better implementation of operator=</span></span><br><span class="line">Fraction&amp; Fraction::<span class="keyword">operator</span>=(<span class="type">const</span> Fraction &amp;fraction) &#123;</span><br><span class="line">  <span class="comment">// self-assignment guard</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;fraction) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do the copy</span></span><br><span class="line">  m_numerator = fraction.m_numerator;</span><br><span class="line">  m_denominator = fraction.m_denominator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the existing object so we can chain this operator</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>By checking if our implicit object is the same as the one being passed in as a parameter, we can have our assignment operator just return immediately without doing any other work.</p>
<p><strong>Note that there is no need to check for self-assignment in a copy-constructor.</strong> This is because the copy constructor is only called when new objects are being constructed, and there is no way to assign a newly created object to itself in a way that calls to copy constructor.</p>
<p><strong>Default assignment operator</strong></p>
<p>Unlike other operators, the compiler will provide a <code>default public assignment operator</code> for your class if you do not provide one. This assignment operator <code>does memberwise assignment</code> (which is essentially the same as the memberwise initialization that default copy constructors do).</p>
<h3 id="Shallow-vs-deep-copying"><a href="#Shallow-vs-deep-copying" class="headerlink" title="Shallow vs. deep copying"></a>Shallow vs. deep copying</h3><p>Because C++ does not know much about your class, the default copy constructor and the default assignment operator it provides use a copying method known as a memberwise copy (also known as a <code>shallow copy</code>). This means that C++ copies each member of the class individually (<strong>using the assignment operator for overloaded operator&#x3D;, and direct initialization for the copy constructor</strong>). When classes are simple (e.g. do not contain any dynamically allocated memory), this works very well.</p>
<p>However, when designing classes that handle dynamically allocated memory, memberwise (shallow) copying can get us in a lot of trouble! <strong>This is because shallow copies of a pointer just copy the address of the pointer – it does not allocate any memory or copy the contents being pointed to.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> *m_data;</span><br><span class="line">  <span class="type">int</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we do not provide specific constructors, C++ will provide a default copy constructor and default assignment operator that do a shallow copy. The copy constructor will look something like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyString::<span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp;source)</span><br><span class="line">  : <span class="built_in">m_length</span>(source.m_length), <span class="built_in">m_data</span>(source.m_data) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line">~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that m_data is just a shallow pointer copy of <code>source.m_data</code>, meaning they now both point to the same thing.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">hello</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>;</span><br><span class="line">  &#123;</span><br><span class="line">    MyString copy = hello; <span class="comment">// use default copy constructor</span></span><br><span class="line">  &#125; <span class="comment">// copy is a local variable, so it gets destroyed here. The destructor deletes copy&#x27;s string, which leaves hello with a dangling pointer</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; hello.<span class="built_in">getString</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// this will have undefined behavior</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Deep copying</strong></p>
<p>One answer to this problem is to do a <code>deep copy</code> on any non-null pointers being copied. A deep copy allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source. This way, the copy and source are distinct and will not affect each other in any way. <strong>Doing deep copies requires that we write our own copy constructors and overloaded assignment operators.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; source) &#123;</span><br><span class="line">  <span class="comment">// because m_length is not a pointer, we can shallow copy it</span></span><br><span class="line">  m_length = source.m_length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// m_data is a pointer, so we need to deep copy it if it is non-null</span></span><br><span class="line">  <span class="keyword">if</span> (source.m_data) &#123;</span><br><span class="line">    <span class="comment">// allocate memory for our copy</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length];</span><br><span class="line">    <span class="comment">// do the copy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i) &#123;</span><br><span class="line">      m_data[i] = source.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m_data = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assignment operator</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>= (<span class="type">const</span> MyString &amp; source) &#123;</span><br><span class="line">  <span class="comment">// check for self-assignment - difference</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;source)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// explicitly delete the original value - difference</span></span><br><span class="line">  <span class="comment">// first we need to deallocate any value that this string is holding!</span></span><br><span class="line">  <span class="keyword">delete</span>[] m_data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// because m_length is not a pointer, we can shallow copy it</span></span><br><span class="line">  m_length = source.m_length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// m_data is a pointer, so we need to deep copy it if it is non-null</span></span><br><span class="line">  <span class="keyword">if</span> (source.m_data) &#123;</span><br><span class="line">    <span class="comment">// allocate memory for our copy</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the copy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; m_length; ++i) &#123;</span><br><span class="line">      m_data[i] = source.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m_data = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// - difference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>A better solution</strong></p>
<p><strong>Classes in the standard library that deal with dynamic memory, such as <code>std::string</code> and <code>std::vector</code>, handle all of their memory management, and have overloaded copy constructors and assignment operators that do proper deep copying.</strong> So instead of doing your own memory management, you can just initialize or assign them like normal fundamental variables! That makes these classes simpler to use, less error-prone, and you don’t have to spend time writing your own overloaded functions!</p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Junhao Wang
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'junhaow';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
