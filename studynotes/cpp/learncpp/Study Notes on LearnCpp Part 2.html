<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <meta name="description" content="Source: LearnCpp.com by Alex">
<meta property="og:type" content="website">
<meta property="og:title" content="Study Notes on LearnCpp (Part 2 - Strings, Pointers&#x2F;References, Functions)">
<meta property="og:url" content="https://junhaow.com/studynotes/cpp/learncpp/Study%20Notes%20on%20LearnCpp%20Part%202.html">
<meta property="og:site_name" content="forkercat.blog">
<meta property="og:description" content="Source: LearnCpp.com by Alex">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-02-14T05:03:11.000Z">
<meta property="article:modified_time" content="2024-02-13T00:53:54.184Z">
<meta property="article:author" content="Junhao Wang">
<meta property="article:tag" content="blog, junhaow, game">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/resources/favicon/me/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/resources/favicon/me/android-chrome-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/resources/favicon/me/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Study Notes on LearnCpp (Part 2 - Strings, Pointers/References, Functions)</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-146643833-1"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-146643833-1');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/resources/images/me_avatar.jpg" />
    
  
    <div id="title">
      <h1 class="p-name">forkercat.blog</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/archives/">Posts</a></li><!--
   --><!--
     --><li><a href="/studynotes/">Notes</a></li><!--
   --><!--
     --><li><a href="/lc/">Leetcode</a></li><!--
   --><!--
     --><li><a href="/games/">Games</a></li><!--
   --><!--
     --><li><a href="/links/">Links</a></li><!--
   --><!--
     --><li><a href="/about/">Me</a></li><!--
   -->
    </ul>
  </div>
</header>

        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <br>

<p>Source: <a target="_blank" rel="noopener" href="https://www.learncpp.com/">LearnCpp.com</a> by Alex</p>
<span id="more"></span>


<h2 id="Strings-Pointers-and-References"><a href="#Strings-Pointers-and-References" class="headerlink" title="Strings, Pointers, and References"></a>Strings, Pointers, and References</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>One important point to note is that C-style strings follow all the same rules as arrays. This means you can initialize the string upon creation, <strong>but you cannot assign values to it using the assignment operator after that!</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> myString[] = <span class="string">&quot;string&quot;</span>; <span class="comment">// ok</span></span><br><span class="line">myString = <span class="string">&quot;rope&quot;</span>; <span class="comment">// not ok!</span></span><br></pre></td></tr></table></figure>

<p>Bad practice:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">255</span>]; <span class="comment">// declare array large enough to hold 255 characters</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>;</span><br><span class="line">std::cin &gt;&gt; name;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>In the above program, we’ve allocated an array of 255 characters to <code>name</code>, guessing that the user will not enter these many characters. Although this is commonly seen in C&#x2F;C++ programming, it is poor programming practice, because nothing is stopping the user from entering more than 255 characters (either unintentionally, or maliciously).</p>
<p>The recommended way of reading strings using cin is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">255</span>]; <span class="comment">// declare array large enough to hold 255 characters</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>;</span><br><span class="line">std::cin.<span class="built_in">getline</span>(name, <span class="number">255</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>This call to <code>cin.getline()</code> will read up to 254 characters into name (leaving room for the null terminator <code>&#39;\0&#39;</code>!). <strong>Any excess characters will be discarded.</strong> In this way, we guarantee that we will not overflow the array!</p>
<p>Note the difference between <code>strlen()</code> and <code>std::size()</code>. strlen() prints the number of characters before the terminator, whereas std::size (or the sizeof() trick) returns the size of the entire array, regardless of what’s in it.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// for std::size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>] = <span class="string">&quot;Alex&quot;</span>; <span class="comment">// only use 5 characters (4 letters + null terminator)</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;My name is: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; <span class="built_in">strlen</span>(name) &lt;&lt; <span class="string">&quot; letters.\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; std::<span class="built_in">size</span>(name) &lt;&lt; <span class="string">&quot; characters in the array.\n&quot;</span>; <span class="comment">// use sizeof(name) / sizeof(name[0]) if not C++17 capable</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// My name is: Alex</span></span><br><span class="line">  <span class="comment">// Alex has 4 letters.</span></span><br><span class="line">  <span class="comment">// Alex has 20 characters in the array.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Don’t use C-style strings</strong></p>
<p>It is important to know about C-style strings because they are used in a lot of code. However, now that we’ve explained how they work, we’re going to recommend that you <strong>avoid them altogether whenever possible</strong>! Unless you have a specific, compelling reason to use C-style strings, use <code>std::string</code> (defined in the <code>&lt;string&gt;</code> header) instead. std::string is easier, safer, and more flexible. In the rare case that you do need to work with fixed buffer sizes and C-style strings (e.g. for memory-limited devices), we’d recommend using a well-tested 3rd party string library designed for the purpose instead.</p>
<h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><p><strong>What good are pointers?</strong></p>
<p>At this point, pointers may seem a little silly, academic, or obtuse. Why use a pointer if we can just use the original variable?</p>
<p>It turns out that pointers are useful in many different cases:</p>
<ol>
<li>Arrays are implemented using pointers. Pointers can be used to iterate through an array (as an alternative to array indices).</li>
<li>They are the only way you can dynamically allocate memory in C++. <strong>This is by far the most common use case for pointers.</strong></li>
<li>They can be used to pass a large amount of data to a function in a way that doesn’t involve copying the data, which is inefficient.</li>
<li>They can be used to pass a function as a parameter to another function.</li>
<li>They can be used to achieve <code>polymorphism</code> when dealing with inheritance.</li>
<li>They can be used to have one struct&#x2F;class point at another struct&#x2F;class, to form a chain. This is useful in some more advanced data structures, such as linked lists and trees.</li>
</ol>
<p>So there are actually a surprising number of uses for pointers. But don’t worry if you don’t understand what most of these are yet. Now that you understand what pointers are at a basic level, we can start taking an in-depth look at the various cases in which they’re useful, which we’ll do in subsequent lessons.</p>
<p>Pointers convert to boolean false if they are null, and boolean true if they are non-null. Therefore, we can use a conditional to test whether a pointer is null or not:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> *ptr = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// pointers convert to boolean false if they are null, and boolean true if they are non-null</span></span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ptr is pointing to a double value.&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ptr is a null pointer.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Best practice: Initialize your pointers to a null value if you’re not giving them another value.</p>
<p>In C++, there is a special preprocessor macro called <code>NULL</code> (defined in the <cstddef> header). This macro was inherited from C, where it is commonly used to indicate a null pointer.</p>
<p>The value of NULL is implementation defined, but is usually defined as the integer constant 0. <strong>Note:</strong> as of C++11, NULL can be defined as <code>nullptr</code> instead (which we’ll discuss in a bit).</p>
<p><strong>Best Practice:</strong> Because NULL is a preprocessor macro with an implementation defined value, avoid using NULL (sure?).</p>
<p>Note that the value of 0 isn’t a pointer type, so assigning 0 (or NULL, pre-C++11) to a pointer to denote that the pointer is a null pointer is a little inconsistent. In rare cases, when used as a literal argument, it can even cause problems because the compiler can’t tell whether we mean a null pointer or the integer 0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span> <span class="comment">// for NULL</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;print(int): &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;print(int*): null\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;print(int*): &quot;</span> &lt;&lt; *x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *x &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="built_in">print</span>(x); <span class="comment">// calls print(int*) because x has type int*</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>); <span class="comment">// calls print(int) because 0 is an integer literal</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="literal">NULL</span>); <span class="comment">// likely calls print(int), although we probably wanted print(int*)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To address the above issues, C++11 introduces a new keyword called <code>nullptr</code>. nullptr is both a keyword and an <code>rvalue</code> constant, much like the boolean keywords true and false are.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>C++ will <strong>implicitly convert</strong> <code>nullptr</code> to any pointer type. So in the above example, nullptr is implicitly converted to an integer pointer, and then the value of nullptr assigned to ptr. This has the effect of making integer pointer ptr a null pointer.</p>
<p>C++11 also introduces a new type called <code>std::nullptr_t</code> (in header <cstddef>). std::nullptr_t can only hold one value: nullptr! While this may seem kind of silly, it’s useful in one situation. If we want to write a function that accepts only a nullptr argument, what type do we make the parameter? The answer is std::nullptr_t.</p>
<p>In all but two cases (which we’ll cover below), when a fixed array is used in an expression, the fixed array will <code>decay</code> (be implicitly converted) into a pointer that points to the first element of the array. (But a pointer is still not an array though)</p>
<p><strong>Arrays in structs and classes don’t decay</strong></p>
<p>Finally, it is worth noting that arrays that are part of structs or classes do not decay when the whole struct or class is passed to a function. This yields a useful way to prevent decay if desired, and will be valuable later when we write classes that utilize arrays.</p>
<p>For optimization purposes, multiple string literals may be consolidated into a single value. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *name1&#123; <span class="string">&quot;Alex&quot;</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name2&#123; <span class="string">&quot;Alex&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>These are two different string literals with the same value. The compiler may opt to combine these into a single shared string literal, with both <code>name1</code> and <code>name2</code> pointed at the same address. Thus, if name1 was not const, making a change to name1 could also impact name2 (which might not be expected). <strong>Actually, if there is no const modifier, name1 can’t be changed still.</strong></p>
<p><strong>Rule:</strong> Feel free to use C-style string symbolic constants if you need read-only strings in your program, but always make them <code>const</code>!</p>
<p>By outputting <code>char *</code> or <code>const char *</code>, std::cout will assume you are going to print a string instead of an address (int *). While this is great 99% of the time, it can lead to unexpected results. Consider the following case:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> in = <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; &amp;in &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 0x7ffee1280558</span></span><br><span class="line">std::cout &lt;&lt; &amp;ch &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// Q</span></span><br></pre></td></tr></table></figure>

<p>Why did it do this? Well, it assumed <code>&amp;ch</code> (which has type <code>char *</code>) was a string. So it printed the ‘Q’, and then kept going. Next in memory was a bunch of garbage. Eventually, it ran into some memory holding a 0 value, which it interpreted as a null terminator, so it stopped. What you see may be different depending on what’s in memory after variable c.</p>
<p>C++ supports three basic types of memory allocation, of which you’ve already seen two.</p>
<ul>
<li><code>Static memory allocation</code> happens for static and global variables. Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.</li>
<li><code>Automatic memory allocation</code> happens for function parameters and local variables. Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.</li>
<li><code>Dynamic memory allocation</code> is the topic of this article.</li>
</ul>
<p>To allocate a single variable dynamically, we use the scalar (non-array) form of the new operator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *ptr1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); <span class="comment">// direct initialization</span></span><br><span class="line"><span class="type">int</span> *ptr2 = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">5</span> &#125;;  <span class="comment">// uniform initialization</span></span><br></pre></td></tr></table></figure>

<p>If it wasn’t before, it should now be clear at least one case in which pointers are useful. Without a pointer to hold the address of the memory that was just allocated, we’d have no way to access the memory that was just allocated for us!</p>
<p>When we are done with a dynamically allocated variable, we need to explicitly tell C++ to free the memory for reuse. For single variables, this is done via the scalar (non-array) form of the delete operator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume ptr has previously been allocated with operator new</span></span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// return the memory pointed to by ptr to the operating system</span></span><br><span class="line">ptr = <span class="literal">nullptr</span>; <span class="comment">// set ptr to be a null pointer (use nullptr instead of 0 in C++11)</span></span><br></pre></td></tr></table></figure>

<p>The delete operator does not actually delete anything. It simply returns the memory being pointed to back to the <code>operating system</code>. The operating system is then free to reassign that memory to another application (or to this application again later).</p>
<p><strong>Note:</strong> deleting a pointer that is not pointing to dynamically allocated memory may cause bad things to happen. A pointer that is pointing to deallocated memory is called a <code>dangling pointer</code>. Dereferencing or deleting a dangling pointer will lead to <code>undefined behavior</code>.</p>
<p><strong>Rule:</strong> Set deleted pointers to 0 (or nullptr in C++11) <strong>unless they are going out of scope immediately afterward</strong>.</p>
<p><strong>Operator new can fail</strong></p>
<p>When requesting memory from the operating system, in rare circumstances, the operating system may not have any memory to grant the request with.</p>
<p>By default, if new fails, a <code>bad_alloc</code> exception is thrown. If this exception isn’t properly handled (and it won’t be, since we haven’t covered exceptions or exception handling yet), the program will simply terminate (crash) with an unhandled exception error.</p>
<p>In many cases, having new throw an exception (or having your program crash) is undesirable, so there’s an alternate form of new that can be used instead to tell new to return a null pointer if memory can’t be allocated. This is done by adding the constant std::nothrow between the new keyword and the allocation type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *value = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>; <span class="comment">// value will be set to a null pointer if the integer allocation fails</span></span><br></pre></td></tr></table></figure>

<p>Note that if you then attempt to dereference this memory, undefined behavior will result (most likely, your program will crash). Consequently, the best practice is to check all memory requests to ensure they actually succeeded before using the allocated memory.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *value = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (!value) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate memory&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Deleting a null pointer has no effect. Thus, there is no need for the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>

<p><strong>Memory leaks</strong></p>
<p>Memory leaks happen when your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. When this happens, your program can’t delete the dynamically allocated memory, because it no longer knows where it is. The operating system also can’t use this memory, because that memory is considered to be still in use by your program.</p>
<p>Dynamically allocated memory effectively has no scope. That is, it stays allocated until it is explicitly deallocated or until the program ends (and the operating system cleans it up, assuming your operating system does that). However, the pointers used to hold dynamically allocated memory addresses follow the scoping rules of normal variables. This mismatch can create interesting problems.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// another example</span></span><br><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// allocate memory</span></span><br><span class="line">ptr = &amp;value; <span class="comment">// old address lost, memory leak results</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// another example</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// old address lost, memory leak results</span></span><br></pre></td></tr></table></figure>

<p><strong>Dynamically allocating arrays</strong></p>
<p>In addition to dynamically allocating single values, we can also dynamically allocate arrays of variables. Unlike a fixed array, where the array size must be fixed at compile time, dynamically allocating an array allows us to choose an array length at runtime.</p>
<p>To allocate an array dynamically, we use the array form of new and delete (often called <code>new[]</code> and <code>delete[]</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[length];</span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"><span class="comment">// Essentially, the new[] operator is called, even though the [] isn&#x27;t placed next to the new keyword.</span></span><br></pre></td></tr></table></figure>

<p>One often asked question of what array <code>delete[]</code> is, “How does array delete know how much memory to delete?” The answer is that array <code>new[]</code> keeps track of how much memory was allocated to a variable, so that array <code>delete[]</code> can delete the proper amount. Unfortunately, this size&#x2F;length isn’t accessible to the programmer (which means we need to keep track of the length if we want to access the size of a dynamically allocating array).</p>
<p><strong>Dynamic arrays are almost identical to fixed arrays, but remember to delete[] it.</strong></p>
<p>If you want to initialize a dynamically allocated array to 0, the syntax is quite simple:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[length](); <span class="comment">// initialized to 0</span></span><br></pre></td></tr></table></figure>

<p>Prior to C++11, there was no easy way to initialize a dynamic array to a non-zero value (initializer lists only worked for fixed arrays). This means you had to loop through the array and assign element values explicitly.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">array[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">array[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">array[<span class="number">4</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>However, starting with C++11, it’s now possible to initialize dynamic arrays using <code>initializer lists</code>!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fixedArray[<span class="number">5</span>] = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// initialize a fixed array in C++03</span></span><br><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>] &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// initialize a dynamic array in C++11</span></span><br><span class="line"><span class="type">int</span> fixedArray[<span class="number">5</span>] &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// initialize a fixed array in C++11</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> fixedArray[<span class="number">14</span>] &#123; <span class="string">&quot;Hello, world!&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// initialize a fixed array in C++11</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *array = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">14</span>] &#123; <span class="string">&quot;Hello, world!&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// doesn&#x27;t work in C++11</span></span><br><span class="line"><span class="comment">// If you have a need to do this, dynamically allocate a std::string instead (or allocate your char array and then strcpy the string in).</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *dynamicArray1 = <span class="keyword">new</span> <span class="type">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// int[3] is required</span></span><br><span class="line"><span class="comment">// not okay: implicit size for dynamic arrays!</span></span><br></pre></td></tr></table></figure>

<p><strong>Resizing arrays (not okay)</strong></p>
<p>Dynamically allocating an array allows you to set the array length at the time of allocation. However, C++ does not provide a built-in way to resize an array that has already been allocated. It is possible to work around this limitation by dynamically allocating a new array, copying the elements over, and deleting the old array. However, this is error prone, especially when the element type is a <code>class</code> (which have special rules governing how they are created).</p>
<p>Consequently, we recommend avoiding doing this yourself.</p>
<p>Fortunately, if you need this capability, C++ provides a resizable array as part of the standard library called std::vector. We’ll introduce std::vector shortly.</p>
<p><strong>Pointers and const</strong></p>
<p>Pointing to const value:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;value; <span class="comment">// ptr points to a &quot;const int&quot;</span></span><br><span class="line">value = <span class="number">6</span>; <span class="comment">// the value is non-const when accessed through a non-const identifier</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;value; <span class="comment">// ptr points to a &quot;const int&quot;</span></span><br><span class="line">*ptr = <span class="number">6</span>; <span class="comment">// error - ptr treats its value as const, so changing the value through ptr is not legal</span></span><br></pre></td></tr></table></figure>

<p>Const pointers:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;value;</span><br></pre></td></tr></table></figure>

<p>Const pointer to a const value:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ptr = &amp;value;</span><br></pre></td></tr></table></figure>


<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><strong>l-values and r-values</strong></p>
<p>In C++, variables are a type of l-value (pronounced ell-value). An l-value is a value that <code>has an address</code> (in memory). Since all variables have addresses, all variables are l-values. The name l-value came about <code>because l-values are the only values that can be on the left side of an assignment statement</code>. When we do an assignment, the left hand side of the assignment operator must be an l-value. Consequently, a statement like 5 &#x3D; 6; will cause a compile error, because 5 is not an l-value. The value of 5 has no memory, and thus nothing can be assigned to it. 5 means 5, and its value cannot be reassigned. When an l-value has a value assigned to it, the current value at that memory address is overwritten.</p>
<p>The opposite of l-values are r-values (pronounced arr-values). <code>An r-value refers to any value that can be assigned to an l-value.</code> r-values are always evaluated to produce a single value. Examples of r-values are literals (such as 5, which evaluates to 5), variables (such as x, which evaluates to whatever value was last assigned to it), or expressions (such as 2 + x, which evaluates to the value of x plus 2).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">7</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>In this statement, the variable x is being used in two different contexts. On the left side of the assignment operator, “x” is being used as an l-value (variable with an address). On the right side of the assignment operator, x is being used as an r-value, and will be evaluated to produce a value (in this case, 7). When C++ evaluates the above statement, it evaluates as: <code>x = 7 + 1;</code></p>
<p>The key <strong>takeaway</strong> is that on the left side of the assignment, you must have something that represents a <code>memory address</code> (such as a variable). Everything on the right side of the assignment will be evaluated to produce a value.</p>
<p><strong>Note:</strong> const variables are considered non-modifiable l-values.</p>
<p><strong>Three basic variable types:</strong></p>
<ul>
<li>Normal variables</li>
<li>Pointers</li>
<li>Reference variables</li>
</ul>
<p>A reference is a type of C++ variable that acts as an <code>alias</code> to another object or value.</p>
<p>C++ supports three kinds of references:</p>
<ul>
<li><p>References to <code>non-const</code> values (typically just called “references”, or “non-const references”), which we’ll discuss in this lesson.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">5</span>; <span class="comment">// normal integer</span></span><br><span class="line"><span class="type">int</span> &amp;ref = value; <span class="comment">// reference to variable value</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// normal integer</span></span><br><span class="line"><span class="type">int</span> &amp;y = x; <span class="comment">// y is a reference to x</span></span><br><span class="line"><span class="type">int</span> &amp;z = y; <span class="comment">// z is also a reference to x</span></span><br></pre></td></tr></table></figure>
<p>Using the address-of &amp; operator on a reference returns <strong>the address of the value being referenced</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &amp;value; <span class="comment">// prints 0012FF7C</span></span><br><span class="line">cout &lt;&lt; &amp;ref;   <span class="comment">// prints 0012FF7C</span></span><br></pre></td></tr></table></figure></li>
<li><p>References to <code>const</code> values (often called “const references”), which we’ll discuss in the next lesson.</p>
</li>
<li><p>C++11 added r-value references, which we cover in detail in the chapter on move semantics.</p>
</li>
</ul>
<p><strong>References must be initialized.</strong></p>
<p><strong>References to non-const values can only be initialized with non-const l-values. They cannot be initialized with const l-values or r-values.</strong></p>
<p><strong>References cannot be reassigned</strong></p>
<p>Once initialized, a reference <strong>cannot be changed</strong> to reference another variable. Consider the following snippet:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value1 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> value2 = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> &amp;ref = value1; <span class="comment">// okay, ref is now an alias for value1</span></span><br><span class="line">ref = value2; <span class="comment">// assigns 6 (the value of value2) to value1 -- does NOT change the reference!</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ref &lt;&lt; std::endl;   <span class="comment">// 6</span></span><br><span class="line">std::cout &lt;&lt; val1 &lt;&lt; std::endl;  <span class="comment">// 6</span></span><br><span class="line">std::cout &lt;&lt; val2 &lt;&lt; std::endl;  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>Note that the second statement may not do what you might expect! Instead of reassigning ref to reference variable value2, <code>it instead assigns the value from value2 to value1</code> (which ref is a reference of).</p>
<p><strong>References as function parameters</strong></p>
<p>References are most often used as function parameters. In this context, the reference parameter acts as an alias for the argument, <strong>and no copy of the argument is made into the parameter.</strong> This can lead to better performance if the argument is large or expensive to copy.</p>
<p>In lesson 6.8 – Pointers and arrays we talked about how passing a pointer argument to a function allows the function to dereference the pointer to modify the argument’s value directly.</p>
<p>References work similarly in this regard. Because the reference parameter acts as an alias for the argument, a function that uses a reference parameter is able to modify the argument passed in:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ref is a reference to the argument passed in, not a copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeN</span><span class="params">(<span class="type">int</span> &amp;ref)</span> </span>&#123;</span><br><span class="line">	ref = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="built_in">changeN</span>(n); </span><br><span class="line">  <span class="comment">// note that this argument does not need to be a reference</span></span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Best practice:</strong> Pass arguments by <code>non-const reference</code> when the argument needs to be modified by the function.</p>
<p>The primary downside of using <code>non-const references</code> as function parameters is that the argument must be a <code>non-const l-value</code>. This can be restrictive.</p>
<p><strong>Using references to pass C-style arrays to functions</strong></p>
<p>One of the most annoying issues with C-style arrays is that in most cases they decay to pointers when evaluated. However, <strong>if a C-style array is passed by reference, this decaying does not happen.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Note: You need to specify the array size in the function declaration</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 4 * 8 - 4 = 28</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// we can now do this since the array won&#x27;t decay</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">20</span>, <span class="number">14</span>, <span class="number">80</span> &#125;;</span><br><span class="line">  <span class="built_in">printElements</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>References as shortcuts</strong></p>
<p>A secondary (much less used) use of references is to <strong>provide easier access to nested data</strong>. Consider the following structs:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">  <span class="type">int</span> value1;</span><br><span class="line">  <span class="type">float</span> value2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">  Something something;</span><br><span class="line">  <span class="type">int</span> otherValue;</span><br><span class="line">&#125;;</span><br><span class="line">Other other;</span><br><span class="line"><span class="type">int</span> &amp;ref = other.something.value1;</span><br><span class="line"><span class="comment">// instead of using: </span></span><br><span class="line">other.something.value1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// we can use</span></span><br><span class="line">ref = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>References vs pointers</strong></p>
<p>References and pointers have an interesting relationship – a reference acts like a pointer that is implicitly dereferenced when accessed (<strong>references are usually implemented internally by the compiler using pointers</strong>). Thus given the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;value;</span><br><span class="line"><span class="type">int</span> &amp;ref = value;</span><br></pre></td></tr></table></figure>

<p><code>*ptr</code> and <code>ref</code> evaluate identically. As a result, the following two statements produce the same effect:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">5</span>;</span><br><span class="line">ref = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>Because references <code>must be initialized</code> to valid objects (cannot be null) and cannot be changed once set, references are generally much <strong>safer</strong> to use than pointers (since there’s no risk of dereferencing a null pointer). <code>However, they are also a bit more limited in functionality accordingly.</code></p>
<p><strong>Note:</strong> If a given task can be solved with either a reference or a pointer, the reference should generally be preferred. Pointers should only be used in situations where references are not sufficient (such as dynamically allocating memory).</p>
<p><strong>References to r-values extend the lifetime of the referenced value</strong></p>
<p>Normally r-values have expression scope, meaning the values are destroyed at the end of the expression in which they are created.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// 2 + 3 evaluates to r-value 5, which is destroyed at the end of this statement</span></span><br></pre></td></tr></table></figure>

<p>However, when a reference to a const value is initialized with an r-value, the lifetime of the r-value is extended to match the lifetime of the reference.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">somefcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;ref = <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">somefcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> &amp;ref = <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// normally the result of 2+3 has expression scope and is destroyed at the end of this statement</span></span><br><span class="line">  <span class="comment">// but because the result is now bound to a reference to a const value...</span></span><br><span class="line">  std::cout &lt;&lt; ref; <span class="comment">// we can use it here</span></span><br><span class="line">&#125; <span class="comment">// and the lifetime of the r-value is extended to here, when the const reference dies</span></span><br></pre></td></tr></table></figure>

<p><strong>Const references as function parameters</strong></p>
<p>References used as function parameters can also be const. This allows us to access the argument without making a copy of it, while guaranteeing that the function will not change the value being referenced.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref is a const reference to the argument passed in, not a copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeN</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;ref)</span> </span>&#123;</span><br><span class="line">	ref = <span class="number">6</span>; <span class="comment">// not allowed, ref is const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>References to const values are particularly useful as function parameters because of their <code>versatility</code>. <strong>A const reference parameter allows you to pass in a non-const l-value argument, a const l-value argument, a literal, or the result of an expression</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printIt</span>(a); <span class="comment">// non-const l-value</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printIt</span>(b); <span class="comment">// const l-value</span></span><br></pre></td></tr></table></figure>

<p>To avoid making unnecessary and potentially expensive copies, variables that are not <code>pointers</code> or <code>fundamental data types</code> (int, double, etc…) should be generally passed by (const) reference. </p>
<p>Fundamental data types should be passed by value, unless the function needs to change them.</p>
<p><strong>Rule:</strong> Pass non-pointer, non-fundamental data type variables (such as structs) by (const) reference.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// In C++, we don&#x27;t need &quot;struct&quot; word.</span></span><br><span class="line">Person *ptr = &amp;person;</span><br><span class="line">(*ptr).age  = <span class="number">5</span>;</span><br><span class="line">ptr-&gt;age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Rule:</strong> When using a pointer to access the value of a member, use operator <code>-&gt;</code> instead of operator <code>.</code>.</p>
<h3 id="For-each-loops"><a href="#For-each-loops" class="headerlink" title="For-each loops"></a>For-each loops</h3><p>C++11 introduces a new type of loop called a for-each loop (also called a range-based for loop) that provides a simpler and safer method for cases where we want to iterate through every element in an array (or other list-type structure).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (element_declaration : array)</span><br><span class="line">  statement;</span><br></pre></td></tr></table></figure>

<p>Because element_declaration should have the same type as the array elements, this is an ideal case in which to use the <code>auto</code> keyword, and let C++ deduce the type of the array elements for us.</p>
<p>Copying array elements can be expensive, and most of the time we really just want to <strong>refer to the original element</strong>. Fortunately, we can use references for this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">5</span>] = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : array)</span><br><span class="line">    std::cout &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>And, of course, it’s a good idea to make your element const if you’re intending to use it in a read-only fashion.</p>
<p><strong>Rule:</strong> In for-each loops element declarations, if your elements are non-fundamental types, use references or const references for performance reasons.</p>
<p><strong>For-each doesn’t work with pointers to an array</strong></p>
<p>In order to iterate through the array, for-each needs to know how big the array is, which means knowing the array size. Because arrays that have decayed into a pointer do not know their size, for-each loops will not work with them!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumArray</span><span class="params">(<span class="type">int</span> array[])</span> </span>&#123; <span class="comment">// array is a pointer</span></span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;number : array) <span class="comment">// compile error, the size of array isn&#x27;t known</span></span><br><span class="line">    sum += number;</span><br><span class="line">  <span class="keyword">return</span> sum;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Similarly, <strong>dynamic arrays won’t work with for-each loops for the same reason</strong>.</p>
<p><strong>Multidimensional arrays</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>][<span class="number">5</span>];  <span class="comment">// won&#x27;t work</span></span><br><span class="line"><span class="built_in">int</span> (*array)[<span class="number">5</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>][<span class="number">5</span>];  <span class="comment">// ok 行指针</span></span><br><span class="line"><span class="keyword">auto</span> array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>][<span class="number">5</span>];  <span class="comment">// In C++11, you can use.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> Unfortunately, this relatively simple solution doesn’t work if the right-most array dimension isn’t a compile-time constant. </p>
<h3 id="Intro-to-std-array"><a href="#Intro-to-std-array" class="headerlink" title="Intro to std::array"></a>Intro to std::array</h3><p>Introduced in C++11, std::array provides fixed array functionality that won’t decay when passed into a function. std::array is defined in the array header, inside the std namespace.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; myArray1;</span><br><span class="line">std::array&lt;<span class="type">int</span>, &gt; myArray2 = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;; <span class="comment">// error, cannot omit</span></span><br></pre></td></tr></table></figure>

<p>Just like the native implementation of fixed arrays, the length of a std::array must be set at compile time.</p>
<p>std::array supports a second form of array element access (the at() function) that does bounds checking:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; myArray &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">myArray.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">6</span>;</span><br><span class="line">myArray.<span class="built_in">at</span>(<span class="number">9</span>) = <span class="number">10</span>; <span class="comment">// array element 9 is invalid, will throw error</span></span><br></pre></td></tr></table></figure>

<p>In the above example, the call to array.at(1) checks to ensure array element 1 is valid, and because it is, it returns a reference to array element 1. We then assign the value of 6 to this. However, the call to array.at(9) fails because array element 9 is out of bounds for the array. Instead of returning a reference, the at() function throws an error that terminates the program (note: It’s actually throwing an exception of type std::out_of_range – we cover exceptions in chapter 15). <strong>Because it does bounds checking, at() is slower (but safer) than operator[].</strong></p>
<p>std::array will clean up after itself when it goes out of scope, so there’s no need to do any kind of cleanup.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLength</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">double</span>, <span class="number">5</span>&gt; &amp;myArray)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;length: &quot;</span> &lt;&lt; myArray.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="type">double</span>, 5&gt; myArray &#123; <span class="number">9.0</span>, <span class="number">7.2</span>, <span class="number">5.4</span>, <span class="number">3.6</span>, <span class="number">1.8</span> &#125;;</span><br><span class="line">  <span class="built_in">printLength</span>(myArray);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Also note that we passed std::array by (const) reference. This is to <code>prevent the compiler from making a copy</code> of the std::array when the std::array was passed to the function (for performance reasons).</p>
<p><strong>Rule:</strong> Always pass std::array by reference or const reference</p>
<p><strong>Manually indexing std::array via size_type</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; myArray &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myArray.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  std::cout &lt;&lt; myArray[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>The answer is that there’s a likely signed&#x2F;unsigned mismatch in this code! Due to a curious decision, the size() function and array index parameter to operator[] use a type called <code>size_type</code>, which is defined by the C++ standard as an unsigned integral type. Our loop counter&#x2F;index (variable i) is a signed int. Therefore both the comparison i &lt; myArray.size() and the array index myArray[i] have type mismatches.</p>
<p>Interestingly enough, size_type isn’t a global type (like int or std::size_t). Rather, it’s defined inside the definition of std::array (C++ allows nested types). This means when we want to use size_type, we have to prefix it with the full array type (think of std::array acting as a namespace in this regard). In our above example, the fully-prefixed type of “size_type” is std::array&lt;int, 5&gt;::size_type!</p>
<p>Therefore, the correct way to write the above code is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;::size_type i = <span class="number">0</span>; i &lt; myArray.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">index_t</span> = std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;::size_type;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">index_t</span> i = <span class="number">0</span>; i &lt; myArray.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p><strong>In all common implementations of std::array, size_type is a typedef for std::size_t</strong>. So it’s somewhat common to see developers use <code>size_t</code> instead. <code>While not technically correct</code>, in almost all implementations, this will work:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myArray.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>A better solution is to <code>avoid manual indexing of std::array</code> in the first place. Instead, use range-based for loops (or iterators) if possible.</p>
<h3 id="Intro-to-std-vector"><a href="#Intro-to-std-vector" class="headerlink" title="Intro to std::vector"></a>Intro to std::vector</h3><p>Introduced in C++03, std::vector provides dynamic array functionality that handles its own memory management. This means you can create arrays that have their length set at runtime, without having to explicitly allocate and deallocate memory using new and delete. std::vector lives in the <code>&lt;vector&gt;</code> header.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// no need to specify length at initialization</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; array; </span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; array2 = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;; <span class="comment">// use &quot;initializer list&quot; to initialize array</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; array3 &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;; <span class="comment">// use &quot;uniform initialization&quot; to initialize array (C++11 onward)</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">6</span>] = <span class="number">2</span>; <span class="comment">// no bounds checking</span></span><br><span class="line">array.<span class="built_in">at</span>(<span class="number">7</span>) = <span class="number">3</span>; <span class="comment">// does bounds checking</span></span><br><span class="line">array = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;   <span class="comment">// In C++11</span></span><br></pre></td></tr></table></figure>

<p>Just like with std::array, size() returns a value of nested type size_type (full type in the above example would be std::vector::size_type), which is an unsigned integer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resize an array</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; array &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">array.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">// set size to 5</span></span><br></pre></td></tr></table></figure>

<p>There are two things to note here. First, when we resized the array, the existing element values were preserved! Second, new elements are initialized to the default value for the type (which is 0 for integers).</p>
<p>Resizing a vector is <code>computationally expensive</code>, so you should strive to minimize the number of times you do so.</p>
<p><strong>Compacting bools</strong></p>
<p>std::vector has another cool trick up its sleeves. There is a special implementation for std::vector of type bool that will <code>compact 8 booleans into a byte</code>! This happens behind the scenes, and doesn’t change how you use the std::vector.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt; array &#123; <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The length is: &quot;</span> &lt;&lt; array.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;element: array)</span><br><span class="line">  std::cout &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Parameters-vs-Arguments"><a href="#Parameters-vs-Arguments" class="headerlink" title="Parameters vs Arguments"></a>Parameters vs Arguments</h3><p>In common usage, the terms <code>parameter</code> and <code>argument</code> are often interchanged. However, for the purposes of further discussion, we will make a distinction between the two:</p>
<p>A <code>parameter</code> (sometimes called a <code>formal parameter</code>) is a variable declared in the function declaration: <code>void foo(int x)</code>.</p>
<p>An <code>argument</code> (sometimes called an <code>actual parameter</code>) is the value that is passed to the function by the caller: <code>foo(5)</code>.</p>
<p><strong>Rule:</strong> When passing an argument by reference, always use a const reference unless you need to change the value of the argument</p>
<h3 id="References-to-pointers"><a href="#References-to-pointers" class="headerlink" title="References to pointers"></a>References to pointers</h3><p>It’s possible to pass a pointer by reference, and have the function change the address of the pointer entirely:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> *&amp;ptr)</span> </span>&#123; <span class="comment">// pass pointer by reference</span></span><br><span class="line">  <span class="comment">// (int *) &amp;ptr</span></span><br><span class="line">  ptr = <span class="literal">nullptr</span>; <span class="comment">// this changes the actual ptr argument passed in, not a copy</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> *ptr = &amp;x;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ptr is: &quot;</span> &lt;&lt; (ptr ? <span class="string">&quot;non-null&quot;</span> : <span class="string">&quot;null&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints non-null</span></span><br><span class="line">  <span class="built_in">foo</span>(ptr);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ptr is: &quot;</span> &lt;&lt; (ptr ? <span class="string">&quot;non-null&quot;</span> : <span class="string">&quot;null&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When to use pass by reference:</p>
<ul>
<li>When passing structs or classes (use const if read-only).</li>
<li>When you need the function to modify an argument.</li>
<li>When you need access to the type information of a fixed array.</li>
</ul>
<p>When not to use pass by reference:</p>
<ul>
<li>When passing fundamental types that don’t need to be modified (use pass by value).</li>
</ul>
<p>When to use pass by address&#x2F;pointer (actually it is passed by value):</p>
<ul>
<li>When passing built-in arrays (if you’re okay with the fact that they’ll decay into a pointer).</li>
<li>When passing a pointer and nullptr is a valid argument logically.</li>
</ul>
<p><strong>Note:</strong> Return by address is often used to return dynamically allocated memory to the caller.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">allocateArray</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *array = <span class="built_in">allocateArray</span>(<span class="number">25</span>);</span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br></pre></td></tr></table></figure>

<p>Just like return by address, you should not return local variables by reference. Consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">doubleValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> value = x * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> value; <span class="comment">// return a reference to value here</span></span><br><span class="line">&#125; <span class="comment">// value is destroyed here</span></span><br></pre></td></tr></table></figure>

<p><strong>Returning by reference is typically used to return arguments passed by reference to the function back to the caller.</strong> In the following example, we return (by reference) an element of an array that was passed to our function by reference:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a reference to the index element of array</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(std::array&lt;<span class="type">int</span>, <span class="number">25</span>&gt; &amp;array, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// we know that array[index] will not be destroyed when we return to the caller (since the caller passed in the array in the first place!)</span></span><br><span class="line">  <span class="keyword">return</span> array[index]; <span class="comment">// so it&#x27;s okay to return it by reference</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="type">int</span>, 25&gt; array;</span><br><span class="line">  <span class="comment">// Set the element of array with index 10 to the value 5</span></span><br><span class="line">  <span class="built_in">getElement</span>(array, <span class="number">10</span>) = <span class="number">5</span>;</span><br><span class="line">  std::cout &lt;&lt; array[<span class="number">10</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lifetime extension doesn’t save dangling references</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">returnByReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> &amp;ref = <span class="built_in">returnByReference</span>(); <span class="comment">// runtime error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above program, <code>returnByReference()</code> is returning a const reference to a value that will go out of scope when the function ends. This is normally a <code>no-no</code>, as it will result in a dangling reference. However, we also know that <strong>assigning a value to a const reference can extend the lifetime of that value</strong>. So which takes precedence here? Does 5 go out of scope first, or does <code>ref</code> extend the lifetime of 5?</p>
<p>The answer is that 5 goes out of scope first, then <code>ref</code> extends the lifetime of the dangling reference. <strong>Lifetime extension only works when the object going out of scope is going out of scope in the same block (e.g. because it has expression scope). It does not work across function boundaries.</strong></p>
<h3 id="Use-tuple-to-return-multiple-values"><a href="#Use-tuple-to-return-multiple-values" class="headerlink" title="Use tuple to return multiple values"></a>Use tuple to return multiple values</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">returnTuple</span><span class="params">()</span> </span>&#123; <span class="comment">// return a tuple that contains an int and a double</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">5</span>, <span class="number">6.7</span>); </span><br><span class="line">  <span class="comment">// use std::make_tuple() as shortcut to make a tuple to return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">double</span> b;</span><br><span class="line">  std::<span class="built_in">tie</span>(a, b) = <span class="built_in">returnTuple</span>(); <span class="comment">// put elements of tuple in variables a and b</span></span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As of C++17, a structured binding declaration can be used to simplify splitting multiple returned values into separate variables:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> [a, b] = <span class="built_in">returnTuple</span>(); <span class="comment">// used structured binding declaration to put results of tuple in variables a and b</span></span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using a struct is a better option than a tuple if you’re using the struct in multiple places. However, for cases where you’re just packaging up these values to return and there would be no reuse from defining a new struct, a tuple is a bit cleaner since it doesn’t introduce a new user-defined data type.</p>
<h3 id="Inline-functions"><a href="#Inline-functions" class="headerlink" title="Inline functions"></a>Inline functions</h3><p><strong>Rule:</strong> Be aware of inline functions. Modern compilers should implicitly add inline functions for you as appropriate, so there isn’t a need to use the keyword.</p>
<p><strong>Inline functions are exempt from the one-definition per program rule</strong></p>
<p>In previous chapters, we’ve noted that you should not implement functions (with external linkage) in header files, because when those headers are included into multiple .cpp files, the function definition will be copied into multiple .cpp files. These files will then be compiled, and the linker will throw an error because it will note that you’ve defined the same function more than once.</p>
<p><strong>However, inline functions are exempt from the rule that you can only have one definition per program, because of the fact that inline functions do not actually result in a real function being compiled</strong> – therefore, there’s no conflict when the linker goes to link multiple files together.</p>
<p>This may seem like an uninteresting bit of trivia at this point, but next chapter we’ll introduce a new type of function (a member function) that makes significant use of this point.</p>
<p>Even with inline functions, you generally should not define global functions in header files.</p>
<h3 id="Function-overloading"><a href="#Function-overloading" class="headerlink" title="Function overloading"></a>Function overloading</h3><p><strong>Function return types are not considered for uniqueness</strong></p>
<p>A function’s return type is NOT considered when overloading functions. (Note for advanced readers: This was an intentional choice, as it ensures the behavior of a function call or subexpression can be determined independently from the rest of the expression, making understanding complex expressions much simpler. Put another way, we can always determine which version of a function will be called based solely on the arguments. If return values were included, then we wouldn’t have an easy syntactic way to tell which version of a function was being called – we’d also have to understand how the return value was being used, which requires a lot more analysis).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getRandomValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// the compiler will flag this as an error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// solution</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomInt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getRandomDouble</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 2 - not recommended</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRandomValue</span><span class="params">(<span class="type">int</span> &amp;out)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRandomValue</span><span class="params">(<span class="type">double</span> &amp;out)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>Types generated by typedef are not distinct, since they don’t introduce new types.</strong> The following two declarations of <code>Print()</code> are considered identical:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *string;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *value)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>How function calls are matched with overloaded functions</strong></p>
<p>Making a call to an overloaded function results in one of three possible outcomes:</p>
<ol>
<li>A match is found. The call is resolved to a particular overloaded function.</li>
<li>No match is found. The arguments cannot be matched to any overloaded function.</li>
<li>An ambiguous match is found. The arguments matched more than one overloaded function.</li>
</ol>
<p>When an overloaded function is called, C++ goes through the following process to determine which version of the function will be called:</p>
<p><strong>First</strong>, C++ tries to find an <code>exact match</code>. This is the case where the actual argument exactly matches the parameter type of one of the overloaded functions. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> value)</span></span>;  <span class="comment">// print(0);  exact match</span></span><br></pre></td></tr></table></figure>

<p><em><em>Although 0 could technically match print(char</em>) (as a null pointer), it exactly matches print(int) (matching char</em> would require an implicit conversion).** Thus print(int) is the best match available.</p>
<p><strong>Secondly</strong>, if no exact match is found, C++ tries to find a match through <code>promotion</code>. To summarize,</p>
<ul>
<li>Char, unsigned char, and short is promoted to an int.</li>
<li>Unsigned short can be promoted to int or unsigned int, depending on the size of an int</li>
<li>Float is promoted to double</li>
<li>Enum is promoted to int</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> value)</span></span>;   <span class="comment">// print(&#x27;a&#x27;);  match this one (char is promoted to int)</span></span><br></pre></td></tr></table></figure>

<p><strong>Thirdly</strong>, if no promotion is possible, C++ tries to find a match through <code>standard conversion</code>. Standard conversions include:</p>
<ul>
<li>Any numeric type will match any other numeric type, including unsigned (e.g. int to float)</li>
<li>Enum will match the formal type of a numeric type (e.g. enum to float)</li>
<li>Zero will match a pointer type and numeric type (e.g. 0 to char*, or 0 to float)</li>
<li>A pointer will match a void pointer</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Employee</span>; <span class="comment">// defined somewhere else</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Employee value)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// &#x27;a&#x27; converted to match print(float)</span></span><br></pre></td></tr></table></figure>

<p><strong>Finally</strong>, C++ tries to find a match through <code>user-defined conversion</code>. Although we have not covered classes yet, classes (which are similar to structs) can define conversions to other types that can be implicitly applied to objects of that class. For example, we might define a class X and a user-defined conversion to int.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>; <span class="comment">// with user-defined conversion to int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">X value; <span class="comment">// declare a variable named value of type class X</span></span><br><span class="line"><span class="built_in">print</span>(value); <span class="comment">// value will be converted to an int and matched to print(int)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.learncpp.com/cpp-tutorial/76-function-overloading/">Ambiguous matches</a></p>
<h3 id="Default-parameters"><a href="#Default-parameters" class="headerlink" title="Default parameters"></a>Default parameters</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y=<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printValues</span>(<span class="number">1</span>); <span class="comment">// y will use default parameter of 10</span></span><br><span class="line">  <span class="built_in">printValues</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// y will use user-supplied value 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A function can have multiple default parameters:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(<span class="type">int</span> x=<span class="number">10</span>, <span class="type">int</span> y=<span class="number">20</span>, <span class="type">int</span> z=<span class="number">30</span>)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Values: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that it is impossible to supply an argument for parameter z without also supplying arguments for parameters x and y. This is because C++ does not support a function call syntax such as printValues(,,3). This has two major consequences:</p>
<ul>
<li><p>All default parameters must be the <code>rightmost</code> parameters. The following is not allowed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> x=<span class="number">10</span>, <span class="type">int</span> y)</span></span>; <span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>If more than one default parameter exists, the leftmost default parameter should be the one most likely to be explicitly set by the user.</p>
</li>
</ul>
<p><strong>Default parameters can only be declared once</strong></p>
<p>Once declared, a default parameter cannot be redeclared. That means for a function with a <code>forward declaration</code> and a <code>function definition</code>, the default parameter can be declared in either the forward declaration or the function definition, but not both.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y=<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y=<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// error: redefinition of default parameter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Default parameters can only be declared once</p>
<p>Once declared, a default parameter cannot be redeclared. That means for a function with a forward declaration and a function definition, the default parameter can be declared in either the forward declaration or the function definition, but not both.</p>
<p><strong>Default parameters and function overloading</strong></p>
<p>Functions with default parameters may be overloaded. For example, the following is allowed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> ch=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If the user were to call print(), it would resolve to print(‘ ‘), which would print a space.</p>
<p><strong>However, it is important to note that default parameters do NOT count towards the parameters that make the function unique</strong>. Consequently, the following is not allowed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y=<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If the caller were to call printValues(10), the compiler would not be able to disambiguate whether the user wanted printValues(int) or printValues(int, 20) with the default value.</p>
<h3 id="Function-Pointers"><a href="#Function-Pointers" class="headerlink" title="Function Pointers"></a>Function Pointers</h3><p>Note that the type (parameters and return type) of the function pointer must match the type of the function. Here are some examples of this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">goo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hoo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// function pointer assignments</span></span><br><span class="line"><span class="built_in">int</span> (*fcnPtr1)() = foo; <span class="comment">// okay</span></span><br><span class="line"><span class="built_in">int</span> (*fcnPtr2)() = goo; <span class="comment">// wrong -- return types don&#x27;t match!</span></span><br><span class="line"><span class="built_in">double</span> (*fcnPtr4)() = goo; <span class="comment">// okay</span></span><br><span class="line">fcnPtr1 = hoo; <span class="comment">// wrong -- fcnPtr1 has no parameters, but hoo() does</span></span><br><span class="line"><span class="built_in">int</span> (*fcnPtr3)(<span class="type">int</span>) = hoo; <span class="comment">// okay</span></span><br></pre></td></tr></table></figure>

<p>Unlike fundamental types, C++ will <strong>implicitly convert a function into a function pointer</strong> if needed (so you don’t need to use the address-of operator (&amp;) to get the function’s address). However, it will not implicitly convert function pointers to void pointers, or vice-versa.</p>
<p>One interesting note: <strong>Default parameters won’t work for functions called through function pointers</strong>. Default parameters are resolved at <code>compile-time</code> (that is, if you don’t supply an argument for a default parameter, the compiler <strong>substitutes</strong> one in for you when the code is compiled). However, function pointers are resolved at run-time. Consequently, default parameters cannot be resolved when making a function call with a function pointer. You’ll explicitly have to pass in values for any defaulted parameters in this case.</p>
<p><strong>Providing default functions</strong></p>
<p>If you’re going to allow the caller to pass in a function as a parameter, it can often be useful to provide some standard functions for the caller to use for their convenience. For example, in the selection sort example above, providing the <code>ascending()</code> and <code>descending()</code> function along with the selectionSort() function would make the callers life easier, as they wouldn’t have to rewrite ascending() or descending() every time they want to use them.</p>
<p>You can even set one of these as a default parameter:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default the sort to ascending sort</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> size, <span class="type">bool</span> (*comparisonFcn)(<span class="type">int</span>, <span class="type">int</span>) = ascending)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>Making function pointers prettier with typedef or type aliases</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*validateFcn)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, validateFcn pfcn)</span> <span class="comment">// clean</span></span></span><br></pre></td></tr></table></figure>

<p>In C++11, you can instead use type aliases to create aliases for function pointers types:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> validateFcn = <span class="built_in">bool</span>(*)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// type alias</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, validateFcn pfcn)</span> <span class="comment">// clean</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>This reads more naturally than the equivalent typedef, since the name of the alias and the alias definition are placed on opposite sides of the equals sign.</p>
<p><strong>Using std::function in C++11</strong></p>
<p>Introduced in C++11, an alternate method of defining and storing function pointers is to use std::function, which is part of the standard library <functional> header. To define a function pointer using this method, declare a std::function object like so:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, std::function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; fcn)</span></span>; <span class="comment">// std::function method that returns a bool and takes two int parameters</span></span><br><span class="line">&lt;<span class="built_in">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; myFunc = test;</span><br></pre></td></tr></table></figure>






<h3 id="The-stack-and-the-heap"><a href="#The-stack-and-the-heap" class="headerlink" title="The stack and the heap"></a>The stack and the heap</h3><p><strong>Stack overflow</strong></p>
<p>The stack has a limited size, and consequently can only hold a limited amount of information. On Windows, the default stack size is 1MB. On some unix machines, it can be as large as 8MB. If the program tries to put too much information on the stack, stack overflow will result. Stack overflow happens when all the memory in the stack has been allocated – in that case, further allocations begin overflowing into other sections of memory.</p>
<p>Here is an example program that will likely cause a stack overflow. You can run it on your system and watch it crash:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stack[<span class="number">100000000</span>];</span><br></pre></td></tr></table></figure>

<p>Another example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>std::vector capacity and stack behavior</strong></p>
<p>Although this is the most useful and commonly used part of std::vector, std::vector has some additional attributes and capabilities that make it useful in some other capacities as well.</p>
<p>Length vs capacity</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>We would say that this array has a length of 10, even though we’re only using 5 of the elements that we allocated.</p>
<p>However, what if we only wanted to iterate over the elements we’ve initialized, reserving the unused ones for future expansion? In that case, we’d need to separately track how many elements were “used” from how many elements were allocated. <code>Unlike a built-in array or a std::array, which only remembers its length, std::vector contains two separate attributes</code>: length and capacity. In the context of a std::vector, length is how many elements are being used in the array, whereas capacity is how many elements were allocated in memory.</p>
<p>Taking a look at an example from the previous lesson on std::vector:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; array &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">array.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">// set length to 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The length is: &quot;</span> &lt;&lt; array.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The length is: &quot;</span> &lt;&lt; array.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The capacity is: &quot;</span> &lt;&lt; array.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>In this case, the resize() function caused the std::vector to change both its length and capacity. Note that the capacity is guaranteed to be at least as large as the array length (but could be larger), otherwise accessing the elements at the end of the array would be outside of the allocated memory!</p>
<p>Why differentiate between length and capacity? std::vector will reallocate its memory if needed, but like Melville’s Bartleby, it would prefer not to, because resizing an array is <code>computationally expensive</code>. Consider the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; array;</span><br><span class="line">array = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// okay, array length = 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;length: &quot;</span> &lt;&lt; array.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;  capacity: &quot;</span> &lt;&lt; array.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">array = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span> &#125;; <span class="comment">// okay, array length is now 3!</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;length: &quot;</span> &lt;&lt; array.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;  capacity: &quot;</span> &lt;&lt; array.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// length: 5  capacity: 5</span></span><br><span class="line"><span class="comment">// length: 3  capacity: 5</span></span><br></pre></td></tr></table></figure>

<p><strong>Array subscripts and at() are based on length, not capacity</strong></p>
<p><strong>Vectors may allocate extra capacity</strong></p>
<p>When a vector is resized, the vector may allocate more capacity than is needed. This is done to provide some “breathing room” for additional elements, to minimize the number of resize operations needed.</p>
<h3 id="Handling-errors-cerr-and-exit"><a href="#Handling-errors-cerr-and-exit" class="headerlink" title="Handling errors, cerr and exit"></a>Handling errors, cerr and exit</h3><p><strong>Problem:</strong> When a function is called, the caller may have passed the function parameters that are semantically meaningless.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cstring)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; cstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Can you identify the assumption that may be violated? The answer is that the caller might pass in a null pointer instead of a valid C-style string. If that happens, the program will crash. Here’s the function again with code that checks to make sure the function parameter is non-null:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cstring)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Only print if cstring is non-null</span></span><br><span class="line">  <span class="keyword">if</span> (cstring)</span><br><span class="line">    std::cout &lt;&lt; cstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cerr</code> is a mechanism that is meant specifically for printing error messages. cerr is an output stream (just like cout) that is defined in <iostream>. Typically, cerr writes the error messages on the screen (just like cout), but it can also be individually redirected to a file.</p>
<p><strong>Assert and static_assert</strong></p>
<p>An assert statement is a <code>preprocessor macro</code> that evaluates a conditional expression at runtime. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// for assert()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getArrayValue</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">10</span>&gt; &amp;array, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// we&#x27;re asserting that index is between 0 and 9</span></span><br><span class="line">  <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="number">9</span>); <span class="comment">// this is line 6 in Test.cpp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Making your assert statements more descriptive</strong></p>
<p>Fortunately, there’s a little trick you can use to make your assert statements more descriptive. Simply add a C-style string description joined with a logical AND:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(found &amp;&amp; <span class="string">&quot;Car could not be found in database&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Here’s why this works: <code>A C-style string always evaluates to boolean true</code>. So if found is false, false &amp;&amp; true &#x3D; false. If found is true, true &amp;&amp; true &#x3D; true. Thus, logical AND-ing a string doesn’t impact the evaluation of the assert.</p>
<p><strong>NDEBUG and other considerations</strong></p>
<p>The assert() function comes with a small performance cost that is incurred each time the assert condition is checked. Furthermore, asserts should (ideally) never be encountered in production code (because your code should already be thoroughly tested). Consequently, many developers prefer that asserts are only active in debug builds. C++ comes with a way to turn off asserts in production code: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG </span></span><br><span class="line"><span class="comment">// all assert() calls will now be ignored to the end of the file</span></span><br></pre></td></tr></table></figure>

<p><strong>Static_assert</strong></p>
<p>C++11 adds another type of assert called static_assert. Unlike assert, which operates at runtime, <code>static_assert is designed to operate at compile time</code>, causing the compiler to error if the condition is not true. If the condition is false, the diagnostic message is printed.</p>
<p>Here’s an example of using static_assert to ensure types have a certain size:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>) == <span class="number">8</span>, <span class="string">&quot;long must be 8 bytes&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int must be 4 bytes&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>A few notes. Because static_assert is evaluated by the compiler, the conditional part of a static_assert must be able to be evaluated at compile time. Because static_assert is not evaluated at runtime, static_assert statements can also be placed anywhere in the code file (even in global space).</p>
<p>In C++11, a diagnostic message <code>must</code> be supplied as the second parameter. In C++17, providing a diagnostic message is <code>optional</code>.</p>
<h3 id="Ellipsis-and-why-to-avoid-them"><a href="#Ellipsis-and-why-to-avoid-them" class="headerlink" title="Ellipsis (and why to avoid them)"></a>Ellipsis (and why to avoid them)</h3><p>The best way to learn about ellipsis is by example. So let’s write a simple program that uses ellipsis. Let’s say we want to write a function that calculates the average of a bunch of integers. We’d do it like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span> <span class="comment">// needed to use ellipsis</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The ellipsis must be the last parameter</span></span><br><span class="line"><span class="comment">// count is how many additional arguments we&#x27;re passing</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">findAverage</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We access the ellipsis through a va_list, so let&#x27;s declare one</span></span><br><span class="line">  va_list list;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We initialize the va_list using va_start.  The first parameter is</span></span><br><span class="line">  <span class="comment">// the list to initialize.  The second parameter is the last non-ellipsis</span></span><br><span class="line">  <span class="comment">// parameter.</span></span><br><span class="line">  <span class="built_in">va_start</span>(list, count);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through all the ellipsis arguments</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> arg=<span class="number">0</span>; arg &lt; count; ++arg)</span><br><span class="line">    <span class="comment">// We use va_arg to get parameters out of our ellipsis</span></span><br><span class="line">    <span class="comment">// The first parameter is the va_list we&#x27;re using</span></span><br><span class="line">    <span class="comment">// The second parameter is the type of the parameter</span></span><br><span class="line">    sum += <span class="built_in">va_arg</span>(list, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cleanup the va_list when we&#x27;re done.</span></span><br><span class="line">  <span class="built_in">va_end</span>(list);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum / count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Junhao Wang
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'junhaow';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
